<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsUdev Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_xs_udev-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsUdev Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for dynamic loading of winusb.  
 <a href="class_xs_udev.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9b6f69bea5ebed79f39e6eaf944a6b1d"><td class="memItemLeft" align="right" valign="top">uDEV_new&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a9b6f69bea5ebed79f39e6eaf944a6b1d">unew</a></td></tr>
<tr class="memdesc:a9b6f69bea5ebed79f39e6eaf944a6b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create udev library context.  <a href="#a9b6f69bea5ebed79f39e6eaf944a6b1d"></a><br/></td></tr>
<tr class="separator:a9b6f69bea5ebed79f39e6eaf944a6b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c08f21f30c188d5f01f632dd05b39b0"><td class="memItemLeft" align="right" valign="top">uDEV_unref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a1c08f21f30c188d5f01f632dd05b39b0">unref</a></td></tr>
<tr class="memdesc:a1c08f21f30c188d5f01f632dd05b39b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference of the udev library context.  <a href="#a1c08f21f30c188d5f01f632dd05b39b0"></a><br/></td></tr>
<tr class="separator:a1c08f21f30c188d5f01f632dd05b39b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a53e5295538962d8d7e28d4b64b65"><td class="memItemLeft" align="right" valign="top">uDEV_device_unref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#afc8a53e5295538962d8d7e28d4b64b65">device_unref</a></td></tr>
<tr class="memdesc:afc8a53e5295538962d8d7e28d4b64b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference of a udev device.  <a href="#afc8a53e5295538962d8d7e28d4b64b65"></a><br/></td></tr>
<tr class="separator:afc8a53e5295538962d8d7e28d4b64b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd926995eaff6e6d39564fa750141fa"><td class="memItemLeft" align="right" valign="top">uDEV_enumerate_new&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#affd926995eaff6e6d39564fa750141fa">enumerate_new</a></td></tr>
<tr class="memdesc:affd926995eaff6e6d39564fa750141fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an enumeration context to scan.  <a href="#affd926995eaff6e6d39564fa750141fa"></a><br/></td></tr>
<tr class="separator:affd926995eaff6e6d39564fa750141fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd70aa75f5b1a043d74b1063d8d9b075"><td class="memItemLeft" align="right" valign="top">uDEV_enumerate_add_match_subsystem&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#afd70aa75f5b1a043d74b1063d8d9b075">enumerate_add_match_subsystem</a></td></tr>
<tr class="memdesc:afd70aa75f5b1a043d74b1063d8d9b075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match only devices belonging to a certain kernel subsystem.  <a href="#afd70aa75f5b1a043d74b1063d8d9b075"></a><br/></td></tr>
<tr class="separator:afd70aa75f5b1a043d74b1063d8d9b075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b14ee457ed7d144a6f6355c0c35e57d"><td class="memItemLeft" align="right" valign="top">uDEV_enumerate_scan_devices&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a4b14ee457ed7d144a6f6355c0c35e57d">enumerate_scan_devices</a></td></tr>
<tr class="memdesc:a4b14ee457ed7d144a6f6355c0c35e57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan /sys for all devices which match the given filters. No matches will return all currently available devices.  <a href="#a4b14ee457ed7d144a6f6355c0c35e57d"></a><br/></td></tr>
<tr class="separator:a4b14ee457ed7d144a6f6355c0c35e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539e445e4146cb53d47fddadf7c6df82"><td class="memItemLeft" align="right" valign="top">uDEV_enumerate_get_list_entry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a539e445e4146cb53d47fddadf7c6df82">enumerate_get_list_entry</a></td></tr>
<tr class="memdesc:a539e445e4146cb53d47fddadf7c6df82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first entry of the sorted list of device paths.  <a href="#a539e445e4146cb53d47fddadf7c6df82"></a><br/></td></tr>
<tr class="separator:a539e445e4146cb53d47fddadf7c6df82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c5d11dfd106d0a69e9a0ea056b8c3f"><td class="memItemLeft" align="right" valign="top">uDEV_enumerate_unref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a99c5d11dfd106d0a69e9a0ea056b8c3f">enumerate_unref</a></td></tr>
<tr class="memdesc:a99c5d11dfd106d0a69e9a0ea056b8c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference of an enumeration context.  <a href="#a99c5d11dfd106d0a69e9a0ea056b8c3f"></a><br/></td></tr>
<tr class="separator:a99c5d11dfd106d0a69e9a0ea056b8c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73bbdf25bf120299b358aab893a4ee1"><td class="memItemLeft" align="right" valign="top">uDEV_list_entry_get_next&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#aa73bbdf25bf120299b358aab893a4ee1">list_entry_get_next</a></td></tr>
<tr class="memdesc:aa73bbdf25bf120299b358aab893a4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next entry from the list.  <a href="#aa73bbdf25bf120299b358aab893a4ee1"></a><br/></td></tr>
<tr class="separator:aa73bbdf25bf120299b358aab893a4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cceaa6bdcd0e869c4612267976d6608"><td class="memItemLeft" align="right" valign="top">uDEV_list_entry_get_name&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a1cceaa6bdcd0e869c4612267976d6608">list_entry_get_name</a></td></tr>
<tr class="memdesc:a1cceaa6bdcd0e869c4612267976d6608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a list entry.  <a href="#a1cceaa6bdcd0e869c4612267976d6608"></a><br/></td></tr>
<tr class="separator:a1cceaa6bdcd0e869c4612267976d6608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad11ffa24d307437f770a717c0d21d58"><td class="memItemLeft" align="right" valign="top">uDEV_device_new_from_syspath&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#aad11ffa24d307437f770a717c0d21d58">device_new_from_syspath</a></td></tr>
<tr class="memdesc:aad11ffa24d307437f770a717c0d21d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new udev device, and fill in information from the sys device and the udev database entry.  <a href="#aad11ffa24d307437f770a717c0d21d58"></a><br/></td></tr>
<tr class="separator:aad11ffa24d307437f770a717c0d21d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0b9a2b732554c19bd7d4bc85d38527"><td class="memItemLeft" align="right" valign="top">uDEV_device_get_parent&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#aff0b9a2b732554c19bd7d4bc85d38527">device_get_parent</a></td></tr>
<tr class="memdesc:aff0b9a2b732554c19bd7d4bc85d38527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next parent device, and fill in information from the sys device and the udev database entry.  <a href="#aff0b9a2b732554c19bd7d4bc85d38527"></a><br/></td></tr>
<tr class="separator:aff0b9a2b732554c19bd7d4bc85d38527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b8dd1c7db64f40b45f3db41409765c"><td class="memItemLeft" align="right" valign="top">uDEV_device_get_devnode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#ad5b8dd1c7db64f40b45f3db41409765c">device_get_devnode</a></td></tr>
<tr class="memdesc:ad5b8dd1c7db64f40b45f3db41409765c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the device node file name belonging to the udev device.  <a href="#ad5b8dd1c7db64f40b45f3db41409765c"></a><br/></td></tr>
<tr class="separator:ad5b8dd1c7db64f40b45f3db41409765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71feebbc676115a50fd3ebf078907b5b"><td class="memItemLeft" align="right" valign="top">uDEV_device_get_parent_with_subsystem_devtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#a71feebbc676115a50fd3ebf078907b5b">device_get_parent_with_subsystem_devtype</a></td></tr>
<tr class="memdesc:a71feebbc676115a50fd3ebf078907b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next parent device, with a matching subsystem and devtypevalue, and fill in information from the sys device and the udev database entry.  <a href="#a71feebbc676115a50fd3ebf078907b5b"></a><br/></td></tr>
<tr class="separator:a71feebbc676115a50fd3ebf078907b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d0381e864b9b01da9ea99ac2f2e0bf"><td class="memItemLeft" align="right" valign="top">uDEV_device_get_sysattr_value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_udev.html#ad4d0381e864b9b01da9ea99ac2f2e0bf">device_get_sysattr_value</a></td></tr>
<tr class="memdesc:ad4d0381e864b9b01da9ea99ac2f2e0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sys attribute value.  <a href="#ad4d0381e864b9b01da9ea99ac2f2e0bf"></a><br/></td></tr>
<tr class="separator:ad4d0381e864b9b01da9ea99ac2f2e0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for dynamic loading of winusb. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad5b8dd1c7db64f40b45f3db41409765c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * XsUdev::device_get_devnode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the device node file name belonging to the udev device. </p>
<p>The path is an absolute path, and starts with the device directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_device</td><td>udev device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device node file name of the udev device, or NULL if no device node exists </dd></dl>

</div>
</div>
<a class="anchor" id="aff0b9a2b732554c19bd7d4bc85d38527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_device * XsUdev::device_get_parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next parent device, and fill in information from the sys device and the udev database entry. </p>
<p>Returned device is not referenced. It is attached to the child device, and will be cleaned up when the child device is cleaned up. It is not necessarily just the upper level directory, empty or not recognized sys directories are ignored.</p>
<p>It can be called as many times as needed, without caring about references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_device,:</td><td>the device to start searching from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new udev device, or NULL, if it no parent exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a71feebbc676115a50fd3ebf078907b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_device * XsUdev::device_get_parent_with_subsystem_devtype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next parent device, with a matching subsystem and devtypevalue, and fill in information from the sys device and the udev database entry. </p>
<p>If devtype is NULL, only subsystem is checked, and any devtype will match.</p>
<p>Returned device is not referenced. It is attached to the child device, and will be cleaned up when the child device is cleaned up.</p>
<p>It can be called as many times as needed, without caring about references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_device</td><td>udev device to start searching from </td></tr>
    <tr><td class="paramname">subsystem</td><td>the subsystem of the device </td></tr>
    <tr><td class="paramname">devtype</td><td>the type (DEVTYPE) of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new udev device, or NULL if no matching parent exists. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d0381e864b9b01da9ea99ac2f2e0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * XsUdev::device_get_sysattr_value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sys attribute value. </p>
<p>The retrieved value is cached in the device. Repeated calls will return the same value and not open the attribute again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_device</td><td>udev device </td></tr>
    <tr><td class="paramname">sysattr</td><td>attribute name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the content of a sys attribute file, or NULL if there is no sys attribute value. </dd></dl>

</div>
</div>
<a class="anchor" id="aad11ffa24d307437f770a717c0d21d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_device * XsUdev::device_new_from_syspath</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new udev device, and fill in information from the sys device and the udev database entry. </p>
<p>The syspath is the absolute path to the device, including the sys mount point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev</td><td>udev library context </td></tr>
    <tr><td class="paramname">syspath</td><td>sys device path including sys directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new udev device, or NULL, if it does not exist </dd></dl>

</div>
</div>
<a class="anchor" id="afc8a53e5295538962d8d7e28d4b64b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_device * XsUdev::device_unref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference of a udev device. </p>
<p>If the refcount reaches zero, the resources of the device will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_device</td><td>udev device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL </dd></dl>

</div>
</div>
<a class="anchor" id="afd70aa75f5b1a043d74b1063d8d9b075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsUdev::enumerate_add_match_subsystem</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match only devices belonging to a certain kernel subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_enumerate</td><td>context </td></tr>
    <tr><td class="paramname">subsystem</td><td>filter for a subsystem of the device to include in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: 0 on success, otherwise a negative error value. </dd></dl>

</div>
</div>
<a class="anchor" id="a539e445e4146cb53d47fddadf7c6df82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_list_entry * XsUdev::enumerate_get_list_entry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first entry of the sorted list of device paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_enumerate</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a udev_list_entry. </dd></dl>

</div>
</div>
<a class="anchor" id="affd926995eaff6e6d39564fa750141fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_enumerate * XsUdev::enumerate_new</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an enumeration context to scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev</td><td>udev library context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an enumeration context. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b14ee457ed7d144a6f6355c0c35e57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsUdev::enumerate_scan_devices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan /sys for all devices which match the given filters. No matches will return all currently available devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_enumerate</td><td>udev enumeration context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise a negative error value. </dd></dl>

</div>
</div>
<a class="anchor" id="a99c5d11dfd106d0a69e9a0ea056b8c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_enumerate * XsUdev::enumerate_unref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference of an enumeration context. </p>
<p>If the refcount reaches zero, all resources of the enumeration context will be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev_enumerate</td><td>context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a1cceaa6bdcd0e869c4612267976d6608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * XsUdev::list_entry_get_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a list entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_entry,:</td><td>current entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name string of this entry. </dd></dl>

</div>
</div>
<a class="anchor" id="aa73bbdf25bf120299b358aab893a4ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev_list_entry * XsUdev::list_entry_get_next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next entry from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_entry</td><td>current entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>udev_list_entry, NULL if no more entries are available. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b6f69bea5ebed79f39e6eaf944a6b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev * XsUdev::unew</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create udev library context. </p>
<p>This reads the udev configuration file, and fills in the default values.</p>
<p>The initial refcount is 1, and needs to be decremented to release the resources of the udev library context.</p>
<dl class="section return"><dt>Returns</dt><dd>a new udev library context </dd></dl>

</div>
</div>
<a class="anchor" id="a1c08f21f30c188d5f01f632dd05b39b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">udev * XsUdev::unref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference of the udev library context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udev</td><td>udev library context</td></tr>
  </table>
  </dd>
</dl>
<p>If the refcount reaches zero, the resources of the context will be released. </p>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Wed Jan 8 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
