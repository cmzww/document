<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>C Interface</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">C Interface</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae8321d23871bd495a735cccbac26b451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8321d23871bd495a735cccbac26b451"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae8321d23871bd495a735cccbac26b451">XS_BID_MASTER</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:gae8321d23871bd495a735cccbac26b451"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus identifier of the master device. <br/></td></tr>
<tr class="separator:gae8321d23871bd495a735cccbac26b451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cefb784042cbd1494268a2735c095f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga44cefb784042cbd1494268a2735c095f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga44cefb784042cbd1494268a2735c095f">XS_BID_BROADCAST</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga44cefb784042cbd1494268a2735c095f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus broadcast bus identifier (all devices) <br/></td></tr>
<tr class="separator:ga44cefb784042cbd1494268a2735c095f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9478ee24f1f927f712dd4ad6caa7bc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9478ee24f1f927f712dd4ad6caa7bc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab9478ee24f1f927f712dd4ad6caa7bc7">XS_BID_MT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:gab9478ee24f1f927f712dd4ad6caa7bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus identifier for the first MT on the bus. <br/></td></tr>
<tr class="separator:gab9478ee24f1f927f712dd4ad6caa7bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccb6071d965b3115cf7e696e70b0292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ccb6071d965b3115cf7e696e70b0292"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5ccb6071d965b3115cf7e696e70b0292">XS_BID_INVALID</a>&#160;&#160;&#160;0xFE</td></tr>
<tr class="memdesc:ga5ccb6071d965b3115cf7e696e70b0292"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid bus identifier. <br/></td></tr>
<tr class="separator:ga5ccb6071d965b3115cf7e696e70b0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e67937a1394ad0c13d4d8f6b6f1d67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74e67937a1394ad0c13d4d8f6b6f1d67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga74e67937a1394ad0c13d4d8f6b6f1d67">XsFileHandle</a>&#160;&#160;&#160;FILE</td></tr>
<tr class="memdesc:ga74e67937a1394ad0c13d4d8f6b6f1d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that is used for low-level identification of an open file. <br/></td></tr>
<tr class="separator:ga74e67937a1394ad0c13d4d8f6b6f1d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaee1db0cf1b8591c59afba7a3a0d13eb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee1db0cf1b8591c59afba7a3a0d13eb9"></a>
typedef __off64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a></td></tr>
<tr class="memdesc:gaee1db0cf1b8591c59afba7a3a0d13eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that is used for positioning inside a file. <br/></td></tr>
<tr class="separator:gaee1db0cf1b8591c59afba7a3a0d13eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8caac814a4ee656f1774ad23ccc5f16e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8caac814a4ee656f1774ad23ccc5f16e"></a>
typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8caac814a4ee656f1774ad23ccc5f16e">XsIoHandle</a></td></tr>
<tr class="memdesc:ga8caac814a4ee656f1774ad23ccc5f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that is used for low-level identification of an open I/O device. <br/></td></tr>
<tr class="separator:ga8caac814a4ee656f1774ad23ccc5f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga064199357e05d84f2304ade2474ac155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga064199357e05d84f2304ade2474ac155"></a>
<a class="el" href="group__enums.html#ga1fc44ee1e71b670b03e72c77ba693f5e">XsSyncLine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga064199357e05d84f2304ade2474ac155">xsl4ToXsl</a> (<a class="el" href="group__enums.html#gaa8f8a207b76aad9bd7f5a1de45cfa66e">SyncLineMk4</a> mk4Line)</td></tr>
<tr class="memdesc:ga064199357e05d84f2304ade2474ac155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an SyncLineMk4 into a generic XsSyncLine. <br/></td></tr>
<tr class="separator:ga064199357e05d84f2304ade2474ac155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1d3d05253bd82f7f9bc61f941cafde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d1d3d05253bd82f7f9bc61f941cafde"></a>
<a class="el" href="group__enums.html#gaa8f8a207b76aad9bd7f5a1de45cfa66e">SyncLineMk4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8d1d3d05253bd82f7f9bc61f941cafde">xslToXsl4</a> (<a class="el" href="group__enums.html#ga1fc44ee1e71b670b03e72c77ba693f5e">XsSyncLine</a> line)</td></tr>
<tr class="memdesc:ga8d1d3d05253bd82f7f9bc61f941cafde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an XsSyncLine into a Mk4-specififc SyncLineMk4. <br/></td></tr>
<tr class="separator:ga8d1d3d05253bd82f7f9bc61f941cafde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704fac796d6899e53094d97403927442"><td class="memItemLeft" align="right" valign="top">XsBaudRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga704fac796d6899e53094d97403927442">XsBaud_codeToRate</a> (XsBaudCode baudcode)</td></tr>
<tr class="memdesc:ga704fac796d6899e53094d97403927442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Xsens baud code to XsBaudRate.  <a href="#ga704fac796d6899e53094d97403927442"></a><br/></td></tr>
<tr class="separator:ga704fac796d6899e53094d97403927442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa587d7e451a00e7a3c2c4432c346cf9b"><td class="memItemLeft" align="right" valign="top">XsBaudCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa587d7e451a00e7a3c2c4432c346cf9b">XsBaud_rateToCode</a> (XsBaudRate baudrate)</td></tr>
<tr class="memdesc:gaa587d7e451a00e7a3c2c4432c346cf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XsBaudRate to an Xsens baud code.  <a href="#gaa587d7e451a00e7a3c2c4432c346cf9b"></a><br/></td></tr>
<tr class="separator:gaa587d7e451a00e7a3c2c4432c346cf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532744ada4da5b1e9c8a277cc98628a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga532744ada4da5b1e9c8a277cc98628a1">XsBaud_rateToNumeric</a> (XsBaudRate baudrate)</td></tr>
<tr class="memdesc:ga532744ada4da5b1e9c8a277cc98628a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XsBaudrate to a numeric baudrate in bps.  <a href="#ga532744ada4da5b1e9c8a277cc98628a1"></a><br/></td></tr>
<tr class="separator:ga532744ada4da5b1e9c8a277cc98628a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7439bd0c058b38ce73d843d39fcef299"><td class="memItemLeft" align="right" valign="top">XsBaudRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7439bd0c058b38ce73d843d39fcef299">XsBaud_numericToRate</a> (int numeric)</td></tr>
<tr class="memdesc:ga7439bd0c058b38ce73d843d39fcef299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a numeric baudrate in bps to XsBaudrate.  <a href="#ga7439bd0c058b38ce73d843d39fcef299"></a><br/></td></tr>
<tr class="separator:ga7439bd0c058b38ce73d843d39fcef299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6a5994363a3d4d175eb5a4d42d7452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafb6a5994363a3d4d175eb5a4d42d7452">validatePacket</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gafb6a5994363a3d4d175eb5a4d42d7452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the packet is internally consistent.  <a href="#gafb6a5994363a3d4d175eb5a4d42d7452"></a><br/></td></tr>
<tr class="separator:gafb6a5994363a3d4d175eb5a4d42d7452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6333be127f949ebb5c3cc3839046a86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6333be127f949ebb5c3cc3839046a86b">XsDataPacket_originalMessage</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_message.html">XsMessage</a> *returnVal)</td></tr>
<tr class="memdesc:ga6333be127f949ebb5c3cc3839046a86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the original message of the data packet.  <a href="#ga6333be127f949ebb5c3cc3839046a86b"></a><br/></td></tr>
<tr class="separator:ga6333be127f949ebb5c3cc3839046a86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743130ab33839e30144cbe2a001153e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga743130ab33839e30144cbe2a001153e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga743130ab33839e30144cbe2a001153e6">XsDataPacket_setCalibratedGyroscopeData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *vec)</td></tr>
<tr class="memdesc:ga743130ab33839e30144cbe2a001153e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated gyroscope data for the item. <br/></td></tr>
<tr class="separator:ga743130ab33839e30144cbe2a001153e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d4ab0b8f1d7fcf2a0d37334dd9e827"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46d4ab0b8f1d7fcf2a0d37334dd9e827"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga46d4ab0b8f1d7fcf2a0d37334dd9e827">XsDataPacket_containsRawGpsSvInfo</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga46d4ab0b8f1d7fcf2a0d37334dd9e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if data item contains RawGpsSvInfo, 0 otherwise. <br/></td></tr>
<tr class="separator:ga46d4ab0b8f1d7fcf2a0d37334dd9e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794947de84c8458cff16f5d7fdd822d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga794947de84c8458cff16f5d7fdd822d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga794947de84c8458cff16f5d7fdd822d8">XsDeviceId_swap</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *a, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *b)</td></tr>
<tr class="memdesc:ga794947de84c8458cff16f5d7fdd822d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with those of <em>b</em>. <br/></td></tr>
<tr class="separator:ga794947de84c8458cff16f5d7fdd822d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ea691e74bd5a68076550bb0f430982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2ea691e74bd5a68076550bb0f430982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab2ea691e74bd5a68076550bb0f430982">XsGpsPvtData_destruct</a> (<a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *)</td></tr>
<tr class="memdesc:gab2ea691e74bd5a68076550bb0f430982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the XsGpsPvtData object. <br/></td></tr>
<tr class="separator:gab2ea691e74bd5a68076550bb0f430982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabab8128b0e6f7c584434fa35f9ca51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabab8128b0e6f7c584434fa35f9ca51a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaabab8128b0e6f7c584434fa35f9ca51a">XsGpsPvtData_empty</a> (const <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *)</td></tr>
<tr class="memdesc:gaabab8128b0e6f7c584434fa35f9ca51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object is empty (when it contains no valid data) <br/></td></tr>
<tr class="separator:gaabab8128b0e6f7c584434fa35f9ca51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e8d38925c77861ac921a55a4ad88db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e8d38925c77861ac921a55a4ad88db1"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3e8d38925c77861ac921a55a4ad88db1">XsMath_asinClamped</a> (XsReal x)</td></tr>
<tr class="memdesc:ga3e8d38925c77861ac921a55a4ad88db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns asin(<em>x</em>) for -1 &lt; x &lt; 1. <br/></td></tr>
<tr class="separator:ga3e8d38925c77861ac921a55a4ad88db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07528eb38651ea5364ffe8379f367d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07528eb38651ea5364ffe8379f367d24"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga07528eb38651ea5364ffe8379f367d24">XsMath_rad2deg</a> (XsReal radians)</td></tr>
<tr class="memdesc:ga07528eb38651ea5364ffe8379f367d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees. <br/></td></tr>
<tr class="separator:ga07528eb38651ea5364ffe8379f367d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbe79a94b1933aaf41935bc1bedaf42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7fbe79a94b1933aaf41935bc1bedaf42"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7fbe79a94b1933aaf41935bc1bedaf42">XsMath_deg2rad</a> (XsReal degrees)</td></tr>
<tr class="memdesc:ga7fbe79a94b1933aaf41935bc1bedaf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians. <br/></td></tr>
<tr class="separator:ga7fbe79a94b1933aaf41935bc1bedaf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8525444555a88e7edec98360b0034a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8525444555a88e7edec98360b0034a10"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8525444555a88e7edec98360b0034a10">XsMath_pow2</a> (XsReal a)</td></tr>
<tr class="memdesc:ga8525444555a88e7edec98360b0034a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>a</em> to the power of 2. <br/></td></tr>
<tr class="separator:ga8525444555a88e7edec98360b0034a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a54cd145e7cc021d5e236d4a3923a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80a54cd145e7cc021d5e236d4a3923a7"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga80a54cd145e7cc021d5e236d4a3923a7">XsMath_pow3</a> (XsReal a)</td></tr>
<tr class="memdesc:ga80a54cd145e7cc021d5e236d4a3923a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>a</em> to the power of 3. <br/></td></tr>
<tr class="separator:ga80a54cd145e7cc021d5e236d4a3923a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56aa58d530cc4f0d696a910adfaaa967"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56aa58d530cc4f0d696a910adfaaa967"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga56aa58d530cc4f0d696a910adfaaa967">XsMath_isFinite</a> (XsReal x)</td></tr>
<tr class="memdesc:ga56aa58d530cc4f0d696a910adfaaa967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if <em>x</em> is finite. <br/></td></tr>
<tr class="separator:ga56aa58d530cc4f0d696a910adfaaa967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd92ddfc40f528d4e30d01ec721b9f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd92ddfc40f528d4e30d01ec721b9f59"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacd92ddfc40f528d4e30d01ec721b9f59">XsMath_doubleToLong</a> (double d)</td></tr>
<tr class="memdesc:gacd92ddfc40f528d4e30d01ec721b9f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>d</em> integer converted from a double precision floating point value. <br/></td></tr>
<tr class="separator:gacd92ddfc40f528d4e30d01ec721b9f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519431d337ff6d61c6c1a0b404496395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga519431d337ff6d61c6c1a0b404496395"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga519431d337ff6d61c6c1a0b404496395">XsMath_doubleToInt64</a> (double d)</td></tr>
<tr class="memdesc:ga519431d337ff6d61c6c1a0b404496395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>d</em> integer converted from a double precision floating point value. <br/></td></tr>
<tr class="separator:ga519431d337ff6d61c6c1a0b404496395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1dfbf570dd9179d632bbf3fd163a483"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac1dfbf570dd9179d632bbf3fd163a483">byteSum</a> (const uint8_t *buffer, XsSize count)</td></tr>
<tr class="memdesc:gac1dfbf570dd9179d632bbf3fd163a483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the sum of the values in the buffer.  <a href="#gac1dfbf570dd9179d632bbf3fd163a483"></a><br/></td></tr>
<tr class="separator:gac1dfbf570dd9179d632bbf3fd163a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3aff1ac742c36f378747f4df0a7eb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3aff1ac742c36f378747f4df0a7eb65">XsMessage_constructSized</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize dataSize)</td></tr>
<tr class="memdesc:gaf3aff1ac742c36f378747f4df0a7eb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the XsMessage object and reserves <em>dataSize</em> bytes for data.  <a href="#gaf3aff1ac742c36f378747f4df0a7eb65"></a><br/></td></tr>
<tr class="separator:gaf3aff1ac742c36f378747f4df0a7eb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac09517b80fdf0c2195dd6c834438bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac09517b80fdf0c2195dd6c834438bb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaac09517b80fdf0c2195dd6c834438bb2">XsMessage_construct</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:gaac09517b80fdf0c2195dd6c834438bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the XsMessage object. <br/></td></tr>
<tr class="separator:gaac09517b80fdf0c2195dd6c834438bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5bfc5759c761cf73988915a1aa01ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f5bfc5759c761cf73988915a1aa01ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6f5bfc5759c761cf73988915a1aa01ba">XsMessage_copyConstruct</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, <a class="el" href="struct_xs_message.html">XsMessage</a> const *src)</td></tr>
<tr class="memdesc:ga6f5bfc5759c761cf73988915a1aa01ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> as a copy of <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> <em>src</em>. <br/></td></tr>
<tr class="separator:ga6f5bfc5759c761cf73988915a1aa01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da904b977b09ad3aaa4e32c4672cd12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9da904b977b09ad3aaa4e32c4672cd12">XsMessage_assign</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize dataSize)</td></tr>
<tr class="memdesc:ga9da904b977b09ad3aaa4e32c4672cd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reinitializes the XsMessage object and reserves <em>dataSize</em> bytes for data.  <a href="#ga9da904b977b09ad3aaa4e32c4672cd12"></a><br/></td></tr>
<tr class="separator:ga9da904b977b09ad3aaa4e32c4672cd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4dde94962cb03ca78d207d7ed7f5b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4dde94962cb03ca78d207d7ed7f5b46">XsMessage_load</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize msgSize, unsigned char const *src)</td></tr>
<tr class="memdesc:gad4dde94962cb03ca78d207d7ed7f5b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the XsMessage object and reserves <em>msgSize</em> bytes for data, it then copies in the data from <em>src</em>.  <a href="#gad4dde94962cb03ca78d207d7ed7f5b46"></a><br/></td></tr>
<tr class="separator:gad4dde94962cb03ca78d207d7ed7f5b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee251864355965b32fe3af9fa07e2419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee251864355965b32fe3af9fa07e2419">XsMessage_destruct</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:gaee251864355965b32fe3af9fa07e2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the data in the message.  <a href="#gaee251864355965b32fe3af9fa07e2419"></a><br/></td></tr>
<tr class="separator:gaee251864355965b32fe3af9fa07e2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5926dcf4e25e601ae0059b95afc5e226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5926dcf4e25e601ae0059b95afc5e226">XsMessage_copy</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *copy, <a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga5926dcf4e25e601ae0059b95afc5e226"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies from <em>thisPtr</em> to <em>copy</em>.  <a href="#ga5926dcf4e25e601ae0059b95afc5e226"></a><br/></td></tr>
<tr class="separator:ga5926dcf4e25e601ae0059b95afc5e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ca57ead95b63178f60835f2374039e"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa4ca57ead95b63178f60835f2374039e">XsMessage_dataSize</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:gaa4ca57ead95b63178f60835f2374039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the datasize of the message in <em>thisptr</em>.  <a href="#gaa4ca57ead95b63178f60835f2374039e"></a><br/></td></tr>
<tr class="separator:gaa4ca57ead95b63178f60835f2374039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02356a5cefd94aa7719c39ba9692b598"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga02356a5cefd94aa7719c39ba9692b598">XsMessage_constData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga02356a5cefd94aa7719c39ba9692b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a const pointer to the <em>offset</em> in the data of the message in <em>thisptr</em>.  <a href="#ga02356a5cefd94aa7719c39ba9692b598"></a><br/></td></tr>
<tr class="separator:ga02356a5cefd94aa7719c39ba9692b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ef5f47b2fe7bca6d550001b5b09296"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4ef5f47b2fe7bca6d550001b5b09296">XsMessage_getMessageStart</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:gad4ef5f47b2fe7bca6d550001b5b09296"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a const pointer to the header of the message in <em>thisptr</em>.  <a href="#gad4ef5f47b2fe7bca6d550001b5b09296"></a><br/></td></tr>
<tr class="separator:gad4ef5f47b2fe7bca6d550001b5b09296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd01bb00c8b697a56aafc443c1ddfd4"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5dd01bb00c8b697a56aafc443c1ddfd4">XsMessage_getTotalMessageSize</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga5dd01bb00c8b697a56aafc443c1ddfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the message buffer.  <a href="#ga5dd01bb00c8b697a56aafc443c1ddfd4"></a><br/></td></tr>
<tr class="separator:ga5dd01bb00c8b697a56aafc443c1ddfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ca4b85ce514c4688055917e7ec0591"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga91ca4b85ce514c4688055917e7ec0591">XsMessage_getDataByte</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga91ca4b85ce514c4688055917e7ec0591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte value at <em>offset</em> in the data of the message.  <a href="#ga91ca4b85ce514c4688055917e7ec0591"></a><br/></td></tr>
<tr class="separator:ga91ca4b85ce514c4688055917e7ec0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc53fffde12da101d13f3528111e1dcf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc53fffde12da101d13f3528111e1dcf">XsMessage_getDataShort</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:gabc53fffde12da101d13f3528111e1dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the short value at <em>offset</em> in the data of the message.  <a href="#gabc53fffde12da101d13f3528111e1dcf"></a><br/></td></tr>
<tr class="separator:gabc53fffde12da101d13f3528111e1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d5a40697d57c0da08e1d21c82fb6e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga42d5a40697d57c0da08e1d21c82fb6e6">XsMessage_getDataLong</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga42d5a40697d57c0da08e1d21c82fb6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the long value at <em>offset</em> in the data of the message.  <a href="#ga42d5a40697d57c0da08e1d21c82fb6e6"></a><br/></td></tr>
<tr class="separator:ga42d5a40697d57c0da08e1d21c82fb6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd25a9320f3fbfabcd193bff5b5185c6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd25a9320f3fbfabcd193bff5b5185c6">XsMessage_getDataFloat</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:gafd25a9320f3fbfabcd193bff5b5185c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the float value at <em>offset</em> in the data of the message.  <a href="#gafd25a9320f3fbfabcd193bff5b5185c6"></a><br/></td></tr>
<tr class="separator:gafd25a9320f3fbfabcd193bff5b5185c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b548351bd3eb7e86187679ac83f572"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga73b548351bd3eb7e86187679ac83f572">XsMessage_getDataDouble</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga73b548351bd3eb7e86187679ac83f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double at <em>offset</em> in the data of the message.  <a href="#ga73b548351bd3eb7e86187679ac83f572"></a><br/></td></tr>
<tr class="separator:ga73b548351bd3eb7e86187679ac83f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf009aeda779d5955bba969390a1fe8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0cf009aeda779d5955bba969390a1fe8">XsMessage_getDataF1220</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga0cf009aeda779d5955bba969390a1fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the F12.20 value at <em>offset</em> in the data of the message.  <a href="#ga0cf009aeda779d5955bba969390a1fe8"></a><br/></td></tr>
<tr class="separator:ga0cf009aeda779d5955bba969390a1fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127c683e09b2db4ce8e161949e778bb1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga127c683e09b2db4ce8e161949e778bb1">XsMessage_getDataFP1632</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga127c683e09b2db4ce8e161949e778bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the F16.32 value at <em>offset</em> in the data of the message.  <a href="#ga127c683e09b2db4ce8e161949e778bb1"></a><br/></td></tr>
<tr class="separator:ga127c683e09b2db4ce8e161949e778bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1ab9a85f8b5c16a798d8920f1b69c8"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3e1ab9a85f8b5c16a798d8920f1b69c8">XsMessage_getDataBuffer</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga3e1ab9a85f8b5c16a798d8920f1b69c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data buffer of the message.  <a href="#ga3e1ab9a85f8b5c16a798d8920f1b69c8"></a><br/></td></tr>
<tr class="separator:ga3e1ab9a85f8b5c16a798d8920f1b69c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23c89aa06c089d2fec7a4d11c573fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa23c89aa06c089d2fec7a4d11c573fd5">XsMessage_setDataByte</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint8_t value, XsSize offset)</td></tr>
<tr class="memdesc:gaa23c89aa06c089d2fec7a4d11c573fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the byte at <em>offset</em> in the message to <em>value</em>.  <a href="#gaa23c89aa06c089d2fec7a4d11c573fd5"></a><br/></td></tr>
<tr class="separator:gaa23c89aa06c089d2fec7a4d11c573fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359dc1326aa818e5168db40264d80502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga359dc1326aa818e5168db40264d80502">XsMessage_setDataShort</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint16_t value, XsSize offset)</td></tr>
<tr class="memdesc:ga359dc1326aa818e5168db40264d80502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the short at <em>offset</em> in the message to <em>value</em>.  <a href="#ga359dc1326aa818e5168db40264d80502"></a><br/></td></tr>
<tr class="separator:ga359dc1326aa818e5168db40264d80502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64de205a7a48f0b109856f2e105e7ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga64de205a7a48f0b109856f2e105e7ffa">XsMessage_setDataLong</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint32_t value, XsSize offset)</td></tr>
<tr class="memdesc:ga64de205a7a48f0b109856f2e105e7ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the long at <em>offset</em> in the message to <em>value</em>.  <a href="#ga64de205a7a48f0b109856f2e105e7ffa"></a><br/></td></tr>
<tr class="separator:ga64de205a7a48f0b109856f2e105e7ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1234b6e6d4411d8b0c702fa440841ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1234b6e6d4411d8b0c702fa440841ee9">XsMessage_setDataFloat</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, float value, XsSize offset)</td></tr>
<tr class="memdesc:ga1234b6e6d4411d8b0c702fa440841ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the float at <em>offset</em> in the message to <em>value</em>.  <a href="#ga1234b6e6d4411d8b0c702fa440841ee9"></a><br/></td></tr>
<tr class="separator:ga1234b6e6d4411d8b0c702fa440841ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga497e871bda0c859a73dfe1f1e29de6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga497e871bda0c859a73dfe1f1e29de6a1">XsMessage_setDataDouble</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, double value, XsSize offset)</td></tr>
<tr class="memdesc:ga497e871bda0c859a73dfe1f1e29de6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the double at <em>offset</em> in the message to <em>value</em>.  <a href="#ga497e871bda0c859a73dfe1f1e29de6a1"></a><br/></td></tr>
<tr class="separator:ga497e871bda0c859a73dfe1f1e29de6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366d27f459a11717add7e69ee6c85878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga366d27f459a11717add7e69ee6c85878">XsMessage_setDataF1220</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, double value, XsSize offset)</td></tr>
<tr class="memdesc:ga366d27f459a11717add7e69ee6c85878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the F12.20 at <em>offset</em> in the message to <em>value</em>.  <a href="#ga366d27f459a11717add7e69ee6c85878"></a><br/></td></tr>
<tr class="separator:ga366d27f459a11717add7e69ee6c85878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69a92d482776fa1c730e6dc1247e5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf69a92d482776fa1c730e6dc1247e5f7">XsMessage_setDataFP1632</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, double value, XsSize offset)</td></tr>
<tr class="memdesc:gaf69a92d482776fa1c730e6dc1247e5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the F16.32 at <em>offset</em> in the message to <em>value</em>.  <a href="#gaf69a92d482776fa1c730e6dc1247e5f7"></a><br/></td></tr>
<tr class="separator:gaf69a92d482776fa1c730e6dc1247e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68055a504cd3ad0108b216d7ec447fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab68055a504cd3ad0108b216d7ec447fe">XsMessage_setDataBuffer</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, const uint8_t *buffer, XsSize size, XsSize offset)</td></tr>
<tr class="memdesc:gab68055a504cd3ad0108b216d7ec447fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts <em>size</em> number of bytes from <em>buffer</em> into the message at <em>offset</em>.  <a href="#gab68055a504cd3ad0108b216d7ec447fe"></a><br/></td></tr>
<tr class="separator:gab68055a504cd3ad0108b216d7ec447fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c80c694ccbad9cc68b216a318a85463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1c80c694ccbad9cc68b216a318a85463">XsMessage_getDataFPValues</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, uint64_t outputSettings, double *dest, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:ga1c80c694ccbad9cc68b216a318a85463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current data values as a double(64 bits), after converting it from float, double, FP1632 or FP1220 depending on outputSettings.  <a href="#ga1c80c694ccbad9cc68b216a318a85463"></a><br/></td></tr>
<tr class="separator:ga1c80c694ccbad9cc68b216a318a85463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04bcae80049f7b33e84ebdffc116b321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga04bcae80049f7b33e84ebdffc116b321">XsMessage_setDataFPValues</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint64_t outputSettings, double const *data, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:ga04bcae80049f7b33e84ebdffc116b321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a floating/fixed point value into to the data buffer, conversion depends on outputSettings.  <a href="#ga04bcae80049f7b33e84ebdffc116b321"></a><br/></td></tr>
<tr class="separator:ga04bcae80049f7b33e84ebdffc116b321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0f330f1e8ff7b541f721dcf9211030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaae0f330f1e8ff7b541f721dcf9211030">XsMessage_getDataFPValuesById</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataIdentifier, double *dest, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:gaae0f330f1e8ff7b541f721dcf9211030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current data values as double, conversion depends on outputSetting.  <a href="#gaae0f330f1e8ff7b541f721dcf9211030"></a><br/></td></tr>
<tr class="separator:gaae0f330f1e8ff7b541f721dcf9211030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde1d1e334dbf921acf03ee0a25eada3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadde1d1e334dbf921acf03ee0a25eada3">XsMessage_setDataFPValuesById</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataIdentifier, double const *data, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:gadde1d1e334dbf921acf03ee0a25eada3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a number of floating/fixed point values into to the data buffer, conversion depends on outputSettings.  <a href="#gadde1d1e334dbf921acf03ee0a25eada3"></a><br/></td></tr>
<tr class="separator:gadde1d1e334dbf921acf03ee0a25eada3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd8840772ddc2616020b1723cf6ea01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bd8840772ddc2616020b1723cf6ea01"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8bd8840772ddc2616020b1723cf6ea01">XsMessage_computeChecksum</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga8bd8840772ddc2616020b1723cf6ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the checksum for the message. <br/></td></tr>
<tr class="separator:ga8bd8840772ddc2616020b1723cf6ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd92cdfd9e682b88fad7e05d69e937e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd92cdfd9e682b88fad7e05d69e937e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadd92cdfd9e682b88fad7e05d69e937e6">XsMessage_recomputeChecksum</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:gadd92cdfd9e682b88fad7e05d69e937e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the checksum for the message. <br/></td></tr>
<tr class="separator:gadd92cdfd9e682b88fad7e05d69e937e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7081af4eca1ef8996da037155ce72a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4f7081af4eca1ef8996da037155ce72a">XsMessage_isChecksumOk</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga4f7081af4eca1ef8996da037155ce72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the checksum inside the message is correct for the message, zero otherwise.  <a href="#ga4f7081af4eca1ef8996da037155ce72a"></a><br/></td></tr>
<tr class="separator:ga4f7081af4eca1ef8996da037155ce72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41551f9a7b226582620c95694009ec52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41551f9a7b226582620c95694009ec52"></a>
<a class="el" href="struct_xs_message_header.html">XsMessageHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga41551f9a7b226582620c95694009ec52">XsMessage_getHeader</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:ga41551f9a7b226582620c95694009ec52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the message header for this message. <br/></td></tr>
<tr class="separator:ga41551f9a7b226582620c95694009ec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06b9bc8c27a860d057a39d9c208c327"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_message_header.html">XsMessageHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac06b9bc8c27a860d057a39d9c208c327">XsMessage_getConstHeader</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="separator:gac06b9bc8c27a860d057a39d9c208c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07140d194f0089a8c40e7738d1622ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa07140d194f0089a8c40e7738d1622ff">XsMessage_empty</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:gaa07140d194f0089a8c40e7738d1622ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this message is empty.  <a href="#gaa07140d194f0089a8c40e7738d1622ff"></a><br/></td></tr>
<tr class="separator:gaa07140d194f0089a8c40e7738d1622ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a71f01ef77db025407f19e93dae9ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6a71f01ef77db025407f19e93dae9ac7">XsMessage_resizeData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize newSize)</td></tr>
<tr class="memdesc:ga6a71f01ef77db025407f19e93dae9ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffer of message to <em>newSize</em> bytes.  <a href="#ga6a71f01ef77db025407f19e93dae9ac7"></a><br/></td></tr>
<tr class="separator:ga6a71f01ef77db025407f19e93dae9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf083ca2bf41d2efdd4fd224bc53c9fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf083ca2bf41d2efdd4fd224bc53c9fa9">XsMessage_setBusId</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint8_t busId)</td></tr>
<tr class="memdesc:gaf083ca2bf41d2efdd4fd224bc53c9fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bus id for this message to <em>busId</em>.  <a href="#gaf083ca2bf41d2efdd4fd224bc53c9fa9"></a><br/></td></tr>
<tr class="separator:gaf083ca2bf41d2efdd4fd224bc53c9fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235e41e089f2c0fc8860bf83df1311d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga235e41e089f2c0fc8860bf83df1311d7">XsMessage_setMessageId</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, enum <a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a> msgId)</td></tr>
<tr class="memdesc:ga235e41e089f2c0fc8860bf83df1311d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message id for this message to <em>msgId</em>.  <a href="#ga235e41e089f2c0fc8860bf83df1311d7"></a><br/></td></tr>
<tr class="separator:ga235e41e089f2c0fc8860bf83df1311d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4901534c43c5716f67f1b73ae215626e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4901534c43c5716f67f1b73ae215626e">XsMessage_insertData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize count, XsSize offset)</td></tr>
<tr class="memdesc:ga4901534c43c5716f67f1b73ae215626e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>count</em> bytes of empty space at <em>offset</em> in this message.  <a href="#ga4901534c43c5716f67f1b73ae215626e"></a><br/></td></tr>
<tr class="separator:ga4901534c43c5716f67f1b73ae215626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9212be8c3889701fad8c40da79822bac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9212be8c3889701fad8c40da79822bac">XsMessage_deleteData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize count, XsSize offset)</td></tr>
<tr class="memdesc:ga9212be8c3889701fad8c40da79822bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>count</em> bytes of data from the message at <em>offset</em>.  <a href="#ga9212be8c3889701fad8c40da79822bac"></a><br/></td></tr>
<tr class="separator:ga9212be8c3889701fad8c40da79822bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9e73d2db2d034d0ae1c3f95fb37cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0b9e73d2db2d034d0ae1c3f95fb37cce">XsMessage_swap</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *a, <a class="el" href="struct_xs_message.html">XsMessage</a> *b)</td></tr>
<tr class="memdesc:ga0b9e73d2db2d034d0ae1c3f95fb37cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>.  <a href="#ga0b9e73d2db2d034d0ae1c3f95fb37cce"></a><br/></td></tr>
<tr class="separator:ga0b9e73d2db2d034d0ae1c3f95fb37cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3efc85d6f6a1062ed0bf6b07631886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d3efc85d6f6a1062ed0bf6b07631886"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7d3efc85d6f6a1062ed0bf6b07631886">XsMessage_compare</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *a, <a class="el" href="struct_xs_message.html">XsMessage</a> const *b)</td></tr>
<tr class="memdesc:ga7d3efc85d6f6a1062ed0bf6b07631886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the contents of the messages <em>a</em> and <em>b</em>, returning non-0 if they are different. <br/></td></tr>
<tr class="separator:ga7d3efc85d6f6a1062ed0bf6b07631886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16769111ff0c7551dbad2a10c93e5f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga16769111ff0c7551dbad2a10c93e5f63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga16769111ff0c7551dbad2a10c93e5f63">XsPortInfo_swap</a> (struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *a, struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *b)</td></tr>
<tr class="memdesc:ga16769111ff0c7551dbad2a10c93e5f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with those of <em>b</em>. <br/></td></tr>
<tr class="separator:ga16769111ff0c7551dbad2a10c93e5f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245f337f50bcbfe350c38bf3f62fc3c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga245f337f50bcbfe350c38bf3f62fc3c8"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga245f337f50bcbfe350c38bf3f62fc3c8">XsResultValue_toString</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga245f337f50bcbfe350c38bf3f62fc3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a character string corresponding to the given result code. <br/></td></tr>
<tr class="separator:ga245f337f50bcbfe350c38bf3f62fc3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7edee3367aa5e0dae8e4723993e237d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab7edee3367aa5e0dae8e4723993e237d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab7edee3367aa5e0dae8e4723993e237d">XsRssi_max</a> ()</td></tr>
<tr class="memdesc:gab7edee3367aa5e0dae8e4723993e237d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum RSSI value. <br/></td></tr>
<tr class="separator:gab7edee3367aa5e0dae8e4723993e237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71878cde0d9365f603d79f773b8f9755"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71878cde0d9365f603d79f773b8f9755"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga71878cde0d9365f603d79f773b8f9755">XsRssi_unknown</a> ()</td></tr>
<tr class="memdesc:ga71878cde0d9365f603d79f773b8f9755"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RSSI value that was reserved for when the RSSI is unknown. <br/></td></tr>
<tr class="separator:ga71878cde0d9365f603d79f773b8f9755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79baa392a62fc5e3ed73d351e4f2c403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga79baa392a62fc5e3ed73d351e4f2c403">XsRssi_unbiased</a> (int raw)</td></tr>
<tr class="memdesc:ga79baa392a62fc5e3ed73d351e4f2c403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw RSSI value transformed into a usable (unbiased) number.  <a href="#ga79baa392a62fc5e3ed73d351e4f2c403"></a><br/></td></tr>
<tr class="separator:ga79baa392a62fc5e3ed73d351e4f2c403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6eebe6760ce2044f7ea6f5f8939addb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6eebe6760ce2044f7ea6f5f8939addb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6eebe6760ce2044f7ea6f5f8939addb">XsSyncSetting_isInput</a> (const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *)</td></tr>
<tr class="memdesc:gae6eebe6760ce2044f7ea6f5f8939addb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the selected line is configured as an input line. <br/></td></tr>
<tr class="separator:gae6eebe6760ce2044f7ea6f5f8939addb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58c058ea42e07990af0f84da09d01b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf58c058ea42e07990af0f84da09d01b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf58c058ea42e07990af0f84da09d01b5">XsSyncSetting_isOutput</a> (const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *)</td></tr>
<tr class="memdesc:gaf58c058ea42e07990af0f84da09d01b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the selected line is configured as an output line. <br/></td></tr>
<tr class="separator:gaf58c058ea42e07990af0f84da09d01b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a9f04de91627ab245235b914c36d04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27a9f04de91627ab245235b914c36d04"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga27a9f04de91627ab245235b914c36d04">XsSyncSetting_swap</a> (<a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *a, <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *b)</td></tr>
<tr class="memdesc:ga27a9f04de91627ab245235b914c36d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with <em>b</em>. <br/></td></tr>
<tr class="separator:ga27a9f04de91627ab245235b914c36d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54582842a30b1029a66050279844a3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac54582842a30b1029a66050279844a3b">XsTime_getTimeOfDay</a> (struct tm *date_, time_t *secs_)</td></tr>
<tr class="memdesc:gac54582842a30b1029a66050279844a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the current time of day in ms since midnight.  <a href="#gac54582842a30b1029a66050279844a3b"></a><br/></td></tr>
<tr class="separator:gac54582842a30b1029a66050279844a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae059db4e22b6f6d69ae31bb7291cd9f6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae059db4e22b6f6d69ae31bb7291cd9f6">XsTime_getDateTime</a> (struct tm *date)</td></tr>
<tr class="memdesc:gae059db4e22b6f6d69ae31bb7291cd9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the date and time (platform-independent)  <a href="#gae059db4e22b6f6d69ae31bb7291cd9f6"></a><br/></td></tr>
<tr class="separator:gae059db4e22b6f6d69ae31bb7291cd9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38505926760a0a5e7dd314e683ae546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae38505926760a0a5e7dd314e683ae546">XsTime_getDateAsString</a> (char *dest, const struct tm *date)</td></tr>
<tr class="memdesc:gae38505926760a0a5e7dd314e683ae546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the date as string representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }.  <a href="#gae38505926760a0a5e7dd314e683ae546"></a><br/></td></tr>
<tr class="separator:gae38505926760a0a5e7dd314e683ae546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb389fca2f6341c79b2262caf7a9d6d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafb389fca2f6341c79b2262caf7a9d6d7">XsTime_getTimeAsString</a> (char *dest, const struct tm *date)</td></tr>
<tr class="memdesc:gafb389fca2f6341c79b2262caf7a9d6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}.  <a href="#gafb389fca2f6341c79b2262caf7a9d6d7"></a><br/></td></tr>
<tr class="separator:gafb389fca2f6341c79b2262caf7a9d6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393705293aa555086514c8835ad019da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga393705293aa555086514c8835ad019da">XsTime_getDateAsWString</a> (wchar_t *dest, const struct tm *date)</td></tr>
<tr class="memdesc:ga393705293aa555086514c8835ad019da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the date as wstring representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }.  <a href="#ga393705293aa555086514c8835ad019da"></a><br/></td></tr>
<tr class="separator:ga393705293aa555086514c8835ad019da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga62a4f6afc1dbe845a1b6b09c9d4fbd1b">XsTime_getTimeAsWString</a> (wchar_t *dest, const struct tm *date)</td></tr>
<tr class="memdesc:ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}.  <a href="#ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"></a><br/></td></tr>
<tr class="separator:ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28efdfd01aad10c9da7baaeb6d7b8931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga28efdfd01aad10c9da7baaeb6d7b8931">XsTime_msleep</a> (uint32_t ms)</td></tr>
<tr class="memdesc:ga28efdfd01aad10c9da7baaeb6d7b8931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the current thread sleep for at least <em>ms</em> milliseconds.  <a href="#ga28efdfd01aad10c9da7baaeb6d7b8931"></a><br/></td></tr>
<tr class="separator:ga28efdfd01aad10c9da7baaeb6d7b8931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8268408ade85db6aa5f5a8bb56f00f75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8268408ade85db6aa5f5a8bb56f00f75">XsTime_udelay</a> (uint32_t us)</td></tr>
<tr class="memdesc:ga8268408ade85db6aa5f5a8bb56f00f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays the current thread for at least <em>us</em> microseconds.  <a href="#ga8268408ade85db6aa5f5a8bb56f00f75"></a><br/></td></tr>
<tr class="separator:ga8268408ade85db6aa5f5a8bb56f00f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d819f679819b2c2c6bc4f7a35f2dde"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga45d819f679819b2c2c6bc4f7a35f2dde">XsTime_timeStampNow</a> (<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *now)</td></tr>
<tr class="memdesc:ga45d819f679819b2c2c6bc4f7a35f2dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current time in ms since the epoch (Jan 1st 1970)  <a href="#ga45d819f679819b2c2c6bc4f7a35f2dde"></a><br/></td></tr>
<tr class="separator:ga45d819f679819b2c2c6bc4f7a35f2dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b31cc058a52b02959dc1b80e729fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf1b31cc058a52b02959dc1b80e729fa1">XsTime_initializeTime</a> ()</td></tr>
<tr class="memdesc:gaf1b31cc058a52b02959dc1b80e729fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stabilize the clock.  <a href="#gaf1b31cc058a52b02959dc1b80e729fa1"></a><br/></td></tr>
<tr class="separator:gaf1b31cc058a52b02959dc1b80e729fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa7a56622d27dbe74e9843a9c633217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2aa7a56622d27dbe74e9843a9c633217"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2aa7a56622d27dbe74e9843a9c633217">XsTriggerIndicationData_destruct</a> (<a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *)</td></tr>
<tr class="memdesc:ga2aa7a56622d27dbe74e9843a9c633217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the XsTriggerIndicationData object. <br/></td></tr>
<tr class="separator:ga2aa7a56622d27dbe74e9843a9c633217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9ccab13c489003637dc63769765d3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc9ccab13c489003637dc63769765d3a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc9ccab13c489003637dc63769765d3a">XsTriggerIndicationData_valid</a> (const <a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *)</td></tr>
<tr class="memdesc:gabc9ccab13c489003637dc63769765d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object is valid (line and polarity may not be 0) <br/></td></tr>
<tr class="separator:gabc9ccab13c489003637dc63769765d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f40f309a7a5e3aec100dc8414104c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa8f40f309a7a5e3aec100dc8414104c6">XsDataFlags_toString</a> (<a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a> f)</td></tr>
<tr class="memdesc:gaa8f40f309a7a5e3aec100dc8414104c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the XsDataFlags to a human readable string.  <a href="#gaa8f40f309a7a5e3aec100dc8414104c6"></a><br/></td></tr>
<tr class="separator:gaa8f40f309a7a5e3aec100dc8414104c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7222e508e1e5b424ba34648a4e31fd98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7222e508e1e5b424ba34648a4e31fd98">XsArray_construct</a> (void *, <a class="el" href="struct_xs_array_descriptor.html">XsArrayDescriptor</a> const *const descriptor, XsSize count, void const *src)</td></tr>
<tr class="memdesc:ga7222e508e1e5b424ba34648a4e31fd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>.  <a href="#ga7222e508e1e5b424ba34648a4e31fd98"></a><br/></td></tr>
<tr class="separator:ga7222e508e1e5b424ba34648a4e31fd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953d7cc7a9ecd8405f2d85b50edc0d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga953d7cc7a9ecd8405f2d85b50edc0d56">XsArray_copyConstruct</a> (void *, void const *src)</td></tr>
<tr class="memdesc:ga953d7cc7a9ecd8405f2d85b50edc0d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with a copy of <em>src</em>.  <a href="#ga953d7cc7a9ecd8405f2d85b50edc0d56"></a><br/></td></tr>
<tr class="separator:ga953d7cc7a9ecd8405f2d85b50edc0d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754df4d700d8f759e3dd29aca3ab629f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga754df4d700d8f759e3dd29aca3ab629f">XsArray_destruct</a> (void *)</td></tr>
<tr class="memdesc:ga754df4d700d8f759e3dd29aca3ab629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and frees memory allocated by the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a>.  <a href="#ga754df4d700d8f759e3dd29aca3ab629f"></a><br/></td></tr>
<tr class="separator:ga754df4d700d8f759e3dd29aca3ab629f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b75e01c27f76b4d91aaa135e4e1a5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7b75e01c27f76b4d91aaa135e4e1a5c3">XsArray_assign</a> (void *, XsSize count, void const *src)</td></tr>
<tr class="memdesc:ga7b75e01c27f76b4d91aaa135e4e1a5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>.  <a href="#ga7b75e01c27f76b4d91aaa135e4e1a5c3"></a><br/></td></tr>
<tr class="separator:ga7b75e01c27f76b4d91aaa135e4e1a5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee0c5bdd163bb6ca4e295e4ae2f4d1bb">XsArray_resize</a> (void *, XsSize count)</td></tr>
<tr class="memdesc:gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the existing list to <em>count</em> items.  <a href="#gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"></a><br/></td></tr>
<tr class="separator:gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e7d83d6428ea82a43d4c44167e75c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9e7d83d6428ea82a43d4c44167e75c54">XsArray_reserve</a> (void *, XsSize count)</td></tr>
<tr class="memdesc:ga9e7d83d6428ea82a43d4c44167e75c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for <em>count</em> items.  <a href="#ga9e7d83d6428ea82a43d4c44167e75c54"></a><br/></td></tr>
<tr class="separator:ga9e7d83d6428ea82a43d4c44167e75c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913d8e0e6cd77c2384b236e634e1881e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga913d8e0e6cd77c2384b236e634e1881e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga913d8e0e6cd77c2384b236e634e1881e">XsArray_copy</a> (void *, void const *src)</td></tr>
<tr class="memdesc:ga913d8e0e6cd77c2384b236e634e1881e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <em>src</em> to thisArray. <br/></td></tr>
<tr class="separator:ga913d8e0e6cd77c2384b236e634e1881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6556d22268f56b6dbd77befdbdad0f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6556d22268f56b6dbd77befdbdad0f68">XsArray_append</a> (void *, void const *other)</td></tr>
<tr class="memdesc:ga6556d22268f56b6dbd77befdbdad0f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the <em>other</em> list to thisArray list.  <a href="#ga6556d22268f56b6dbd77befdbdad0f68"></a><br/></td></tr>
<tr class="separator:ga6556d22268f56b6dbd77befdbdad0f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1698369198b2417d5b5021a660281297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1698369198b2417d5b5021a660281297">XsArray_insert</a> (void *, XsSize index, XsSize count, void const *src)</td></tr>
<tr class="memdesc:ga1698369198b2417d5b5021a660281297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>count</em> items from <em>src</em> at <em>index</em> in the array.  <a href="#ga1698369198b2417d5b5021a660281297"></a><br/></td></tr>
<tr class="separator:ga1698369198b2417d5b5021a660281297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01697484c2c698f779345d64e199a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad01697484c2c698f779345d64e199a5f">XsArray_swap</a> (void *a, void *b)</td></tr>
<tr class="memdesc:gad01697484c2c698f779345d64e199a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with those of <em>b</em>.  <a href="#gad01697484c2c698f779345d64e199a5f"></a><br/></td></tr>
<tr class="separator:gad01697484c2c698f779345d64e199a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24f468427e969e5a5daecb55cd36288"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf24f468427e969e5a5daecb55cd36288"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf24f468427e969e5a5daecb55cd36288">XsArray_erase</a> (void *, XsSize index, XsSize count)</td></tr>
<tr class="memdesc:gaf24f468427e969e5a5daecb55cd36288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <em>count</em> items from the list starting at <em>index</em>. <br/></td></tr>
<tr class="separator:gaf24f468427e969e5a5daecb55cd36288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b78f3e6c2315d7e9741a9336781c49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga63b78f3e6c2315d7e9741a9336781c49">XsArray_compare</a> (void const *a, void const *b)</td></tr>
<tr class="memdesc:ga63b78f3e6c2315d7e9741a9336781c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the lists are different, 0 if they're equal.  <a href="#ga63b78f3e6c2315d7e9741a9336781c49"></a><br/></td></tr>
<tr class="separator:ga63b78f3e6c2315d7e9741a9336781c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72561edb500d3e01c3aeb40de6d6a3db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga72561edb500d3e01c3aeb40de6d6a3db">XsArray_compareSet</a> (void const *a, void const *b)</td></tr>
<tr class="memdesc:ga72561edb500d3e01c3aeb40de6d6a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal.  <a href="#ga72561edb500d3e01c3aeb40de6d6a3db"></a><br/></td></tr>
<tr class="separator:ga72561edb500d3e01c3aeb40de6d6a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6969403e331f28f7534cc2945ddcc09c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6969403e331f28f7534cc2945ddcc09c">XsArray_find</a> (void const *, void const *needle)</td></tr>
<tr class="memdesc:ga6969403e331f28f7534cc2945ddcc09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of <em>needle</em> in the list or -1 if it wasn't found.  <a href="#ga6969403e331f28f7534cc2945ddcc09c"></a><br/></td></tr>
<tr class="separator:ga6969403e331f28f7534cc2945ddcc09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de36061187ffca3834ee403bfaff57d"><td class="memItemLeft" align="right" valign="top">void const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4de36061187ffca3834ee403bfaff57d">XsArray_at</a> (void const *, XsSize index)</td></tr>
<tr class="memdesc:ga4de36061187ffca3834ee403bfaff57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds.  <a href="#ga4de36061187ffca3834ee403bfaff57d"></a><br/></td></tr>
<tr class="separator:ga4de36061187ffca3834ee403bfaff57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5004f8c9e45e57e43b09d6160648591c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5004f8c9e45e57e43b09d6160648591c">XsArray_atIndex</a> (void *, XsSize index)</td></tr>
<tr class="memdesc:ga5004f8c9e45e57e43b09d6160648591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds.  <a href="#ga5004f8c9e45e57e43b09d6160648591c"></a><br/></td></tr>
<tr class="separator:ga5004f8c9e45e57e43b09d6160648591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d1845c9e3d0e754c40807de07208d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac8d1845c9e3d0e754c40807de07208d4">XsArray_removeDuplicates</a> (void *)</td></tr>
<tr class="memdesc:gac8d1845c9e3d0e754c40807de07208d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate entries from the array, keeping only the first instance of each value.  <a href="#gac8d1845c9e3d0e754c40807de07208d4"></a><br/></td></tr>
<tr class="separator:gac8d1845c9e3d0e754c40807de07208d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f6206a9555aeb7b0531ee0a0f7f982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0f6206a9555aeb7b0531ee0a0f7f982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab0f6206a9555aeb7b0531ee0a0f7f982">XsCalibratedData_construct</a> (<a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *, const XsReal *acc, const XsReal *gyr, const XsReal *mag)</td></tr>
<tr class="memdesc:gab0f6206a9555aeb7b0531ee0a0f7f982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an XsCalibratedData object. <br/></td></tr>
<tr class="separator:gab0f6206a9555aeb7b0531ee0a0f7f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba56f16b16d32892d22e15007e4b8e5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba56f16b16d32892d22e15007e4b8e5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaba56f16b16d32892d22e15007e4b8e5d">XsCalibratedData_destruct</a> (<a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *)</td></tr>
<tr class="memdesc:gaba56f16b16d32892d22e15007e4b8e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct an XsCalibratedData object. <br/></td></tr>
<tr class="separator:gaba56f16b16d32892d22e15007e4b8e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a65a3767d1ed8441caf2006a58e71e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55a65a3767d1ed8441caf2006a58e71e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55a65a3767d1ed8441caf2006a58e71e">XsDataPacket_construct</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga55a65a3767d1ed8441caf2006a58e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits a data packet, the packet will be empty after construction. <br/></td></tr>
<tr class="separator:ga55a65a3767d1ed8441caf2006a58e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e364ab5254b2cc649d3ac8200fd729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2e364ab5254b2cc649d3ac8200fd729"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa2e364ab5254b2cc649d3ac8200fd729">XsDataPacket_destruct</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaa2e364ab5254b2cc649d3ac8200fd729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and frees data in an <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a>. <br/></td></tr>
<tr class="separator:gaa2e364ab5254b2cc649d3ac8200fd729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7338c4a1f1b1f4ae4472e8ce30c175df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7338c4a1f1b1f4ae4472e8ce30c175df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7338c4a1f1b1f4ae4472e8ce30c175df">XsDataPacket_copy</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *copy, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *src)</td></tr>
<tr class="memdesc:ga7338c4a1f1b1f4ae4472e8ce30c175df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> to <em>copy</em>. <br/></td></tr>
<tr class="separator:ga7338c4a1f1b1f4ae4472e8ce30c175df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130c593fb6803da813074f4d63b8c044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga130c593fb6803da813074f4d63b8c044"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga130c593fb6803da813074f4d63b8c044">XsDataPacket_swap</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *a, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *b)</td></tr>
<tr class="memdesc:ga130c593fb6803da813074f4d63b8c044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the XsDataPackets in <em>a</em> and <em>b</em>. <br/></td></tr>
<tr class="separator:ga130c593fb6803da813074f4d63b8c044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad1448ea697088e9d77d1c2066309f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafad1448ea697088e9d77d1c2066309f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafad1448ea697088e9d77d1c2066309f4">XsDataPacket_empty</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gafad1448ea697088e9d77d1c2066309f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> is empty. <br/></td></tr>
<tr class="separator:gafad1448ea697088e9d77d1c2066309f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc7556dbcc95a99751eca59d41b1001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaccc7556dbcc95a99751eca59d41b1001">XsDataPacket_itemOffsetMasked</a> (const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> mask)</td></tr>
<tr class="memdesc:gaccc7556dbcc95a99751eca59d41b1001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item offset of the supplied data identifier <em>id</em> using matching criteria specified by <em>mask</em>.  <a href="#gaccc7556dbcc95a99751eca59d41b1001"></a><br/></td></tr>
<tr class="separator:gaccc7556dbcc95a99751eca59d41b1001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9652cd8a68c2389fe27822e35d7d4fa9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9652cd8a68c2389fe27822e35d7d4fa9">XsDataPacket_itemOffsetExact</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:ga9652cd8a68c2389fe27822e35d7d4fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item offset of the supplied data identifier <em>id</em> using strict matching criteria.  <a href="#ga9652cd8a68c2389fe27822e35d7d4fa9"></a><br/></td></tr>
<tr class="separator:ga9652cd8a68c2389fe27822e35d7d4fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8965ee66cdb54fedb30532722588ba6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac8965ee66cdb54fedb30532722588ba6">XsDataPacket_itemOffsetLoose</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:gac8965ee66cdb54fedb30532722588ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item offset of the supplied data identifier <em>id</em> using loose matching criteria.  <a href="#gac8965ee66cdb54fedb30532722588ba6"></a><br/></td></tr>
<tr class="separator:gac8965ee66cdb54fedb30532722588ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4598964d5372f185a2b67ba82846ee72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4598964d5372f185a2b67ba82846ee72">XsDataPacket_setMessage</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_message.html">XsMessage</a> *msg)</td></tr>
<tr class="memdesc:ga4598964d5372f185a2b67ba82846ee72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a message in a datapacket.  <a href="#ga4598964d5372f185a2b67ba82846ee72"></a><br/></td></tr>
<tr class="separator:ga4598964d5372f185a2b67ba82846ee72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00224a13a6b7220f43dacf6e90645298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00224a13a6b7220f43dacf6e90645298">XsDataPacket_dataFormat</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:ga00224a13a6b7220f43dacf6e90645298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dataformat of a specific data identifier in the packet.  <a href="#ga00224a13a6b7220f43dacf6e90645298"></a><br/></td></tr>
<tr class="separator:ga00224a13a6b7220f43dacf6e90645298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a782bc042f7cc6eb779d78aa5e20b0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae0a782bc042f7cc6eb779d78aa5e20b0">XsDataPacket_getFPValueSize</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:gae0a782bc042f7cc6eb779d78aa5e20b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte size of <em>id</em> if the format is a floating point format.  <a href="#gae0a782bc042f7cc6eb779d78aa5e20b0"></a><br/></td></tr>
<tr class="separator:gae0a782bc042f7cc6eb779d78aa5e20b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f76199c6002f84e70d052f5734cd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae0f76199c6002f84e70d052f5734cd77">XsDataPacket_rawAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:gae0f76199c6002f84e70d052f5734cd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw accelerometer component of a data item.  <a href="#gae0f76199c6002f84e70d052f5734cd77"></a><br/></td></tr>
<tr class="separator:gae0f76199c6002f84e70d052f5734cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cf09e402b3a79ae77f2f2b8319667f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab4cf09e402b3a79ae77f2f2b8319667f">XsDataPacket_containsRawAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gab4cf09e402b3a79ae77f2f2b8319667f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains Raw Accelerometer data.  <a href="#gab4cf09e402b3a79ae77f2f2b8319667f"></a><br/></td></tr>
<tr class="separator:gab4cf09e402b3a79ae77f2f2b8319667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1939610911dbe628aa86fdaf60e191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c1939610911dbe628aa86fdaf60e191">XsDataPacket_setRawAcceleration</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:ga8c1939610911dbe628aa86fdaf60e191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw accelerometer data for the item.  <a href="#ga8c1939610911dbe628aa86fdaf60e191"></a><br/></td></tr>
<tr class="separator:ga8c1939610911dbe628aa86fdaf60e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5604d1a08bfcf788d9dc5cc5143f7008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5604d1a08bfcf788d9dc5cc5143f7008">XsDataPacket_rawGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga5604d1a08bfcf788d9dc5cc5143f7008"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw gyroscope component of a data item.  <a href="#ga5604d1a08bfcf788d9dc5cc5143f7008"></a><br/></td></tr>
<tr class="separator:ga5604d1a08bfcf788d9dc5cc5143f7008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41fa8c51bc0bdd7a948c26f29cb993a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf41fa8c51bc0bdd7a948c26f29cb993a">XsDataPacket_containsRawGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf41fa8c51bc0bdd7a948c26f29cb993a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw gyroscope data.  <a href="#gaf41fa8c51bc0bdd7a948c26f29cb993a"></a><br/></td></tr>
<tr class="separator:gaf41fa8c51bc0bdd7a948c26f29cb993a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c1378e3077524fc062c52fb75f6628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81c1378e3077524fc062c52fb75f6628"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga81c1378e3077524fc062c52fb75f6628">XsDataPacket_setRawGyroscopeData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:ga81c1378e3077524fc062c52fb75f6628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw gyroscope data for the item. <br/></td></tr>
<tr class="separator:ga81c1378e3077524fc062c52fb75f6628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d19682f28bbccf51ede5129a489308e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3d19682f28bbccf51ede5129a489308e">XsDataPacket_rawGyroscopeTemperatureData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga3d19682f28bbccf51ede5129a489308e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw gyroscope temperature component of a data item.  <a href="#ga3d19682f28bbccf51ede5129a489308e"></a><br/></td></tr>
<tr class="separator:ga3d19682f28bbccf51ede5129a489308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957722c94b3de10844beb19bceb9499f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga957722c94b3de10844beb19bceb9499f">XsDataPacket_containsRawGyroscopeTemperatureData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga957722c94b3de10844beb19bceb9499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw gyroscope temperature data.  <a href="#ga957722c94b3de10844beb19bceb9499f"></a><br/></td></tr>
<tr class="separator:ga957722c94b3de10844beb19bceb9499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d63654f139445c87dbfc6c861eb6d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5d63654f139445c87dbfc6c861eb6d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac5d63654f139445c87dbfc6c861eb6d7">XsDataPacket_setRawGyroscopeTemperatureData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:gac5d63654f139445c87dbfc6c861eb6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw gyroscope temperature data for the item. <br/></td></tr>
<tr class="separator:gac5d63654f139445c87dbfc6c861eb6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c11ad29680b10e01f52a0f140554be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae5c11ad29680b10e01f52a0f140554be">XsDataPacket_rawMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:gae5c11ad29680b10e01f52a0f140554be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw magnetometer component of a data item.  <a href="#gae5c11ad29680b10e01f52a0f140554be"></a><br/></td></tr>
<tr class="separator:gae5c11ad29680b10e01f52a0f140554be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd354b23b58b9a25af2ed141dd4ba48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabbd354b23b58b9a25af2ed141dd4ba48">XsDataPacket_containsRawMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gabbd354b23b58b9a25af2ed141dd4ba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw magnetometer data.  <a href="#gabbd354b23b58b9a25af2ed141dd4ba48"></a><br/></td></tr>
<tr class="separator:gabbd354b23b58b9a25af2ed141dd4ba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b26c0dc6409162565f02eafb2287149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b26c0dc6409162565f02eafb2287149"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9b26c0dc6409162565f02eafb2287149">XsDataPacket_setRawMagneticField</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:ga9b26c0dc6409162565f02eafb2287149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw magnetometer data for the item. <br/></td></tr>
<tr class="separator:ga9b26c0dc6409162565f02eafb2287149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb399f7bef85d6305b33a8c2a8dc9aa2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeb399f7bef85d6305b33a8c2a8dc9aa2">XsDataPacket_rawTemperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaeb399f7bef85d6305b33a8c2a8dc9aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw temperature component of a data item.  <a href="#gaeb399f7bef85d6305b33a8c2a8dc9aa2"></a><br/></td></tr>
<tr class="separator:gaeb399f7bef85d6305b33a8c2a8dc9aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33c1f5eb46f0e30ecbdb2f5f3f52680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae33c1f5eb46f0e30ecbdb2f5f3f52680">XsDataPacket_containsRawTemperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gae33c1f5eb46f0e30ecbdb2f5f3f52680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw temperature data.  <a href="#gae33c1f5eb46f0e30ecbdb2f5f3f52680"></a><br/></td></tr>
<tr class="separator:gae33c1f5eb46f0e30ecbdb2f5f3f52680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab006ecad31d746626d1c5057582b09bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab006ecad31d746626d1c5057582b09bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab006ecad31d746626d1c5057582b09bd">XsDataPacket_setRawTemperature</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint16_t temp)</td></tr>
<tr class="memdesc:gab006ecad31d746626d1c5057582b09bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw temperature data for the item. <br/></td></tr>
<tr class="separator:gab006ecad31d746626d1c5057582b09bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d926a63a4e5dae27263e34bb9cc50d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d926a63a4e5dae27263e34bb9cc50d5"></a>
<a class="el" href="struct_xs_scr_data.html">XsScrData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1d926a63a4e5dae27263e34bb9cc50d5">XsDataPacket_rawData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_scr_data.html">XsScrData</a> *returnVal)</td></tr>
<tr class="memdesc:ga1d926a63a4e5dae27263e34bb9cc50d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data component of a data item. <br/></td></tr>
<tr class="separator:ga1d926a63a4e5dae27263e34bb9cc50d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga517f271754bceccef3989b9b9d939755"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga517f271754bceccef3989b9b9d939755">XsDataPacket_containsRawData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga517f271754bceccef3989b9b9d939755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw data.  <a href="#ga517f271754bceccef3989b9b9d939755"></a><br/></td></tr>
<tr class="separator:ga517f271754bceccef3989b9b9d939755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab04d9286516b3281256dd9b6d88c2031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab04d9286516b3281256dd9b6d88c2031"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab04d9286516b3281256dd9b6d88c2031">XsDataPacket_setRawData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_scr_data.html">XsScrData</a> *data)</td></tr>
<tr class="memdesc:gab04d9286516b3281256dd9b6d88c2031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw data for the item. <br/></td></tr>
<tr class="separator:gab04d9286516b3281256dd9b6d88c2031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fddb259bdabf11dcc062770c50f0fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5fddb259bdabf11dcc062770c50f0fb1">XsDataPacket_calibratedAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga5fddb259bdabf11dcc062770c50f0fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calibrated accelerometer component of a data item.  <a href="#ga5fddb259bdabf11dcc062770c50f0fb1"></a><br/></td></tr>
<tr class="separator:ga5fddb259bdabf11dcc062770c50f0fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97126b54948708a4fe4396ed6c1c377f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga97126b54948708a4fe4396ed6c1c377f">XsDataPacket_containsCalibratedAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga97126b54948708a4fe4396ed6c1c377f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated accelerometer data.  <a href="#ga97126b54948708a4fe4396ed6c1c377f"></a><br/></td></tr>
<tr class="separator:ga97126b54948708a4fe4396ed6c1c377f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc4c405eae162395d8b1216742bb3d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabdc4c405eae162395d8b1216742bb3d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabdc4c405eae162395d8b1216742bb3d5">XsDataPacket_setCalibratedAcceleration</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *vec)</td></tr>
<tr class="memdesc:gabdc4c405eae162395d8b1216742bb3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated accelerometer data for the item. <br/></td></tr>
<tr class="separator:gabdc4c405eae162395d8b1216742bb3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f8510e32c5ce64be24aa4e4357977c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga48f8510e32c5ce64be24aa4e4357977c">XsDataPacket_calibratedGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga48f8510e32c5ce64be24aa4e4357977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calibrated gyroscope component of a data item.  <a href="#ga48f8510e32c5ce64be24aa4e4357977c"></a><br/></td></tr>
<tr class="separator:ga48f8510e32c5ce64be24aa4e4357977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ed952bed9c7ca76e937ce062a09fe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga60ed952bed9c7ca76e937ce062a09fe9">XsDataPacket_containsCalibratedGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga60ed952bed9c7ca76e937ce062a09fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated gyroscope data.  <a href="#ga60ed952bed9c7ca76e937ce062a09fe9"></a><br/></td></tr>
<tr class="separator:ga60ed952bed9c7ca76e937ce062a09fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b29dfe4997c15a16cc47524353a0b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5b29dfe4997c15a16cc47524353a0b00">XsDataPacket_calibratedMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga5b29dfe4997c15a16cc47524353a0b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calibrated magnetometer component of a data item.  <a href="#ga5b29dfe4997c15a16cc47524353a0b00"></a><br/></td></tr>
<tr class="separator:ga5b29dfe4997c15a16cc47524353a0b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4578f0373d56a4f810bd2b11c75660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaef4578f0373d56a4f810bd2b11c75660">XsDataPacket_containsCalibratedMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaef4578f0373d56a4f810bd2b11c75660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated magnetometer data.  <a href="#gaef4578f0373d56a4f810bd2b11c75660"></a><br/></td></tr>
<tr class="separator:gaef4578f0373d56a4f810bd2b11c75660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8823e4c2ac88b96fad3a51ccb728828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8823e4c2ac88b96fad3a51ccb728828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae8823e4c2ac88b96fad3a51ccb728828">XsDataPacket_setCalibratedMagneticField</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *vec)</td></tr>
<tr class="memdesc:gae8823e4c2ac88b96fad3a51ccb728828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated magnetometer data for the item. <br/></td></tr>
<tr class="separator:gae8823e4c2ac88b96fad3a51ccb728828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6048d525e0e5e7bb504d7a7c08ebb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc6048d525e0e5e7bb504d7a7c08ebb3">XsDataPacket_calibratedData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *returnVal)</td></tr>
<tr class="memdesc:gabc6048d525e0e5e7bb504d7a7c08ebb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the calibrated Data component of a data item.  <a href="#gabc6048d525e0e5e7bb504d7a7c08ebb3"></a><br/></td></tr>
<tr class="separator:gabc6048d525e0e5e7bb504d7a7c08ebb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c01a1ed158b5e3537fe702377611f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga87c01a1ed158b5e3537fe702377611f1">XsDataPacket_containsCalibratedData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga87c01a1ed158b5e3537fe702377611f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated Data.  <a href="#ga87c01a1ed158b5e3537fe702377611f1"></a><br/></td></tr>
<tr class="separator:ga87c01a1ed158b5e3537fe702377611f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7045ddceec8b9a1f687d142d498ed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee7045ddceec8b9a1f687d142d498ed1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee7045ddceec8b9a1f687d142d498ed1">XsDataPacket_setCalibratedData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *data)</td></tr>
<tr class="memdesc:gaee7045ddceec8b9a1f687d142d498ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated Data for the item. <br/></td></tr>
<tr class="separator:gaee7045ddceec8b9a1f687d142d498ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0149c98d71b9bfe8803485775d41f0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0149c98d71b9bfe8803485775d41f0ac">XsDataPacket_orientationQuaternion</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga0149c98d71b9bfe8803485775d41f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation component of a data item as a quaternion.  <a href="#ga0149c98d71b9bfe8803485775d41f0ac"></a><br/></td></tr>
<tr class="separator:ga0149c98d71b9bfe8803485775d41f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929523109044e36d1b1177d8111c0db5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga929523109044e36d1b1177d8111c0db5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga929523109044e36d1b1177d8111c0db5">XsDataPacket_setOrientationQuaternion</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga929523109044e36d1b1177d8111c0db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update quaternion orientation Data for the item. <br/></td></tr>
<tr class="separator:ga929523109044e36d1b1177d8111c0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1605983648c9e678da6b2e04213293d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_euler.html">XsEuler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf1605983648c9e678da6b2e04213293d">XsDataPacket_orientationEuler</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_euler.html">XsEuler</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:gaf1605983648c9e678da6b2e04213293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation component of a data item as a euler angles.  <a href="#gaf1605983648c9e678da6b2e04213293d"></a><br/></td></tr>
<tr class="separator:gaf1605983648c9e678da6b2e04213293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932baacb21362e29fe602a994b54d5f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga932baacb21362e29fe602a994b54d5f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga932baacb21362e29fe602a994b54d5f2">XsDataPacket_setOrientationEuler</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_euler.html">XsEuler</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga932baacb21362e29fe602a994b54d5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update quaternion orientation Data for the item. <br/></td></tr>
<tr class="separator:ga932baacb21362e29fe602a994b54d5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f622e95ca566c0e8627b6b5a362d9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3f622e95ca566c0e8627b6b5a362d9d8">XsDataPacket_orientationMatrix</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga3f622e95ca566c0e8627b6b5a362d9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation component of a data item as a orientation matrix.  <a href="#ga3f622e95ca566c0e8627b6b5a362d9d8"></a><br/></td></tr>
<tr class="separator:ga3f622e95ca566c0e8627b6b5a362d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afbdb8e359c44d57614bfa059b4ebdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4afbdb8e359c44d57614bfa059b4ebdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4afbdb8e359c44d57614bfa059b4ebdd">XsDataPacket_setOrientationMatrix</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga4afbdb8e359c44d57614bfa059b4ebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update quaternion orientation Data for the item. <br/></td></tr>
<tr class="separator:ga4afbdb8e359c44d57614bfa059b4ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7c3cdac9092bcabd206fb6a634919d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaca7c3cdac9092bcabd206fb6a634919d">XsDataPacket_containsOrientation</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaca7c3cdac9092bcabd206fb6a634919d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains orientation Data of any kind.  <a href="#gaca7c3cdac9092bcabd206fb6a634919d"></a><br/></td></tr>
<tr class="separator:gaca7c3cdac9092bcabd206fb6a634919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47cd95b1d759e97eecca58161eeee5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad47cd95b1d759e97eecca58161eeee5b">XsDataPacket_orientationIdentifier</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad47cd95b1d759e97eecca58161eeee5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data identifier of the first orientation data of any kind in the packet.  <a href="#gad47cd95b1d759e97eecca58161eeee5b"></a><br/></td></tr>
<tr class="separator:gad47cd95b1d759e97eecca58161eeee5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33cedaf486f7ea05478fc1891dbd59e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab33cedaf486f7ea05478fc1891dbd59e">XsDataPacket_coordinateSystemOrientation</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gab33cedaf486f7ea05478fc1891dbd59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate system of the first orientation data of any kind in the packet.  <a href="#gab33cedaf486f7ea05478fc1891dbd59e"></a><br/></td></tr>
<tr class="separator:gab33cedaf486f7ea05478fc1891dbd59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159f5666dafb668580256c6af709dce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga159f5666dafb668580256c6af709dce6">XsDataPacket_gpsPvtData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *returnVal)</td></tr>
<tr class="memdesc:ga159f5666dafb668580256c6af709dce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gps PVT data component of a data item.  <a href="#ga159f5666dafb668580256c6af709dce6"></a><br/></td></tr>
<tr class="separator:ga159f5666dafb668580256c6af709dce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4592f786dece1c41d0a2c480cc83338d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4592f786dece1c41d0a2c480cc83338d">XsDataPacket_containsGpsPvtData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga4592f786dece1c41d0a2c480cc83338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains gps PVT data.  <a href="#ga4592f786dece1c41d0a2c480cc83338d"></a><br/></td></tr>
<tr class="separator:ga4592f786dece1c41d0a2c480cc83338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9674a10af2e9f0f25da5afb1ea569893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9674a10af2e9f0f25da5afb1ea569893">XsDataPacket_setGpsPvtData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *data)</td></tr>
<tr class="memdesc:ga9674a10af2e9f0f25da5afb1ea569893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update gps PVT data for the item.  <a href="#ga9674a10af2e9f0f25da5afb1ea569893"></a><br/></td></tr>
<tr class="separator:ga9674a10af2e9f0f25da5afb1ea569893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47889699665bb08e201fae0f3e6eb984"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga47889699665bb08e201fae0f3e6eb984">XsDataPacket_containsPressure</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga47889699665bb08e201fae0f3e6eb984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains pressure data.  <a href="#ga47889699665bb08e201fae0f3e6eb984"></a><br/></td></tr>
<tr class="separator:ga47889699665bb08e201fae0f3e6eb984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45a927643b25f86b659ee60784590c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf45a927643b25f86b659ee60784590c3">XsDataPacket_containsPressureAge</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf45a927643b25f86b659ee60784590c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains pressure age data.  <a href="#gaf45a927643b25f86b659ee60784590c3"></a><br/></td></tr>
<tr class="separator:gaf45a927643b25f86b659ee60784590c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5562328d6b7612efb2263f9216f444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_pressure.html">XsPressure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacb5562328d6b7612efb2263f9216f444">XsDataPacket_pressure</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_pressure.html">XsPressure</a> *returnVal)</td></tr>
<tr class="memdesc:gacb5562328d6b7612efb2263f9216f444"><td class="mdescLeft">&#160;</td><td class="mdescRight">The air pressure component of a data item.  <a href="#gacb5562328d6b7612efb2263f9216f444"></a><br/></td></tr>
<tr class="separator:gacb5562328d6b7612efb2263f9216f444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01accfac8d7a667e248a4df83b07721f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01accfac8d7a667e248a4df83b07721f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga01accfac8d7a667e248a4df83b07721f">XsDataPacket_setPressure</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_pressure.html">XsPressure</a> *data)</td></tr>
<tr class="memdesc:ga01accfac8d7a667e248a4df83b07721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update pressure data for the item. <br/></td></tr>
<tr class="separator:ga01accfac8d7a667e248a4df83b07721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954395b7b5af631e31e9b0493acec7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga954395b7b5af631e31e9b0493acec7b2">XsDataPacket_sdiData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *returnVal)</td></tr>
<tr class="memdesc:ga954395b7b5af631e31e9b0493acec7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the strapdown integration data component of a data item.  <a href="#ga954395b7b5af631e31e9b0493acec7b2"></a><br/></td></tr>
<tr class="separator:ga954395b7b5af631e31e9b0493acec7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5ecc04a489160f62f261de66a02497"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6f5ecc04a489160f62f261de66a02497">XsDataPacket_containsSdiData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga6f5ecc04a489160f62f261de66a02497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains strapdown integration data.  <a href="#ga6f5ecc04a489160f62f261de66a02497"></a><br/></td></tr>
<tr class="separator:ga6f5ecc04a489160f62f261de66a02497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52705223ff52de6e52f0f8746da3d2da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga52705223ff52de6e52f0f8746da3d2da">XsDataPacket_setSdiData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *data)</td></tr>
<tr class="memdesc:ga52705223ff52de6e52f0f8746da3d2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update strapdown integration data for the item.  <a href="#ga52705223ff52de6e52f0f8746da3d2da"></a><br/></td></tr>
<tr class="separator:ga52705223ff52de6e52f0f8746da3d2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d218f313dc1be12638fd38d9fe39a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac6d218f313dc1be12638fd38d9fe39a9">XsDataPacket_temperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac6d218f313dc1be12638fd38d9fe39a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The temperature component of a data item.  <a href="#gac6d218f313dc1be12638fd38d9fe39a9"></a><br/></td></tr>
<tr class="separator:gac6d218f313dc1be12638fd38d9fe39a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a768d2f6b29b740b110e869b54f682b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3a768d2f6b29b740b110e869b54f682b">XsDataPacket_containsTemperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga3a768d2f6b29b740b110e869b54f682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains temperature data.  <a href="#ga3a768d2f6b29b740b110e869b54f682b"></a><br/></td></tr>
<tr class="separator:ga3a768d2f6b29b740b110e869b54f682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecd3755ae9c05a6e03db67ae8fa6a178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaecd3755ae9c05a6e03db67ae8fa6a178">XsDataPacket_setTemperature</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, double temperature)</td></tr>
<tr class="memdesc:gaecd3755ae9c05a6e03db67ae8fa6a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or updates the temperature data in the datapacket.  <a href="#gaecd3755ae9c05a6e03db67ae8fa6a178"></a><br/></td></tr>
<tr class="separator:gaecd3755ae9c05a6e03db67ae8fa6a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984fcbb151bb425bed68fd15f214e530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga984fcbb151bb425bed68fd15f214e530">XsDataPacket_analogIn1Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *returnVal)</td></tr>
<tr class="memdesc:ga984fcbb151bb425bed68fd15f214e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analog in 1 component of a data item.  <a href="#ga984fcbb151bb425bed68fd15f214e530"></a><br/></td></tr>
<tr class="separator:ga984fcbb151bb425bed68fd15f214e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e15bfb90ba4a319b147edd5c69b093f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5e15bfb90ba4a319b147edd5c69b093f">XsDataPacket_containsAnalogIn1Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga5e15bfb90ba4a319b147edd5c69b093f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains analog in 1 data.  <a href="#ga5e15bfb90ba4a319b147edd5c69b093f"></a><br/></td></tr>
<tr class="separator:ga5e15bfb90ba4a319b147edd5c69b093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9952a87a8aa302aa872a7c88ff9186b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9952a87a8aa302aa872a7c88ff9186b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9952a87a8aa302aa872a7c88ff9186b4">XsDataPacket_setAnalogIn1Data</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *data)</td></tr>
<tr class="memdesc:ga9952a87a8aa302aa872a7c88ff9186b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update analog in 1 data for the item. <br/></td></tr>
<tr class="separator:ga9952a87a8aa302aa872a7c88ff9186b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742702ec9806c8ce2ad92d3e3bdab699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga742702ec9806c8ce2ad92d3e3bdab699">XsDataPacket_analogIn2Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *returnVal)</td></tr>
<tr class="memdesc:ga742702ec9806c8ce2ad92d3e3bdab699"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analog in 2 component of a data item.  <a href="#ga742702ec9806c8ce2ad92d3e3bdab699"></a><br/></td></tr>
<tr class="separator:ga742702ec9806c8ce2ad92d3e3bdab699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b909a7cf3d951bd587e462167ed8943"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6b909a7cf3d951bd587e462167ed8943">XsDataPacket_containsAnalogIn2Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga6b909a7cf3d951bd587e462167ed8943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains analog in 2 data.  <a href="#ga6b909a7cf3d951bd587e462167ed8943"></a><br/></td></tr>
<tr class="separator:ga6b909a7cf3d951bd587e462167ed8943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61d05432a6a3d927280be031911fbed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab61d05432a6a3d927280be031911fbed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab61d05432a6a3d927280be031911fbed">XsDataPacket_setAnalogIn2Data</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *data)</td></tr>
<tr class="memdesc:gab61d05432a6a3d927280be031911fbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update analog in 2 data for the item. <br/></td></tr>
<tr class="separator:gab61d05432a6a3d927280be031911fbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45af0d8bfc4107fb0c09640cbda1f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa45af0d8bfc4107fb0c09640cbda1f09">XsDataPacket_positionLLA</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:gaa45af0d8bfc4107fb0c09640cbda1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position lat lon alt component of a data item.  <a href="#gaa45af0d8bfc4107fb0c09640cbda1f09"></a><br/></td></tr>
<tr class="separator:gaa45af0d8bfc4107fb0c09640cbda1f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3fd8178e684cfe66bb696540bab029d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3fd8178e684cfe66bb696540bab029d">XsDataPacket_containsPositionLLA</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf3fd8178e684cfe66bb696540bab029d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains position lat lon alt data.  <a href="#gaf3fd8178e684cfe66bb696540bab029d"></a><br/></td></tr>
<tr class="separator:gaf3fd8178e684cfe66bb696540bab029d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20fd010f517f69c99199f28a43474a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga20fd010f517f69c99199f28a43474a3c">XsDataPacket_setPositionLLA</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *data)</td></tr>
<tr class="memdesc:ga20fd010f517f69c99199f28a43474a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update position lat lon alt data for the item.  <a href="#ga20fd010f517f69c99199f28a43474a3c"></a><br/></td></tr>
<tr class="separator:ga20fd010f517f69c99199f28a43474a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74073fd7f88c1d458c6fbb4314d041b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga74073fd7f88c1d458c6fbb4314d041b9">XsDataPacket_latitudeLongitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga74073fd7f88c1d458c6fbb4314d041b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position latitude longitude component of a data item.  <a href="#ga74073fd7f88c1d458c6fbb4314d041b9"></a><br/></td></tr>
<tr class="separator:ga74073fd7f88c1d458c6fbb4314d041b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84873964429e40c3dec1ad5f5cbff300"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga84873964429e40c3dec1ad5f5cbff300">XsDataPacket_containsLatitudeLongitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga84873964429e40c3dec1ad5f5cbff300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains position latitude longitude data.  <a href="#ga84873964429e40c3dec1ad5f5cbff300"></a><br/></td></tr>
<tr class="separator:ga84873964429e40c3dec1ad5f5cbff300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99054a34e98f315e4fd31b6be56a97a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga99054a34e98f315e4fd31b6be56a97a9">XsDataPacket_setLatitudeLongitude</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *data)</td></tr>
<tr class="memdesc:ga99054a34e98f315e4fd31b6be56a97a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update position latitude longitude data for the item.  <a href="#ga99054a34e98f315e4fd31b6be56a97a9"></a><br/></td></tr>
<tr class="separator:ga99054a34e98f315e4fd31b6be56a97a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bb2c43334630ab37781b05d5a0a076"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf1bb2c43334630ab37781b05d5a0a076">XsDataPacket_altitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf1bb2c43334630ab37781b05d5a0a076"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position altitude component of a data item.  <a href="#gaf1bb2c43334630ab37781b05d5a0a076"></a><br/></td></tr>
<tr class="separator:gaf1bb2c43334630ab37781b05d5a0a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17e37b4198366ef799fac69e4301ee9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf17e37b4198366ef799fac69e4301ee9">XsDataPacket_containsAltitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf17e37b4198366ef799fac69e4301ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains position altitude data.  <a href="#gaf17e37b4198366ef799fac69e4301ee9"></a><br/></td></tr>
<tr class="separator:gaf17e37b4198366ef799fac69e4301ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeffa2fd1c18474fe885b643abb25399f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeffa2fd1c18474fe885b643abb25399f">XsDataPacket_setAltitude</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, double data)</td></tr>
<tr class="memdesc:gaeffa2fd1c18474fe885b643abb25399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update altitude data for the item.  <a href="#gaeffa2fd1c18474fe885b643abb25399f"></a><br/></td></tr>
<tr class="separator:gaeffa2fd1c18474fe885b643abb25399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11d6d994aa40c6f8277081ecadb9216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa11d6d994aa40c6f8277081ecadb9216">XsDataPacket_velocity</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:gaa11d6d994aa40c6f8277081ecadb9216"><td class="mdescLeft">&#160;</td><td class="mdescRight">The velocity NWU component of a data item.  <a href="#gaa11d6d994aa40c6f8277081ecadb9216"></a><br/></td></tr>
<tr class="separator:gaa11d6d994aa40c6f8277081ecadb9216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075b55f7591d36c2eb93bf4b5e6690fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga075b55f7591d36c2eb93bf4b5e6690fe">XsDataPacket_containsVelocity</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga075b55f7591d36c2eb93bf4b5e6690fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains velocity NED data.  <a href="#ga075b55f7591d36c2eb93bf4b5e6690fe"></a><br/></td></tr>
<tr class="separator:ga075b55f7591d36c2eb93bf4b5e6690fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa48af71aaba108c0b6bde089d74fc2b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa48af71aaba108c0b6bde089d74fc2b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa48af71aaba108c0b6bde089d74fc2b0">XsDataPacket_setVelocity</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:gaa48af71aaba108c0b6bde089d74fc2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update velocity NED data for the item. <br/></td></tr>
<tr class="separator:gaa48af71aaba108c0b6bde089d74fc2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b78a321c23bc634ccfe41730e748824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1b78a321c23bc634ccfe41730e748824">XsDataPacket_velocityIdentifier</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga1b78a321c23bc634ccfe41730e748824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data identifier of the first velocity data of any kind in the packet.  <a href="#ga1b78a321c23bc634ccfe41730e748824"></a><br/></td></tr>
<tr class="separator:ga1b78a321c23bc634ccfe41730e748824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb8f791a622d1594b2985a89101e975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0bb8f791a622d1594b2985a89101e975">XsDataPacket_coordinateSystemVelocity</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga0bb8f791a622d1594b2985a89101e975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate system of the first velocity data of any kind in the packet.  <a href="#ga0bb8f791a622d1594b2985a89101e975"></a><br/></td></tr>
<tr class="separator:ga0bb8f791a622d1594b2985a89101e975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8aad732d8ba37df041168b8aa256a49"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad8aad732d8ba37df041168b8aa256a49">XsDataPacket_status</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad8aad732d8ba37df041168b8aa256a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status component of a data item.  <a href="#gad8aad732d8ba37df041168b8aa256a49"></a><br/></td></tr>
<tr class="separator:gad8aad732d8ba37df041168b8aa256a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb321aba93424a38c986c10972bb4b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabdb321aba93424a38c986c10972bb4b5">XsDataPacket_containsStatusByte</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gabdb321aba93424a38c986c10972bb4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wether the XsDataPacket contains a statusbyte.  <a href="#gabdb321aba93424a38c986c10972bb4b5"></a><br/></td></tr>
<tr class="separator:gabdb321aba93424a38c986c10972bb4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1713a40540a9d9e74feddde498b429b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad1713a40540a9d9e74feddde498b429b">XsDataPacket_containsStatus</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad1713a40540a9d9e74feddde498b429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains legacy status data.  <a href="#gad1713a40540a9d9e74feddde498b429b"></a><br/></td></tr>
<tr class="separator:gad1713a40540a9d9e74feddde498b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ac53ce205dd1188f542d68cfe4489d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga74ac53ce205dd1188f542d68cfe4489d">XsDataPacket_containsDetailedStatus</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga74ac53ce205dd1188f542d68cfe4489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains detailed status data.  <a href="#ga74ac53ce205dd1188f542d68cfe4489d"></a><br/></td></tr>
<tr class="separator:ga74ac53ce205dd1188f542d68cfe4489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e5d2cf3dba73410249b687560fcff4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95e5d2cf3dba73410249b687560fcff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga95e5d2cf3dba73410249b687560fcff4">XsDataPacket_setStatusByte</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint8_t data)</td></tr>
<tr class="memdesc:ga95e5d2cf3dba73410249b687560fcff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update status data for the item. <br/></td></tr>
<tr class="separator:ga95e5d2cf3dba73410249b687560fcff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45e4088b88602b52e2c6c75ac311850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa45e4088b88602b52e2c6c75ac311850"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa45e4088b88602b52e2c6c75ac311850">XsDataPacket_setStatus</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t data)</td></tr>
<tr class="memdesc:gaa45e4088b88602b52e2c6c75ac311850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update status data for the item. <br/></td></tr>
<tr class="separator:gaa45e4088b88602b52e2c6c75ac311850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e80aaced3a3102ad4b6e4cc732eb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4e80aaced3a3102ad4b6e4cc732eb77">XsDataPacket_setTriggerIndication</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> triggerId, <a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> const *triggerIndicationData)</td></tr>
<tr class="memdesc:gad4e80aaced3a3102ad4b6e4cc732eb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update trigger indication data for the item.  <a href="#gad4e80aaced3a3102ad4b6e4cc732eb77"></a><br/></td></tr>
<tr class="separator:gad4e80aaced3a3102ad4b6e4cc732eb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b22f2e3d9ed049488d6797fb279370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad2b22f2e3d9ed049488d6797fb279370">XsDataPacket_triggerIndication</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> triggerId, <a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *returnVal)</td></tr>
<tr class="memdesc:gad2b22f2e3d9ed049488d6797fb279370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trigger indication data of a packet If the packet does not contain the requested data, the return val struct will be set to all zeroes.  <a href="#gad2b22f2e3d9ed049488d6797fb279370"></a><br/></td></tr>
<tr class="separator:gad2b22f2e3d9ed049488d6797fb279370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45de3d34c2383f51ff85c41d042da13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga45de3d34c2383f51ff85c41d042da13f">XsDataPacket_containsTriggerIndication</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> triggerId)</td></tr>
<tr class="memdesc:ga45de3d34c2383f51ff85c41d042da13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains trigger indication data.  <a href="#ga45de3d34c2383f51ff85c41d042da13f"></a><br/></td></tr>
<tr class="separator:ga45de3d34c2383f51ff85c41d042da13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33cb466ebe40612bd66801cb3bf65d2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac33cb466ebe40612bd66801cb3bf65d2">XsDataPacket_packetCounter8</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac33cb466ebe40612bd66801cb3bf65d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 8 bit packet counter of a packet.  <a href="#gac33cb466ebe40612bd66801cb3bf65d2"></a><br/></td></tr>
<tr class="separator:gac33cb466ebe40612bd66801cb3bf65d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72422178927a7ce88254b0b9e37076da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga72422178927a7ce88254b0b9e37076da">XsDataPacket_containsPacketCounter8</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga72422178927a7ce88254b0b9e37076da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains an 8 bit packet counter.  <a href="#ga72422178927a7ce88254b0b9e37076da"></a><br/></td></tr>
<tr class="separator:ga72422178927a7ce88254b0b9e37076da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81fa16e65f4f1198bbccf10c58d6960e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81fa16e65f4f1198bbccf10c58d6960e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga81fa16e65f4f1198bbccf10c58d6960e">XsDataPacket_setPacketCounter8</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint8_t counter)</td></tr>
<tr class="memdesc:ga81fa16e65f4f1198bbccf10c58d6960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update 8 bit packet counter data for the item. <br/></td></tr>
<tr class="separator:ga81fa16e65f4f1198bbccf10c58d6960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac897f266dc357670ff551f82edbf7bae"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac897f266dc357670ff551f82edbf7bae">XsDataPacket_packetCounter</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac897f266dc357670ff551f82edbf7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet/frame counter of a packet.  <a href="#gac897f266dc357670ff551f82edbf7bae"></a><br/></td></tr>
<tr class="separator:gac897f266dc357670ff551f82edbf7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa1b7a6f13ea2bdd22ce75332601b34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8aa1b7a6f13ea2bdd22ce75332601b34">XsDataPacket_containsPacketCounter</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga8aa1b7a6f13ea2bdd22ce75332601b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains a packet counter.  <a href="#ga8aa1b7a6f13ea2bdd22ce75332601b34"></a><br/></td></tr>
<tr class="separator:ga8aa1b7a6f13ea2bdd22ce75332601b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf5eb91a1a96ef3dd19ada5ff633d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2cf5eb91a1a96ef3dd19ada5ff633d11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2cf5eb91a1a96ef3dd19ada5ff633d11">XsDataPacket_setPacketCounter</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint16_t counter)</td></tr>
<tr class="memdesc:ga2cf5eb91a1a96ef3dd19ada5ff633d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update packet counter data for the item. <br/></td></tr>
<tr class="separator:ga2cf5eb91a1a96ef3dd19ada5ff633d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3aabf7c48a5972924c6274ca8d28e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaba3aabf7c48a5972924c6274ca8d28e8">XsDataPacket_sampleTimeFine</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaba3aabf7c48a5972924c6274ca8d28e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fine sample time of a packet.  <a href="#gaba3aabf7c48a5972924c6274ca8d28e8"></a><br/></td></tr>
<tr class="separator:gaba3aabf7c48a5972924c6274ca8d28e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00be954b34a7a3697229bfd6f04dccaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00be954b34a7a3697229bfd6f04dccaa">XsDataPacket_containsSampleTimeFine</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga00be954b34a7a3697229bfd6f04dccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item XsDataPacket_contains a sample time fine.  <a href="#ga00be954b34a7a3697229bfd6f04dccaa"></a><br/></td></tr>
<tr class="separator:ga00be954b34a7a3697229bfd6f04dccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb1187b7cd2a11b1ff3443ecf3aa095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1bb1187b7cd2a11b1ff3443ecf3aa095"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1bb1187b7cd2a11b1ff3443ecf3aa095">XsDataPacket_setSampleTimeFine</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t counter)</td></tr>
<tr class="memdesc:ga1bb1187b7cd2a11b1ff3443ecf3aa095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update sample tine fine data for the item. <br/></td></tr>
<tr class="separator:ga1bb1187b7cd2a11b1ff3443ecf3aa095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659cc64f5f3fbc6d7efcee002474b992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga659cc64f5f3fbc6d7efcee002474b992"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga659cc64f5f3fbc6d7efcee002474b992">XsDataPacket_sampleTimeCoarse</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga659cc64f5f3fbc6d7efcee002474b992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coarse sample time of a packet. <br/></td></tr>
<tr class="separator:ga659cc64f5f3fbc6d7efcee002474b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd77491910c63fabf11167c66f5dc3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7bd77491910c63fabf11167c66f5dc3c">XsDataPacket_containsSampleTimeCoarse</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga7bd77491910c63fabf11167c66f5dc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item XsDataPacket_contains a sample time coarse.  <a href="#ga7bd77491910c63fabf11167c66f5dc3c"></a><br/></td></tr>
<tr class="separator:ga7bd77491910c63fabf11167c66f5dc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d34b33022671972cedefd72bacec6a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d34b33022671972cedefd72bacec6a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1d34b33022671972cedefd72bacec6a2">XsDataPacket_setSampleTimeCoarse</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t counter)</td></tr>
<tr class="memdesc:ga1d34b33022671972cedefd72bacec6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update sample tine coarse data for the item. <br/></td></tr>
<tr class="separator:ga1d34b33022671972cedefd72bacec6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b8e417b166d90a0687a2b7758f6ae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71b8e417b166d90a0687a2b7758f6ae0"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga71b8e417b166d90a0687a2b7758f6ae0">XsDataPacket_sampleTime64</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga71b8e417b166d90a0687a2b7758f6ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full 64-bit sample time of a packet, combined from the fine and coarse sample times. <br/></td></tr>
<tr class="separator:ga71b8e417b166d90a0687a2b7758f6ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69c00776dc3a25fa9a0bf6d178d6e29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab69c00776dc3a25fa9a0bf6d178d6e29">XsDataPacket_containsSampleTime64</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gab69c00776dc3a25fa9a0bf6d178d6e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> contains a full 64-bit sample time.  <a href="#gab69c00776dc3a25fa9a0bf6d178d6e29"></a><br/></td></tr>
<tr class="separator:gab69c00776dc3a25fa9a0bf6d178d6e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8473f03a8b763be77e44bc0d28aa0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c8473f03a8b763be77e44bc0d28aa0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c8473f03a8b763be77e44bc0d28aa0e">XsDataPacket_setSampleTime64</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint64_t counter)</td></tr>
<tr class="memdesc:ga6c8473f03a8b763be77e44bc0d28aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update sample tine coarse data for the item. <br/></td></tr>
<tr class="separator:ga6c8473f03a8b763be77e44bc0d28aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d14dd8d8800650f30c10b8592bcf7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0d14dd8d8800650f30c10b8592bcf7c1">XsDataPacket_utcTime</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *returnVal)</td></tr>
<tr class="memdesc:ga0d14dd8d8800650f30c10b8592bcf7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The utc time component of a data item.  <a href="#ga0d14dd8d8800650f30c10b8592bcf7c1"></a><br/></td></tr>
<tr class="separator:ga0d14dd8d8800650f30c10b8592bcf7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fddd1161e2606088e18804c47edc0d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2fddd1161e2606088e18804c47edc0d0">XsDataPacket_containsUtcTime</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga2fddd1161e2606088e18804c47edc0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains utc time data.  <a href="#ga2fddd1161e2606088e18804c47edc0d0"></a><br/></td></tr>
<tr class="separator:ga2fddd1161e2606088e18804c47edc0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94fddaf42bacfc69f0ea367e04ade0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae94fddaf42bacfc69f0ea367e04ade0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae94fddaf42bacfc69f0ea367e04ade0a">XsDataPacket_setUtcTime</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *data)</td></tr>
<tr class="memdesc:gae94fddaf42bacfc69f0ea367e04ade0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update utc time data for the item. <br/></td></tr>
<tr class="separator:gae94fddaf42bacfc69f0ea367e04ade0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e1ec4bf4fde8f406bc8743eb5eeeb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga67e1ec4bf4fde8f406bc8743eb5eeeb7">XsDataPacket_freeAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga67e1ec4bf4fde8f406bc8743eb5eeeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The free acceleration component of a data item.  <a href="#ga67e1ec4bf4fde8f406bc8743eb5eeeb7"></a><br/></td></tr>
<tr class="separator:ga67e1ec4bf4fde8f406bc8743eb5eeeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1307b6dfe823a65ae9e035295e485f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae1307b6dfe823a65ae9e035295e485f7">XsDataPacket_containsFreeAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gae1307b6dfe823a65ae9e035295e485f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains free acceleration.  <a href="#gae1307b6dfe823a65ae9e035295e485f7"></a><br/></td></tr>
<tr class="separator:gae1307b6dfe823a65ae9e035295e485f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ebbb512b59c7748a45fa70f3da5c667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8ebbb512b59c7748a45fa70f3da5c667">XsDataPacket_setFreeAcceleration</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *g)</td></tr>
<tr class="memdesc:ga8ebbb512b59c7748a45fa70f3da5c667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update free acceleration data for the item.  <a href="#ga8ebbb512b59c7748a45fa70f3da5c667"></a><br/></td></tr>
<tr class="separator:ga8ebbb512b59c7748a45fa70f3da5c667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9a426ac35cf230d4d6016ebee6d6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafa9a426ac35cf230d4d6016ebee6d6c9">XsDataPacket_frameRange</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_range.html">XsRange</a> *returnVal)</td></tr>
<tr class="memdesc:gafa9a426ac35cf230d4d6016ebee6d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frame range contained in the datapacket.  <a href="#gafa9a426ac35cf230d4d6016ebee6d6c9"></a><br/></td></tr>
<tr class="separator:gafa9a426ac35cf230d4d6016ebee6d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58130ed5eb306a370faf88dd3b5dc83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad58130ed5eb306a370faf88dd3b5dc83">XsDataPacket_containsFrameRange</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad58130ed5eb306a370faf88dd3b5dc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the datapacket contains a framerange.  <a href="#gad58130ed5eb306a370faf88dd3b5dc83"></a><br/></td></tr>
<tr class="separator:gad58130ed5eb306a370faf88dd3b5dc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d69b7bbbd2c6393c908f511085f31d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga48d69b7bbbd2c6393c908f511085f31d">XsDataPacket_setFrameRange</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_range.html">XsRange</a> *r)</td></tr>
<tr class="memdesc:ga48d69b7bbbd2c6393c908f511085f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or updates the frame range in the datapacket.  <a href="#ga48d69b7bbbd2c6393c908f511085f31d"></a><br/></td></tr>
<tr class="separator:ga48d69b7bbbd2c6393c908f511085f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30697102dfb8de08d4b8f4b3e5362834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga30697102dfb8de08d4b8f4b3e5362834">XsDataPacket_rssi</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga30697102dfb8de08d4b8f4b3e5362834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rssi value contained in the datapacket.  <a href="#ga30697102dfb8de08d4b8f4b3e5362834"></a><br/></td></tr>
<tr class="separator:ga30697102dfb8de08d4b8f4b3e5362834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f360268043a4fc135884256f00e34e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7f360268043a4fc135884256f00e34e1">XsDataPacket_containsRssi</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga7f360268043a4fc135884256f00e34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the datapacket contains an rssi value.  <a href="#ga7f360268043a4fc135884256f00e34e1"></a><br/></td></tr>
<tr class="separator:ga7f360268043a4fc135884256f00e34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee18c6de4dd432a2361dd981f9c4e7d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee18c6de4dd432a2361dd981f9c4e7d9">XsDataPacket_setRssi</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, int r)</td></tr>
<tr class="memdesc:gaee18c6de4dd432a2361dd981f9c4e7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or updates the rssi value in the datapacket.  <a href="#gaee18c6de4dd432a2361dd981f9c4e7d9"></a><br/></td></tr>
<tr class="separator:gaee18c6de4dd432a2361dd981f9c4e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc084c075cde16cb8a91b1e38f8cd05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fc084c075cde16cb8a91b1e38f8cd05"></a>
<a class="el" href="struct_xs_raw_gps_dop.html">XsRawGpsDop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5fc084c075cde16cb8a91b1e38f8cd05">XsDataPacket_rawGpsDop</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_dop.html">XsRawGpsDop</a> *returnVal)</td></tr>
<tr class="memdesc:ga5fc084c075cde16cb8a91b1e38f8cd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with <a class="el" href="struct_xs_raw_gps_dop.html" title="A container for NAV-DOP data.">XsRawGpsDop</a> data. <br/></td></tr>
<tr class="separator:ga5fc084c075cde16cb8a91b1e38f8cd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53edb71aeb307e9125ce630eaee90ca4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga53edb71aeb307e9125ce630eaee90ca4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga53edb71aeb307e9125ce630eaee90ca4">XsDataPacket_containsRawGpsDop</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga53edb71aeb307e9125ce630eaee90ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if data item contains RawGpsDop, 0 otherwise. <br/></td></tr>
<tr class="separator:ga53edb71aeb307e9125ce630eaee90ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfbfb7c6bc844380868feb62f91af63a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfbfb7c6bc844380868feb62f91af63a"></a>
<a class="el" href="struct_xs_raw_gps_sol.html">XsRawGpsSol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadfbfb7c6bc844380868feb62f91af63a">XsDataPacket_rawGpsSol</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_sol.html">XsRawGpsSol</a> *returnVal)</td></tr>
<tr class="memdesc:gadfbfb7c6bc844380868feb62f91af63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with RawGpsSol data. <br/></td></tr>
<tr class="separator:gadfbfb7c6bc844380868feb62f91af63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a02ac1c0ef73d9610a85129ed1672a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a02ac1c0ef73d9610a85129ed1672a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0a02ac1c0ef73d9610a85129ed1672a2">XsDataPacket_containsRawGpsSol</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga0a02ac1c0ef73d9610a85129ed1672a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if data item contains RawGpsSol, 0 otherwise. <br/></td></tr>
<tr class="separator:ga0a02ac1c0ef73d9610a85129ed1672a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49edf68109e853cc027d4ff11c909b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada49edf68109e853cc027d4ff11c909b"></a>
<a class="el" href="struct_xs_raw_gps_time_utc.html">XsRawGpsTimeUtc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gada49edf68109e853cc027d4ff11c909b">XsDataPacket_rawGpsTimeUtc</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_time_utc.html">XsRawGpsTimeUtc</a> *returnVal)</td></tr>
<tr class="memdesc:gada49edf68109e853cc027d4ff11c909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with RawGpsTimeUtc data. <br/></td></tr>
<tr class="separator:gada49edf68109e853cc027d4ff11c909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24dcfb986bd6fa58b0bd099adfeb1d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac24dcfb986bd6fa58b0bd099adfeb1d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac24dcfb986bd6fa58b0bd099adfeb1d0">XsDataPacket_containsRawGpsTimeUtc</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac24dcfb986bd6fa58b0bd099adfeb1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if data item contains RawGpsTimeUtc, 0 otherwise. <br/></td></tr>
<tr class="separator:gac24dcfb986bd6fa58b0bd099adfeb1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ef62360dfb7431256bf679b42f4a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3ef62360dfb7431256bf679b42f4a23"></a>
<a class="el" href="struct_xs_raw_gps_sv_info.html">XsRawGpsSvInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad3ef62360dfb7431256bf679b42f4a23">XsDataPacket_rawGpsSvInfo</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_sv_info.html">XsRawGpsSvInfo</a> *returnVal)</td></tr>
<tr class="memdesc:gad3ef62360dfb7431256bf679b42f4a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with RawGpsClock data. <br/></td></tr>
<tr class="separator:gad3ef62360dfb7431256bf679b42f4a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec420bb6de5d632e4fa3f5e4751ef3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaec420bb6de5d632e4fa3f5e4751ef3f7">XsDataPacket_append</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *other)</td></tr>
<tr class="memdesc:gaec420bb6de5d632e4fa3f5e4751ef3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the data items from <em>other</em> to the packet.  <a href="#gaec420bb6de5d632e4fa3f5e4751ef3f7"></a><br/></td></tr>
<tr class="separator:gaec420bb6de5d632e4fa3f5e4751ef3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4916426e8dd9d71641e33633a9e12e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b4916426e8dd9d71641e33633a9e12e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5b4916426e8dd9d71641e33633a9e12e">XsDeviceId_broadcast</a> (void)</td></tr>
<tr class="memdesc:ga5b4916426e8dd9d71641e33633a9e12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a broadcast deviceID. <br/></td></tr>
<tr class="separator:ga5b4916426e8dd9d71641e33633a9e12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099ea30bbea00971b41bf16781cf6a83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga099ea30bbea00971b41bf16781cf6a83"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga099ea30bbea00971b41bf16781cf6a83">XsDeviceId_isValid</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga099ea30bbea00971b41bf16781cf6a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the device ID is a valid id (not 0). <br/></td></tr>
<tr class="separator:ga099ea30bbea00971b41bf16781cf6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99df42d3a051bd603c8bf5c8d3c3a5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae99df42d3a051bd603c8bf5c8d3c3a5b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae99df42d3a051bd603c8bf5c8d3c3a5b">XsDeviceId_isXbusMaster</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae99df42d3a051bd603c8bf5c8d3c3a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Xbus Master. <br/></td></tr>
<tr class="separator:gae99df42d3a051bd603c8bf5c8d3c3a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37cbd55b17b3a877042112a59e904cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae37cbd55b17b3a877042112a59e904cc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae37cbd55b17b3a877042112a59e904cc">XsDeviceId_isWirelessMaster</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae37cbd55b17b3a877042112a59e904cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents a Wireless Master device (Awinda Station, Awinda Dongle, Awinda OEM). <br/></td></tr>
<tr class="separator:gae37cbd55b17b3a877042112a59e904cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac407762b4a1b5ca50d99aadc2c516883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac407762b4a1b5ca50d99aadc2c516883"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac407762b4a1b5ca50d99aadc2c516883">XsDeviceId_isAwindaStation</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gac407762b4a1b5ca50d99aadc2c516883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Awinda Station. <br/></td></tr>
<tr class="separator:gac407762b4a1b5ca50d99aadc2c516883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27ce112c3bd3fa3ed63170f4115b442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa27ce112c3bd3fa3ed63170f4115b442"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa27ce112c3bd3fa3ed63170f4115b442">XsDeviceId_isAwindaDongle</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaa27ce112c3bd3fa3ed63170f4115b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Awinda Dongle. <br/></td></tr>
<tr class="separator:gaa27ce112c3bd3fa3ed63170f4115b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbaf3008b1d5d9db37704923a3b233d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbaf3008b1d5d9db37704923a3b233d7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabbaf3008b1d5d9db37704923a3b233d7">XsDeviceId_isAwindaOem</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gabbaf3008b1d5d9db37704923a3b233d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Awinda OEM board. <br/></td></tr>
<tr class="separator:gabbaf3008b1d5d9db37704923a3b233d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5279f17952a3e1f6c1f05a3bfb812fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5279f17952a3e1f6c1f05a3bfb812fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab5279f17952a3e1f6c1f05a3bfb812fe">XsDeviceId_isMtw</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gab5279f17952a3e1f6c1f05a3bfb812fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTw. <br/></td></tr>
<tr class="separator:gab5279f17952a3e1f6c1f05a3bfb812fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c084f04c30b7370dc36692ed193d1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08c084f04c30b7370dc36692ed193d1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga08c084f04c30b7370dc36692ed193d1b">XsDeviceId_isXbusMasterMotionTracker</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga08c084f04c30b7370dc36692ed193d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Xbus Master Motion Tracker. <br/></td></tr>
<tr class="separator:ga08c084f04c30b7370dc36692ed193d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ed456340bb66c2da02b1aedd55ac1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga33ed456340bb66c2da02b1aedd55ac1a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga33ed456340bb66c2da02b1aedd55ac1a">XsDeviceId_isMtix</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga33ed456340bb66c2da02b1aedd55ac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTi or an MTx. <br/></td></tr>
<tr class="separator:ga33ed456340bb66c2da02b1aedd55ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7f3448fc6bbe05fb55373bc6c72be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e7f3448fc6bbe05fb55373bc6c72be8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3e7f3448fc6bbe05fb55373bc6c72be8">XsDeviceId_isLegacyMtig</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga3e7f3448fc6bbe05fb55373bc6c72be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents a legacy MTi-G. <br/></td></tr>
<tr class="separator:ga3e7f3448fc6bbe05fb55373bc6c72be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec57002bd1fdc7c371b9207899ca3bb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec57002bd1fdc7c371b9207899ca3bb9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaec57002bd1fdc7c371b9207899ca3bb9">XsDeviceId_isMtig</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaec57002bd1fdc7c371b9207899ca3bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTi-G. <br/></td></tr>
<tr class="separator:gaec57002bd1fdc7c371b9207899ca3bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a52a7ef11195a72bb3712f965852fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1a52a7ef11195a72bb3712f965852fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae1a52a7ef11195a72bb3712f965852fe">XsDeviceId_isMtMk4</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae1a52a7ef11195a72bb3712f965852fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4. <br/></td></tr>
<tr class="separator:gae1a52a7ef11195a72bb3712f965852fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c192ef55e4f81743a9bfdae27396e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05c192ef55e4f81743a9bfdae27396e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga05c192ef55e4f81743a9bfdae27396e0">XsDeviceId_isMtMk4_X0</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga05c192ef55e4f81743a9bfdae27396e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 10 series. <br/></td></tr>
<tr class="separator:ga05c192ef55e4f81743a9bfdae27396e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da662ba7f747bb2318b2d15fac1935c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0da662ba7f747bb2318b2d15fac1935c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0da662ba7f747bb2318b2d15fac1935c">XsDeviceId_isMtMk4_10</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga0da662ba7f747bb2318b2d15fac1935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 10. <br/></td></tr>
<tr class="separator:ga0da662ba7f747bb2318b2d15fac1935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55491981ff828d44fcf93e1c02d6a9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55491981ff828d44fcf93e1c02d6a9e5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55491981ff828d44fcf93e1c02d6a9e5">XsDeviceId_isMtMk4_20</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga55491981ff828d44fcf93e1c02d6a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 20. <br/></td></tr>
<tr class="separator:ga55491981ff828d44fcf93e1c02d6a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9d17f3d9226bf0177a76171aa2f188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab9d17f3d9226bf0177a76171aa2f188"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaab9d17f3d9226bf0177a76171aa2f188">XsDeviceId_isMtMk4_30</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaab9d17f3d9226bf0177a76171aa2f188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 30. <br/></td></tr>
<tr class="separator:gaab9d17f3d9226bf0177a76171aa2f188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cd8b78662d0970bdf15e0a0713c2b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27cd8b78662d0970bdf15e0a0713c2b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga27cd8b78662d0970bdf15e0a0713c2b2">XsDeviceId_isMtMk4_X00</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga27cd8b78662d0970bdf15e0a0713c2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 100 series. <br/></td></tr>
<tr class="separator:ga27cd8b78662d0970bdf15e0a0713c2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29cb199d8cbbd28aa43bf4ee542e0898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29cb199d8cbbd28aa43bf4ee542e0898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga29cb199d8cbbd28aa43bf4ee542e0898">XsDeviceId_isMtMk4_100</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga29cb199d8cbbd28aa43bf4ee542e0898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 100. <br/></td></tr>
<tr class="separator:ga29cb199d8cbbd28aa43bf4ee542e0898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c60991d86c6136d323e9344eec4d5c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c60991d86c6136d323e9344eec4d5c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c60991d86c6136d323e9344eec4d5c3">XsDeviceId_isMtMk4_200</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga6c60991d86c6136d323e9344eec4d5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 200. <br/></td></tr>
<tr class="separator:ga6c60991d86c6136d323e9344eec4d5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c8c4a97533d7a67a1aae56b2a8ad10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3c8c4a97533d7a67a1aae56b2a8ad10"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad3c8c4a97533d7a67a1aae56b2a8ad10">XsDeviceId_isMtMk4_300</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gad3c8c4a97533d7a67a1aae56b2a8ad10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 300. <br/></td></tr>
<tr class="separator:gad3c8c4a97533d7a67a1aae56b2a8ad10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1c3377e2e191de766abd34ec859f80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a1c3377e2e191de766abd34ec859f80"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4a1c3377e2e191de766abd34ec859f80">XsDeviceId_isMtMk4_700</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga4a1c3377e2e191de766abd34ec859f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 700. <br/></td></tr>
<tr class="separator:ga4a1c3377e2e191de766abd34ec859f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55623db59b144d6874d42fdc113adc31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55623db59b144d6874d42fdc113adc31"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55623db59b144d6874d42fdc113adc31">XsDeviceId_isMtw2</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga55623db59b144d6874d42fdc113adc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTw2. <br/></td></tr>
<tr class="separator:ga55623db59b144d6874d42fdc113adc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1e5fd0df1373b4857b47e874a3be6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d1e5fd0df1373b4857b47e874a3be6d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4d1e5fd0df1373b4857b47e874a3be6d">XsDeviceId_isMtx2</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga4d1e5fd0df1373b4857b47e874a3be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTx2. <br/></td></tr>
<tr class="separator:ga4d1e5fd0df1373b4857b47e874a3be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dd4d5d3ca5ae5079fabbfc657c278f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6dd4d5d3ca5ae5079fabbfc657c278f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6dd4d5d3ca5ae5079fabbfc657c278f">XsDeviceId_containsBroadcast</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae6dd4d5d3ca5ae5079fabbfc657c278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the device ID has the broadcast bit set. <br/></td></tr>
<tr class="separator:gae6dd4d5d3ca5ae5079fabbfc657c278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223b3bbf099718160b2958a8663de2da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga223b3bbf099718160b2958a8663de2da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga223b3bbf099718160b2958a8663de2da">XsDeviceId_isBroadcast</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga223b3bbf099718160b2958a8663de2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID <em>is</em> <em>the</em> broadcast id. <br/></td></tr>
<tr class="separator:ga223b3bbf099718160b2958a8663de2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9d23d23f25cc104ce77ea1dc9a2f3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f9d23d23f25cc104ce77ea1dc9a2f3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8f9d23d23f25cc104ce77ea1dc9a2f3c">XsDeviceId_toString</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *str)</td></tr>
<tr class="memdesc:ga8f9d23d23f25cc104ce77ea1dc9a2f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with a readable representation of this device ID. <br/></td></tr>
<tr class="separator:ga8f9d23d23f25cc104ce77ea1dc9a2f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2c532c3468ad0e5bf869888cb169e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c2c532c3468ad0e5bf869888cb169e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c2c532c3468ad0e5bf869888cb169e8">XsEuler_destruct</a> (<a class="el" href="struct_xs_euler.html">XsEuler</a> *)</td></tr>
<tr class="memdesc:ga8c2c532c3468ad0e5bf869888cb169e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all angles in the <a class="el" href="struct_xs_euler.html" title="Contains Euler Angle data and conversion from Quaternion.">XsEuler</a> object by setting them to 0. <br/></td></tr>
<tr class="separator:ga8c2c532c3468ad0e5bf869888cb169e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2386ad4f8114a365b6cd43274e7dfefd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2386ad4f8114a365b6cd43274e7dfefd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2386ad4f8114a365b6cd43274e7dfefd">XsEuler_empty</a> (const <a class="el" href="struct_xs_euler.html">XsEuler</a> *)</td></tr>
<tr class="memdesc:ga2386ad4f8114a365b6cd43274e7dfefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all angles in this object are zero. <br/></td></tr>
<tr class="separator:ga2386ad4f8114a365b6cd43274e7dfefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a0f25e115a3798583d767c869600c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5a0f25e115a3798583d767c869600c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa5a0f25e115a3798583d767c869600c0">XsEuler_fromQuaternion</a> (<a class="el" href="struct_xs_euler.html">XsEuler</a> *, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:gaa5a0f25e115a3798583d767c869600c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an euler angle representation of the quaternion. <br/></td></tr>
<tr class="separator:gaa5a0f25e115a3798583d767c869600c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf527c091a1c75bba161ea8620442bf1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf527c091a1c75bba161ea8620442bf1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf527c091a1c75bba161ea8620442bf1d">XsMatrix_ref</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize cols, XsSize stride, XsReal *buffer, <a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a> flags)</td></tr>
<tr class="memdesc:gaf527c091a1c75bba161ea8620442bf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the XsMatrix as a reference to data in <em>buffer</em>. <br/></td></tr>
<tr class="separator:gaf527c091a1c75bba161ea8620442bf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aecaec6a03d98ca29d1f0245d52d1be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5aecaec6a03d98ca29d1f0245d52d1be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5aecaec6a03d98ca29d1f0245d52d1be">XsMatrix_construct</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize cols, XsSize stride, const XsReal *src, XsSize srcStride)</td></tr>
<tr class="memdesc:ga5aecaec6a03d98ca29d1f0245d52d1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix and copy the data from <em>src</em> into the matrix if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:ga5aecaec6a03d98ca29d1f0245d52d1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1694795a244793ab61ccdee5ffb44feb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1694795a244793ab61ccdee5ffb44feb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1694795a244793ab61ccdee5ffb44feb">XsMatrix_assign</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize cols, XsSize stride, const XsReal *src, XsSize srcStride)</td></tr>
<tr class="memdesc:ga1694795a244793ab61ccdee5ffb44feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix and copy the data from <em>src</em> into the matrix if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:ga1694795a244793ab61ccdee5ffb44feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9532727d4c5dc4b1ff11286bb249b7da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9532727d4c5dc4b1ff11286bb249b7da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9532727d4c5dc4b1ff11286bb249b7da">XsMatrix_destruct</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:ga9532727d4c5dc4b1ff11286bb249b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> and release allocated resources. <br/></td></tr>
<tr class="separator:ga9532727d4c5dc4b1ff11286bb249b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e74b6a3842014c47fda04fe9c4f4fd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e74b6a3842014c47fda04fe9c4f4fd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7e74b6a3842014c47fda04fe9c4f4fd4">XsMatrix_copy</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *copy, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> const *src)</td></tr>
<tr class="memdesc:ga7e74b6a3842014c47fda04fe9c4f4fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <em>copy</em> to the XsMatrix. <br/></td></tr>
<tr class="separator:ga7e74b6a3842014c47fda04fe9c4f4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb837448577820b2e4d81ad6b0fece5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9bb837448577820b2e4d81ad6b0fece5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9bb837448577820b2e4d81ad6b0fece5">XsMatrix_setZero</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:ga9bb837448577820b2e4d81ad6b0fece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the values in the matrix to zero. <br/></td></tr>
<tr class="separator:ga9bb837448577820b2e4d81ad6b0fece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae713d0404dfa67fedb05659f54d6449e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae713d0404dfa67fedb05659f54d6449e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae713d0404dfa67fedb05659f54d6449e">XsMatrix_empty</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:gae713d0404dfa67fedb05659f54d6449e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns not zero if the matrix contains no values. <br/></td></tr>
<tr class="separator:gae713d0404dfa67fedb05659f54d6449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3aa84511f07c5b343ee77112361dfaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3aa84511f07c5b343ee77112361dfaf">XsMatrix_multiplyScalar</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsReal scalar, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *dest)</td></tr>
<tr class="memdesc:gaf3aa84511f07c5b343ee77112361dfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all values in this <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> by <em>scalar</em>.  <a href="#gaf3aa84511f07c5b343ee77112361dfaf"></a><br/></td></tr>
<tr class="separator:gaf3aa84511f07c5b343ee77112361dfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84490340feeeb8c23327124019db1dde"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga84490340feeeb8c23327124019db1dde">XsMatrix_offset</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize row, XsSize column)</td></tr>
<tr class="memdesc:ga84490340feeeb8c23327124019db1dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset in the data for accessing the value at <em>row</em> and <em>column</em>.  <a href="#ga84490340feeeb8c23327124019db1dde"></a><br/></td></tr>
<tr class="separator:ga84490340feeeb8c23327124019db1dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a90bfd79321cad5e715dba52de1e6ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a90bfd79321cad5e715dba52de1e6ea"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9a90bfd79321cad5e715dba52de1e6ea">XsMatrix_value</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize row, XsSize column)</td></tr>
<tr class="memdesc:ga9a90bfd79321cad5e715dba52de1e6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data value at <em>row</em> and <em>column</em>. <br/></td></tr>
<tr class="separator:ga9a90bfd79321cad5e715dba52de1e6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0084bdd99540d1133f4cf6998e78527"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0084bdd99540d1133f4cf6998e78527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab0084bdd99540d1133f4cf6998e78527">XsMatrix_setValue</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize row, XsSize column, XsReal value)</td></tr>
<tr class="memdesc:gab0084bdd99540d1133f4cf6998e78527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data <em>value</em> at <em>row</em> and <em>column</em>. <br/></td></tr>
<tr class="separator:gab0084bdd99540d1133f4cf6998e78527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5882a97fbee0de45eeb4431d9e640093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5882a97fbee0de45eeb4431d9e640093"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5882a97fbee0de45eeb4431d9e640093">XsMatrix_dimensionsMatch</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize columns)</td></tr>
<tr class="memdesc:ga5882a97fbee0de45eeb4431d9e640093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns not zero if the dimensions of the XsMatrix are equal to <em>rows</em> and <em>columns</em>. <br/></td></tr>
<tr class="separator:ga5882a97fbee0de45eeb4431d9e640093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671caacd145c6ba203d621c65c49b649"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga671caacd145c6ba203d621c65c49b649"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga671caacd145c6ba203d621c65c49b649">XsMatrix_fromQuaternion</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:ga671caacd145c6ba203d621c65c49b649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an orientation matrix representation of the quaternion. <br/></td></tr>
<tr class="separator:ga671caacd145c6ba203d621c65c49b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4218a181d23c28cf3e927b7504a9069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab4218a181d23c28cf3e927b7504a9069">XsMatrix_swap</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *a, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *b)</td></tr>
<tr class="memdesc:gab4218a181d23c28cf3e927b7504a9069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>.  <a href="#gab4218a181d23c28cf3e927b7504a9069"></a><br/></td></tr>
<tr class="separator:gab4218a181d23c28cf3e927b7504a9069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098d9712b3e0710bbe9470f8587ea834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga098d9712b3e0710bbe9470f8587ea834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga098d9712b3e0710bbe9470f8587ea834">XsMatrix3x3_construct</a> (<a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> *)</td></tr>
<tr class="memdesc:ga098d9712b3e0710bbe9470f8587ea834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix3x3. <br/></td></tr>
<tr class="separator:ga098d9712b3e0710bbe9470f8587ea834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33b2122d974535e39388dfdea6344dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab33b2122d974535e39388dfdea6344dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab33b2122d974535e39388dfdea6344dd">XsMatrix3x3_assign</a> (<a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> *, const XsReal *src, XsSize srcStride)</td></tr>
<tr class="memdesc:gab33b2122d974535e39388dfdea6344dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix3x3 and copy the data from <em>src</em> into the matrix if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:gab33b2122d974535e39388dfdea6344dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06191d9047075d30941028a1ff760b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06191d9047075d30941028a1ff760b71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga06191d9047075d30941028a1ff760b71">XsMatrix3x3_destruct</a> (<a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> *)</td></tr>
<tr class="memdesc:ga06191d9047075d30941028a1ff760b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the Matrix3x3. <br/></td></tr>
<tr class="separator:ga06191d9047075d30941028a1ff760b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de6b5eb3961a00bb3822bd31928f63e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2de6b5eb3961a00bb3822bd31928f63e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2de6b5eb3961a00bb3822bd31928f63e">XsMatrix3x3_copy</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *copy, <a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> const *src)</td></tr>
<tr class="memdesc:ga2de6b5eb3961a00bb3822bd31928f63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsMatrix3x3 to <em>copy</em>. <br/></td></tr>
<tr class="separator:ga2de6b5eb3961a00bb3822bd31928f63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a897853544927b983109bc082a2047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10a897853544927b983109bc082a2047"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga10a897853544927b983109bc082a2047">XsPortInfo_clear</a> (<a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga10a897853544927b983109bc082a2047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object to the empty state. <br/></td></tr>
<tr class="separator:ga10a897853544927b983109bc082a2047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e303f48cc6379d465407af794f8ebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97e303f48cc6379d465407af794f8ebe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga97e303f48cc6379d465407af794f8ebe">XsPortInfo_empty</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga97e303f48cc6379d465407af794f8ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="struct_xs_port_info.html" title="Contains a descriptor for opening a communication port to an Xsens device.">XsPortInfo</a> object is empty. <br/></td></tr>
<tr class="separator:ga97e303f48cc6379d465407af794f8ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32b87ad68904738bb4ad9e64758f05a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa32b87ad68904738bb4ad9e64758f05a">XsPortInfo_portNumber</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:gaa32b87ad68904738bb4ad9e64758f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number.  <a href="#gaa32b87ad68904738bb4ad9e64758f05a"></a><br/></td></tr>
<tr class="separator:gaa32b87ad68904738bb4ad9e64758f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b8b2bbdc065321e22e7bc0e0edc3eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3b8b2bbdc065321e22e7bc0e0edc3eb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3b8b2bbdc065321e22e7bc0e0edc3eb">XsPortInfo_isUsb</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:gaf3b8b2bbdc065321e22e7bc0e0edc3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this port info object contains a USB device. <br/></td></tr>
<tr class="separator:gaf3b8b2bbdc065321e22e7bc0e0edc3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a9ed806c36fb0f13e476ad29ff6876"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga07a9ed806c36fb0f13e476ad29ff6876">XsPortInfo_usbBus</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga07a9ed806c36fb0f13e476ad29ff6876"><td class="mdescLeft">&#160;</td><td class="mdescRight">The usb bus.  <a href="#ga07a9ed806c36fb0f13e476ad29ff6876"></a><br/></td></tr>
<tr class="separator:ga07a9ed806c36fb0f13e476ad29ff6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7a31f4a8a7aaf3a18c9152d9e993ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9f7a31f4a8a7aaf3a18c9152d9e993ff">XsPortInfo_usbAddress</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga9f7a31f4a8a7aaf3a18c9152d9e993ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The usb address.  <a href="#ga9f7a31f4a8a7aaf3a18c9152d9e993ff"></a><br/></td></tr>
<tr class="separator:ga9f7a31f4a8a7aaf3a18c9152d9e993ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1b3ad304657c3af6a6023bbf01c30e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f1b3ad304657c3af6a6023bbf01c30e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1f1b3ad304657c3af6a6023bbf01c30e">XsQuaternion_destruct</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga1f1b3ad304657c3af6a6023bbf01c30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the quaternion by setting all values to 0. <br/></td></tr>
<tr class="separator:ga1f1b3ad304657c3af6a6023bbf01c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d14c31ff258dab9129d882b02103f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97d14c31ff258dab9129d882b02103f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga97d14c31ff258dab9129d882b02103f4">XsQuaternion_empty</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga97d14c31ff258dab9129d882b02103f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this is a null object. <br/></td></tr>
<tr class="separator:ga97d14c31ff258dab9129d882b02103f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217fd03f808db0b06765e3bbb85fc9cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga217fd03f808db0b06765e3bbb85fc9cb">XsQuaternion_invert</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga217fd03f808db0b06765e3bbb85fc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert this quaternion.  <a href="#ga217fd03f808db0b06765e3bbb85fc9cb"></a><br/></td></tr>
<tr class="separator:ga217fd03f808db0b06765e3bbb85fc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7269b337234843b87fd7df7f68efa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6b7269b337234843b87fd7df7f68efa2">XsQuaternion_inverse</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *dest)</td></tr>
<tr class="memdesc:ga6b7269b337234843b87fd7df7f68efa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse/conjugate of this quaternion.  <a href="#ga6b7269b337234843b87fd7df7f68efa2"></a><br/></td></tr>
<tr class="separator:ga6b7269b337234843b87fd7df7f68efa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c462b4e47fccbf9c363016cf634082"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00c462b4e47fccbf9c363016cf634082"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00c462b4e47fccbf9c363016cf634082">XsQuaternion_normalized</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *dest)</td></tr>
<tr class="memdesc:ga00c462b4e47fccbf9c363016cf634082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a normalized version of this quaternion. <br/></td></tr>
<tr class="separator:ga00c462b4e47fccbf9c363016cf634082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ebe154b533b0a06c7f13f6a1a467d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43ebe154b533b0a06c7f13f6a1a467d7"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga43ebe154b533b0a06c7f13f6a1a467d7">XsQuaternion_normalize</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga43ebe154b533b0a06c7f13f6a1a467d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize this quaternion. <br/></td></tr>
<tr class="separator:ga43ebe154b533b0a06c7f13f6a1a467d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83391ceba3832268f3c65985d12d041b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83391ceba3832268f3c65985d12d041b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga83391ceba3832268f3c65985d12d041b">XsQuaternion_fromEulerAngles</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, const <a class="el" href="struct_xs_euler.html">XsEuler</a> *src)</td></tr>
<tr class="memdesc:ga83391ceba3832268f3c65985d12d041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a quaternion representation from <em>euler</em> angles. <br/></td></tr>
<tr class="separator:ga83391ceba3832268f3c65985d12d041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5021de7e1f89887d357b80e69c15d5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5021de7e1f89887d357b80e69c15d5ba">XsQuaternion_fromRotationMatrix</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *ori)</td></tr>
<tr class="memdesc:ga5021de7e1f89887d357b80e69c15d5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a quaternion representation of orientation matrix <em>ori</em>.  <a href="#ga5021de7e1f89887d357b80e69c15d5ba"></a><br/></td></tr>
<tr class="separator:ga5021de7e1f89887d357b80e69c15d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593ee51ef335cbc420bb7ea13c453156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga593ee51ef335cbc420bb7ea13c453156"></a>
const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga593ee51ef335cbc420bb7ea13c453156">XsQuaternion_identity</a> (void)</td></tr>
<tr class="memdesc:ga593ee51ef335cbc420bb7ea13c453156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_xs_quaternion.html" title="A class that implements a quaternion.">XsQuaternion</a> that represents the identity quaternion. <br/></td></tr>
<tr class="separator:ga593ee51ef335cbc420bb7ea13c453156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0440c029b3ede9752761cffc902151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a0440c029b3ede9752761cffc902151"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3a0440c029b3ede9752761cffc902151">XsQuaternion_multiply</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *left, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *right, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *dest)</td></tr>
<tr class="memdesc:ga3a0440c029b3ede9752761cffc902151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply <em>left</em> quaternion with <em>right</em> quaternion and put the result in <em>dest</em>. The parameters may point to the same XsQuaternion(s). <br/></td></tr>
<tr class="separator:ga3a0440c029b3ede9752761cffc902151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ddb691c1f925c8ead506706bda469d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ddb691c1f925c8ead506706bda469d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga91ddb691c1f925c8ead506706bda469d">XsQuaternion_swap</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *a, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *b)</td></tr>
<tr class="memdesc:ga91ddb691c1f925c8ead506706bda469d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>. <br/></td></tr>
<tr class="separator:ga91ddb691c1f925c8ead506706bda469d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51869125847cbfb122309dba983f2162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51869125847cbfb122309dba983f2162"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga51869125847cbfb122309dba983f2162">XsQuaternion_copy</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *copy, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> const *src)</td></tr>
<tr class="memdesc:ga51869125847cbfb122309dba983f2162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of <em>thisPtr</em> into <em>copy</em>. <br/></td></tr>
<tr class="separator:ga51869125847cbfb122309dba983f2162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066fd219bed3ec664d2e37fda22f664f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga066fd219bed3ec664d2e37fda22f664f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga066fd219bed3ec664d2e37fda22f664f">XsQuaternion_equal</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> const *a, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> const *b)</td></tr>
<tr class="memdesc:ga066fd219bed3ec664d2e37fda22f664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns non-zero if <em>a</em> and <em>b</em> are numerically equal <br/></td></tr>
<tr class="separator:ga066fd219bed3ec664d2e37fda22f664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13553237cb71fff5792dda83f4fa0126"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga13553237cb71fff5792dda83f4fa0126">XsRange_count</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *)</td></tr>
<tr class="memdesc:ga13553237cb71fff5792dda83f4fa0126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of values in the range.  <a href="#ga13553237cb71fff5792dda83f4fa0126"></a><br/></td></tr>
<tr class="separator:ga13553237cb71fff5792dda83f4fa0126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5d89008b194a4404db1c8f0cdf35b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc5d89008b194a4404db1c8f0cdf35b2">XsRange_interval</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *)</td></tr>
<tr class="memdesc:gabc5d89008b194a4404db1c8f0cdf35b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of values in the range.  <a href="#gabc5d89008b194a4404db1c8f0cdf35b2"></a><br/></td></tr>
<tr class="separator:gabc5d89008b194a4404db1c8f0cdf35b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1cd63243ef6c97d8dc74100b696ae33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1cd63243ef6c97d8dc74100b696ae33"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa1cd63243ef6c97d8dc74100b696ae33">XsRange_contains</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *, int i)</td></tr>
<tr class="memdesc:gaa1cd63243ef6c97d8dc74100b696ae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the range contains the given value <em>i</em>. <br/></td></tr>
<tr class="separator:gaa1cd63243ef6c97d8dc74100b696ae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced1498a56faedf260bace911f210d46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaced1498a56faedf260bace911f210d46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaced1498a56faedf260bace911f210d46">XsRange_setRange</a> (<a class="el" href="struct_xs_range.html">XsRange</a> *, int f, int l)</td></tr>
<tr class="memdesc:gaced1498a56faedf260bace911f210d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new range. <br/></td></tr>
<tr class="separator:gaced1498a56faedf260bace911f210d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de65698e6d8914121c8fde5832fd5cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6de65698e6d8914121c8fde5832fd5cb">XsRange_empty</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *)</td></tr>
<tr class="memdesc:ga6de65698e6d8914121c8fde5832fd5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the range is empty.  <a href="#ga6de65698e6d8914121c8fde5832fd5cb"></a><br/></td></tr>
<tr class="separator:ga6de65698e6d8914121c8fde5832fd5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade542196fc0232e0801ff67f5ae19abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gade542196fc0232e0801ff67f5ae19abc">XsSdiData_construct</a> (<a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *, const XsReal *orientationIncrement, const XsReal *velocityIncrement)</td></tr>
<tr class="memdesc:gade542196fc0232e0801ff67f5ae19abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an XsSdiData object with the optional arguments.  <a href="#gade542196fc0232e0801ff67f5ae19abc"></a><br/></td></tr>
<tr class="separator:gade542196fc0232e0801ff67f5ae19abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb5973e5a32cfdb3d6490ea651554c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fb5973e5a32cfdb3d6490ea651554c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0fb5973e5a32cfdb3d6490ea651554c7">XsSdiData_destruct</a> (<a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *)</td></tr>
<tr class="memdesc:ga0fb5973e5a32cfdb3d6490ea651554c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the object, makes the fields invalid. <br/></td></tr>
<tr class="separator:ga0fb5973e5a32cfdb3d6490ea651554c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc206cd38f905d821555bb9a322ac7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6cc206cd38f905d821555bb9a322ac7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6cc206cd38f905d821555bb9a322ac7e">XsTimeStamp_setMilliSecondTime</a> (<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *, int64_t t)</td></tr>
<tr class="memdesc:ga6cc206cd38f905d821555bb9a322ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stored time to <em>miliseconds</em>. <br/></td></tr>
<tr class="separator:ga6cc206cd38f905d821555bb9a322ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd4c01e2cac9765f62585aa1a8e1ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaccd4c01e2cac9765f62585aa1a8e1ba1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaccd4c01e2cac9765f62585aa1a8e1ba1">XsTimeStamp_timeOfDay</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:gaccd4c01e2cac9765f62585aa1a8e1ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time of day component of the stored timestamp in seconds as a double precision value. <br/></td></tr>
<tr class="separator:gaccd4c01e2cac9765f62585aa1a8e1ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0753ab6a21c625d468886b2e03150841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0753ab6a21c625d468886b2e03150841"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0753ab6a21c625d468886b2e03150841">XsTimeStamp_secondTime</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga0753ab6a21c625d468886b2e03150841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of seconds elapsed since the epoch as stored in the <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps.">XsTimeStamp</a>. <br/></td></tr>
<tr class="separator:ga0753ab6a21c625d468886b2e03150841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a15a3de652a757c85b6be392200d65d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a15a3de652a757c85b6be392200d65d"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6a15a3de652a757c85b6be392200d65d">XsTimeStamp_milliSecondPart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga6a15a3de652a757c85b6be392200d65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the millisecond part of the time (in the range 0-999) <br/></td></tr>
<tr class="separator:ga6a15a3de652a757c85b6be392200d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73cf9b62e56dc2bd2f4572479f8df07b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73cf9b62e56dc2bd2f4572479f8df07b"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga73cf9b62e56dc2bd2f4572479f8df07b">XsTimeStamp_secondPart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga73cf9b62e56dc2bd2f4572479f8df07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the seconds part of the time (in the range 0-59) <br/></td></tr>
<tr class="separator:ga73cf9b62e56dc2bd2f4572479f8df07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d5e50f0cfb94cee77e3875d7791246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66d5e50f0cfb94cee77e3875d7791246"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga66d5e50f0cfb94cee77e3875d7791246">XsTimeStamp_minutePart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga66d5e50f0cfb94cee77e3875d7791246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minutes part of the time (in the range 0-59) <br/></td></tr>
<tr class="separator:ga66d5e50f0cfb94cee77e3875d7791246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ecd56cfb6fad328170a98a0e0b3d5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9ecd56cfb6fad328170a98a0e0b3d5e"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab9ecd56cfb6fad328170a98a0e0b3d5e">XsTimeStamp_hourPart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:gab9ecd56cfb6fad328170a98a0e0b3d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hours part of the time (in the range 0-23) <br/></td></tr>
<tr class="separator:gab9ecd56cfb6fad328170a98a0e0b3d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471299f2a92ca43888c34e0088f8808d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga471299f2a92ca43888c34e0088f8808d">XsTimeStamp_now</a> (<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *dest)</td></tr>
<tr class="memdesc:ga471299f2a92ca43888c34e0088f8808d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current time in ms since the epoch (Jan 1st 1970)  <a href="#ga471299f2a92ca43888c34e0088f8808d"></a><br/></td></tr>
<tr class="separator:ga471299f2a92ca43888c34e0088f8808d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0466f8867b763d7e97c9191f5c3e5d32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0466f8867b763d7e97c9191f5c3e5d32"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0466f8867b763d7e97c9191f5c3e5d32">XsTimeStamp_maxValue</a> ()</td></tr>
<tr class="memdesc:ga0466f8867b763d7e97c9191f5c3e5d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of an XsTimeStamp. <br/></td></tr>
<tr class="separator:ga0466f8867b763d7e97c9191f5c3e5d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fc3ee8f0b8597295311adb4ff8c78a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga96fc3ee8f0b8597295311adb4ff8c78a">XsTimeStamp_fromUtcTime</a> (struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *, const struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *utc)</td></tr>
<tr class="memdesc:ga96fc3ee8f0b8597295311adb4ff8c78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps.">XsTimeStamp</a> from an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object.  <a href="#ga96fc3ee8f0b8597295311adb4ff8c78a"></a><br/></td></tr>
<tr class="separator:ga96fc3ee8f0b8597295311adb4ff8c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2760d12880e4b6dcd77dac1be3d1068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad2760d12880e4b6dcd77dac1be3d1068">XsTimeStamp_toUtcTime</a> (struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *, struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *utc)</td></tr>
<tr class="memdesc:gad2760d12880e4b6dcd77dac1be3d1068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the timestamp into an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object.  <a href="#gad2760d12880e4b6dcd77dac1be3d1068"></a><br/></td></tr>
<tr class="separator:gad2760d12880e4b6dcd77dac1be3d1068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga028d330e7bb01b01b7ac831c4fe47b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga028d330e7bb01b01b7ac831c4fe47b71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga028d330e7bb01b01b7ac831c4fe47b71">XsVector_ref</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsSize sz, XsReal *buffer, <a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a> flags)</td></tr>
<tr class="memdesc:ga028d330e7bb01b01b7ac831c4fe47b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the XsVector to refer to the supplied buffer. <br/></td></tr>
<tr class="separator:ga028d330e7bb01b01b7ac831c4fe47b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0f6ef88463c27c0ebd5a16eea4d3b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc0f6ef88463c27c0ebd5a16eea4d3b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafc0f6ef88463c27c0ebd5a16eea4d3b6">XsVector_construct</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsSize sz, const XsReal *src)</td></tr>
<tr class="memdesc:gafc0f6ef88463c27c0ebd5a16eea4d3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the XsVector using <em>sz</em> number of items from <em>src</em>. <br/></td></tr>
<tr class="separator:gafc0f6ef88463c27c0ebd5a16eea4d3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd92f0315fa77840940cd63b25612f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd92f0315fa77840940cd63b25612f52">XsVector_assign</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsSize sz, const XsReal *src)</td></tr>
<tr class="memdesc:gafd92f0315fa77840940cd63b25612f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> using <em>sz</em> number of items from <em>src</em>.  <a href="#gafd92f0315fa77840940cd63b25612f52"></a><br/></td></tr>
<tr class="separator:gafd92f0315fa77840940cd63b25612f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82281540cbb4bf44e38d8c9dd455f9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf82281540cbb4bf44e38d8c9dd455f9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf82281540cbb4bf44e38d8c9dd455f9e">XsVector_destruct</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:gaf82281540cbb4bf44e38d8c9dd455f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release and clear the contents of the vector. <br/></td></tr>
<tr class="separator:gaf82281540cbb4bf44e38d8c9dd455f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d7d3e5a0ba913181464ffda5cdda6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5d7d3e5a0ba913181464ffda5cdda6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad5d7d3e5a0ba913181464ffda5cdda6c">XsVector_copy</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *copy, <a class="el" href="struct_xs_vector.html">XsVector</a> const *src)</td></tr>
<tr class="memdesc:gad5d7d3e5a0ba913181464ffda5cdda6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsVector to <em>copy</em>. <br/></td></tr>
<tr class="separator:gad5d7d3e5a0ba913181464ffda5cdda6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732086e0854c6c1218ca3d1fddc7722c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga732086e0854c6c1218ca3d1fddc7722c"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga732086e0854c6c1218ca3d1fddc7722c">XsVector_dotProduct</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *a, const <a class="el" href="struct_xs_vector.html">XsVector</a> *b)</td></tr>
<tr class="memdesc:ga732086e0854c6c1218ca3d1fddc7722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the dot product of XsVectors <em>a</em> and <em>b</em>. <br/></td></tr>
<tr class="separator:ga732086e0854c6c1218ca3d1fddc7722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217ff6e4b3e3624cd6d93e7c4e7b61a3"><td class="memItemLeft" align="right" valign="top">XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga217ff6e4b3e3624cd6d93e7c4e7b61a3">XsVector_cartesianLength</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga217ff6e4b3e3624cd6d93e7c4e7b61a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the cartesian length.  <a href="#ga217ff6e4b3e3624cd6d93e7c4e7b61a3"></a><br/></td></tr>
<tr class="separator:ga217ff6e4b3e3624cd6d93e7c4e7b61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c124e7419bf63e2d3e1682504ca8ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c124e7419bf63e2d3e1682504ca8ff7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c124e7419bf63e2d3e1682504ca8ff7">XsVector_setZero</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga8c124e7419bf63e2d3e1682504ca8ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of the XsVector to 0. <br/></td></tr>
<tr class="separator:ga8c124e7419bf63e2d3e1682504ca8ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c1f360ee7560c392a7b3d09ba3d5d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54c1f360ee7560c392a7b3d09ba3d5d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga54c1f360ee7560c392a7b3d09ba3d5d4">XsVector_fill</a> (struct <a class="el" href="struct_xs_vector.html">XsVector</a> *, XsReal value)</td></tr>
<tr class="memdesc:ga54c1f360ee7560c392a7b3d09ba3d5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of the XsVector to <em>value</em>. <br/></td></tr>
<tr class="separator:ga54c1f360ee7560c392a7b3d09ba3d5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa653c9dadd824d94c9a5ba32ce6b15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9aa653c9dadd824d94c9a5ba32ce6b15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9aa653c9dadd824d94c9a5ba32ce6b15">XsVector_empty</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga9aa653c9dadd824d94c9a5ba32ce6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-zero value if the <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> does not contain any values. <br/></td></tr>
<tr class="separator:ga9aa653c9dadd824d94c9a5ba32ce6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf11db4e898c308aee2929a1f63582c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf11db4e898c308aee2929a1f63582c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadf11db4e898c308aee2929a1f63582c4">XsVector_multiplyScalar</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *, XsReal scalar, <a class="el" href="struct_xs_vector.html">XsVector</a> *dest)</td></tr>
<tr class="memdesc:gadf11db4e898c308aee2929a1f63582c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all values in this <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> by <em>scalar</em> and puts the result in <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> <em>dest</em>. <br/></td></tr>
<tr class="separator:gadf11db4e898c308aee2929a1f63582c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6ac21c4bbc663e10723e982150e1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c6ac21c4bbc663e10723e982150e1b7">XsVector_angularVelocityFromQuaternion</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsReal deltaT, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:ga8c6ac21c4bbc663e10723e982150e1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an effective angular velocity from the quaternion, which must represent a delta angle.  <a href="#ga8c6ac21c4bbc663e10723e982150e1b7"></a><br/></td></tr>
<tr class="separator:ga8c6ac21c4bbc663e10723e982150e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7097bb62e03b0dd0bf57efcb2fa54e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7097bb62e03b0dd0bf57efcb2fa54e7e">XsVector_swap</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *a, <a class="el" href="struct_xs_vector.html">XsVector</a> *b)</td></tr>
<tr class="memdesc:ga7097bb62e03b0dd0bf57efcb2fa54e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>.  <a href="#ga7097bb62e03b0dd0bf57efcb2fa54e7e"></a><br/></td></tr>
<tr class="separator:ga7097bb62e03b0dd0bf57efcb2fa54e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff1df86948c024ea56939838641a05e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5ff1df86948c024ea56939838641a05e">XsVector_equal</a> (const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *a, const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *b)</td></tr>
<tr class="memdesc:ga5ff1df86948c024ea56939838641a05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero when the two vectors are identical.  <a href="#ga5ff1df86948c024ea56939838641a05e"></a><br/></td></tr>
<tr class="separator:ga5ff1df86948c024ea56939838641a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ac3a135a32e7a8656b8e79970029b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5ac3a135a32e7a8656b8e79970029b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac5ac3a135a32e7a8656b8e79970029b3">XsVector3_construct</a> (<a class="el" href="struct_xs_vector3.html">XsVector3</a> *, const XsReal *src)</td></tr>
<tr class="memdesc:gac5ac3a135a32e7a8656b8e79970029b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsVector3 and copy the data from <em>src</em> into the vector if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:gac5ac3a135a32e7a8656b8e79970029b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fee30a3f5faf7de7db788a4dc6c3ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fee30a3f5faf7de7db788a4dc6c3ba7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5fee30a3f5faf7de7db788a4dc6c3ba7">XsVector3_assign</a> (<a class="el" href="struct_xs_vector3.html">XsVector3</a> *, const XsReal *src)</td></tr>
<tr class="memdesc:ga5fee30a3f5faf7de7db788a4dc6c3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsVector3 and copy the data from <em>src</em> into the vector if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:ga5fee30a3f5faf7de7db788a4dc6c3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e212d7063c29d64cb51f783350bf4e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e212d7063c29d64cb51f783350bf4e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8e212d7063c29d64cb51f783350bf4e3">XsVector3_destruct</a> (<a class="el" href="struct_xs_vector3.html">XsVector3</a> *)</td></tr>
<tr class="memdesc:ga8e212d7063c29d64cb51f783350bf4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the <a class="el" href="struct_xs_vector3.html" title="A class that represents a fixed size (3) vector.">XsVector3</a>. <br/></td></tr>
<tr class="separator:ga8e212d7063c29d64cb51f783350bf4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf489613264450e41927680abe4006b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf489613264450e41927680abe4006b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf489613264450e41927680abe4006b8b">XsVector3_copy</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *copy, <a class="el" href="struct_xs_vector3.html">XsVector3</a> const *src)</td></tr>
<tr class="memdesc:gaf489613264450e41927680abe4006b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsVector3 to <em>copy</em>. <br/></td></tr>
<tr class="separator:gaf489613264450e41927680abe4006b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d30e420e615cf22083a28da03d0e10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78d30e420e615cf22083a28da03d0e10"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga78d30e420e615cf22083a28da03d0e10">XsVersion_empty</a> (const <a class="el" href="struct_xs_version.html">XsVersion</a> *)</td></tr>
<tr class="memdesc:ga78d30e420e615cf22083a28da03d0e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this is a null-version. <br/></td></tr>
<tr class="separator:ga78d30e420e615cf22083a28da03d0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b32669f83122d1211b3b0c31612ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6b32669f83122d1211b3b0c31612ed9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6b32669f83122d1211b3b0c31612ed9">XsVersion_toString</a> (const <a class="el" href="struct_xs_version.html">XsVersion</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *version)</td></tr>
<tr class="memdesc:gae6b32669f83122d1211b3b0c31612ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the version expressed in a readable format. <br/></td></tr>
<tr class="separator:gae6b32669f83122d1211b3b0c31612ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab97601f7315ae3199adc282b831db7e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab97601f7315ae3199adc282b831db7e7"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab97601f7315ae3199adc282b831db7e7">XsMath_e</a> = 2.7182818284590452353602874713527</td></tr>
<tr class="memdesc:gab97601f7315ae3199adc282b831db7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value e. <br/></td></tr>
<tr class="separator:gab97601f7315ae3199adc282b831db7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6e3d3d1839bb65757ad40636b171d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c6e3d3d1839bb65757ad40636b171d2"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4c6e3d3d1839bb65757ad40636b171d2">XsMath_pi</a> = 3.1415926535897932384626433832795</td></tr>
<tr class="memdesc:ga4c6e3d3d1839bb65757ad40636b171d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value pi. <br/></td></tr>
<tr class="separator:ga4c6e3d3d1839bb65757ad40636b171d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf554bfa4e69e3b27c5f87258b01833de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf554bfa4e69e3b27c5f87258b01833de"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf554bfa4e69e3b27c5f87258b01833de">XsMath_tinyValue</a> = 1.0e-16</td></tr>
<tr class="memdesc:gaf554bfa4e69e3b27c5f87258b01833de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A really small value. <br/></td></tr>
<tr class="separator:gaf554bfa4e69e3b27c5f87258b01833de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3b28041b0bd6247b2081fffbfc3727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee3b28041b0bd6247b2081fffbfc3727"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee3b28041b0bd6247b2081fffbfc3727">XsMath_hugeValue</a> = 1.0e+16</td></tr>
<tr class="memdesc:gaee3b28041b0bd6247b2081fffbfc3727"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convincingly large number. <br/></td></tr>
<tr class="separator:gaee3b28041b0bd6247b2081fffbfc3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efefc2a45e911cd0f39d7912393a189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2efefc2a45e911cd0f39d7912393a189"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2efefc2a45e911cd0f39d7912393a189">XsMath_epsilon</a> = 2.2204460492503131e-016</td></tr>
<tr class="memdesc:ga2efefc2a45e911cd0f39d7912393a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value related to the precisson of floating point arithmetic (2.2204460492503131e-016) <br/></td></tr>
<tr class="separator:ga2efefc2a45e911cd0f39d7912393a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8730deb54c00eeaffccc0cd89f751ef1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8730deb54c00eeaffccc0cd89f751ef1"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8730deb54c00eeaffccc0cd89f751ef1">XsMath_sqrtEpsilon</a> = 1.4901161193847656e-008</td></tr>
<tr class="memdesc:ga8730deb54c00eeaffccc0cd89f751ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of XsMath_epsilon. <br/></td></tr>
<tr class="separator:ga8730deb54c00eeaffccc0cd89f751ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef8e06324e3369662e0a70d1b86d1ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ef8e06324e3369662e0a70d1b86d1ed"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2ef8e06324e3369662e0a70d1b86d1ed">XsMath_denormalized</a> = 1e-307</td></tr>
<tr class="memdesc:ga2ef8e06324e3369662e0a70d1b86d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value that represents the subnormal number in floating point wizardry. <br/></td></tr>
<tr class="separator:ga2ef8e06324e3369662e0a70d1b86d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5002d16ca92da32aedeb28b4a0c265b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5002d16ca92da32aedeb28b4a0c265b"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae5002d16ca92da32aedeb28b4a0c265b">XsMath_sqrtDenormalized</a> = 3.1622776601683793319988935444327e-154</td></tr>
<tr class="memdesc:gae5002d16ca92da32aedeb28b4a0c265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of XsMath_denormalized. <br/></td></tr>
<tr class="separator:gae5002d16ca92da32aedeb28b4a0c265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ed1429bd5b6c6e1c23526af0969bf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67ed1429bd5b6c6e1c23526af0969bf1"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga67ed1429bd5b6c6e1c23526af0969bf1">XsMath_rad2degValue</a> = 57.295779513082320876798154814105</td></tr>
<tr class="memdesc:ga67ed1429bd5b6c6e1c23526af0969bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to convert radians to degrees by multiplication. <br/></td></tr>
<tr class="separator:ga67ed1429bd5b6c6e1c23526af0969bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ea89ab3df5b3ef0ec5151dba3fb97b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99ea89ab3df5b3ef0ec5151dba3fb97b"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga99ea89ab3df5b3ef0ec5151dba3fb97b">XsMath_deg2radValue</a> = 0.017453292519943295769236907684886</td></tr>
<tr class="memdesc:ga99ea89ab3df5b3ef0ec5151dba3fb97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to convert degrees to radians by multiplication. <br/></td></tr>
<tr class="separator:ga99ea89ab3df5b3ef0ec5151dba3fb97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2a42313dfb3c1b1fb4068e85bd2092"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f2a42313dfb3c1b1fb4068e85bd2092"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1f2a42313dfb3c1b1fb4068e85bd2092">XsMath_zero</a> = 0.0</td></tr>
<tr class="memdesc:ga1f2a42313dfb3c1b1fb4068e85bd2092"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 <br/></td></tr>
<tr class="separator:ga1f2a42313dfb3c1b1fb4068e85bd2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c4eab8d61589ad6c75798a479f74ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2c4eab8d61589ad6c75798a479f74ea"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab2c4eab8d61589ad6c75798a479f74ea">XsMath_pt25</a> = 0.25</td></tr>
<tr class="memdesc:gab2c4eab8d61589ad6c75798a479f74ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">0.25 <br/></td></tr>
<tr class="separator:gab2c4eab8d61589ad6c75798a479f74ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bc8cad523dc271cbbb4a7fe8819d242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bc8cad523dc271cbbb4a7fe8819d242"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8bc8cad523dc271cbbb4a7fe8819d242">XsMath_pt5</a> = 0.5</td></tr>
<tr class="memdesc:ga8bc8cad523dc271cbbb4a7fe8819d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">0.5 <br/></td></tr>
<tr class="separator:ga8bc8cad523dc271cbbb4a7fe8819d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac7deb2c99feb885697688f44f275aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabac7deb2c99feb885697688f44f275aa"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabac7deb2c99feb885697688f44f275aa">XsMath_minusPt5</a> = -0.5</td></tr>
<tr class="memdesc:gabac7deb2c99feb885697688f44f275aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">-0.5 <br/></td></tr>
<tr class="separator:gabac7deb2c99feb885697688f44f275aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8bcb595cebc269662be8fbb178cd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a8bcb595cebc269662be8fbb178cd4c"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5a8bcb595cebc269662be8fbb178cd4c">XsMath_one</a> = 1.0</td></tr>
<tr class="memdesc:ga5a8bcb595cebc269662be8fbb178cd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0 <br/></td></tr>
<tr class="separator:ga5a8bcb595cebc269662be8fbb178cd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1d592f937af3f06b8839a0415f0dbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf1d592f937af3f06b8839a0415f0dbd"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabf1d592f937af3f06b8839a0415f0dbd">XsMath_minusOne</a> = -1.0</td></tr>
<tr class="memdesc:gabf1d592f937af3f06b8839a0415f0dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">-1.0 <br/></td></tr>
<tr class="separator:gabf1d592f937af3f06b8839a0415f0dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a45ccb8ca11408266e4ce06e5d04c80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a45ccb8ca11408266e4ce06e5d04c80"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4a45ccb8ca11408266e4ce06e5d04c80">XsMath_two</a> = 2.0</td></tr>
<tr class="memdesc:ga4a45ccb8ca11408266e4ce06e5d04c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 <br/></td></tr>
<tr class="separator:ga4a45ccb8ca11408266e4ce06e5d04c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcca87b18866b7ed7c435da6c7a17484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabcca87b18866b7ed7c435da6c7a17484"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabcca87b18866b7ed7c435da6c7a17484">XsMath_four</a> = 4.0</td></tr>
<tr class="memdesc:gabcca87b18866b7ed7c435da6c7a17484"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 <br/></td></tr>
<tr class="separator:gabcca87b18866b7ed7c435da6c7a17484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab984b7c0fc78b6252046a91aa874b5d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab984b7c0fc78b6252046a91aa874b5d8"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab984b7c0fc78b6252046a91aa874b5d8">XsMath_minusTwo</a> = -2.0</td></tr>
<tr class="memdesc:gab984b7c0fc78b6252046a91aa874b5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">-2 <br/></td></tr>
<tr class="separator:gab984b7c0fc78b6252046a91aa874b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3a4325d0e3428720084c3ca05555de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a3a4325d0e3428720084c3ca05555de"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8a3a4325d0e3428720084c3ca05555de">XsMath_minusHalfPi</a> = -1.570796326794897</td></tr>
<tr class="memdesc:ga8a3a4325d0e3428720084c3ca05555de"><td class="mdescLeft">&#160;</td><td class="mdescRight">-pi/2 <br/></td></tr>
<tr class="separator:ga8a3a4325d0e3428720084c3ca05555de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd74b3381c1548825092aad63a4c1dfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd74b3381c1548825092aad63a4c1dfa"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadd74b3381c1548825092aad63a4c1dfa">XsMath_halfPi</a> = +1.570796326794897</td></tr>
<tr class="memdesc:gadd74b3381c1548825092aad63a4c1dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">pi/2 <br/></td></tr>
<tr class="separator:gadd74b3381c1548825092aad63a4c1dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78efef0592e979f9cee61a9aa3c1b92b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78efef0592e979f9cee61a9aa3c1b92b"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga78efef0592e979f9cee61a9aa3c1b92b">XsMath_sqrt2</a> = 1.4142135623730950488016887242097</td></tr>
<tr class="memdesc:ga78efef0592e979f9cee61a9aa3c1b92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sqrt(2) <br/></td></tr>
<tr class="separator:ga78efef0592e979f9cee61a9aa3c1b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723b566b6a4e00659e47aee982f56ada"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga723b566b6a4e00659e47aee982f56ada"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga723b566b6a4e00659e47aee982f56ada">XsMath_infinity</a> = DBL_MAX</td></tr>
<tr class="memdesc:ga723b566b6a4e00659e47aee982f56ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity value <br/></td></tr>
<tr class="separator:ga723b566b6a4e00659e47aee982f56ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac1dfbf570dd9179d632bbf3fd163a483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t byteSum </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the sum of the values in the buffer. </p>
<p>This function calculates the sum of the byte values for the first <em>count</em> bytes in the <em>buffer</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>An array of (unsigned) bytes </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unsigned sum of the byte values in the buffer modulo 256 </dd></dl>

</div>
</div>
<a class="anchor" id="gafb6a5994363a3d4d175eb5a4d42d7452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void validatePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the packet is internally consistent. </p>
<p>This function will throw an exception if there are inconsistencies in the size of the message buffers and the size as reported by the header. </p>

</div>
</div>
<a class="anchor" id="ga6556d22268f56b6dbd77befdbdad0f68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_append </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the <em>other</em> list to thisArray list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The list to append to thisArray list. <em>other</em> may point to thisArray list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7b75e01c27f76b4d91aaa135e4e1a5c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_assign </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>. </p>
<p>This function reinitializes the object reserving space for at least <em>count</em> items in the buffer. <em>count</em> may be 0. If <em>src</em> is not 0, <em>count</em> items will be copied from <em>src</em>. Previous data will be cleared automatically, but the reserved space will not be reduced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of items in src </td></tr>
    <tr><td class="paramname">src</td><td>a pointer to an array of output configuration objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9e7d83d6428ea82a43d4c44167e75c54" title="Reserves space for count items.">XsArray_reserve</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4de36061187ffca3834ee403bfaff57d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void const * XsArray_at </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the item to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the item or NULL if <em>index</em> is out of bounds </dd></dl>

</div>
</div>
<a class="anchor" id="ga5004f8c9e45e57e43b09d6160648591c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * XsArray_atIndex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the item to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the item or NULL if <em>index</em> is out of bounds </dd></dl>

</div>
</div>
<a class="anchor" id="ga63b78f3e6c2315d7e9741a9336781c49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsArray_compare </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero if the lists are different, 0 if they're equal. </p>
<p>This function compares the two lists in-order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The left hand side of the comparison </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal. Please note that not all lists have items that can be accurately tested for less than or greater than, but can be tested for (in-)equality. So the sign of the return value should be treated with knowledge of the data type in mind. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga72561edb500d3e01c3aeb40de6d6a3db" title="Returns -1 if a is smaller in some way than b, 1 if it is larger in some way and 0 if both lists are ...">XsArray_compareSet</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga72561edb500d3e01c3aeb40de6d6a3db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsArray_compareSet </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns -1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal. </p>
<p>This function compares the two lists out-of-order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The left hand side of the comparison </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal. Please note that not all lists have items that can be accurately tested for less than or greater than, but can be tested for (in-)equality. So the sign of the return value should be treated with knowledge of the data type in mind. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga63b78f3e6c2315d7e9741a9336781c49" title="Returns non-zero if the lists are different, 0 if they&#39;re equal.">XsArray_compare</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7222e508e1e5b424ba34648a4e31fd98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_construct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_array_descriptor.html">XsArrayDescriptor</a> const *const&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>. </p>
<p>This function initializes the object reserving <em>count</em> items in the buffer. <em>count</em> may be 0. If <em>src</em> is not 0, <em>count</em> items from <em>src</em> will be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor</td><td>The descriptor of the data in the list </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to reserve space for. When <em>src</em> is not NULL, thisArray is also the number of items copied from <em>src</em> </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to an array of objects to copy, may be NULL, ignored when <em>count</em> is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga953d7cc7a9ecd8405f2d85b50edc0d56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_copyConstruct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with a copy of <em>src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the objects to copy. The object may be empty, but src may not be 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga754df4d700d8f759e3dd29aca3ab629f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_destruct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears and frees memory allocated by the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a>. </p>
<dl class="section note"><dt>Note</dt><dd>After XsArray_destruct is called, the object is empty but valid, ie. it can be used as if XsArray_construct has been called on it. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6969403e331f28f7534cc2945ddcc09c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsArray_find </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of <em>needle</em> in the list or -1 if it wasn't found. </p>
<p>The search does not assume any kind of ordering of the items so in a worst-case scenario it will go through the entire list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>A pointer to the value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of where <em>needle</em> was found or -1 if it wasn't found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1698369198b2417d5b5021a660281297"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_insert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>count</em> items from <em>src</em> at <em>index</em> in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to use for inserting. Anything beyond the end of the array (ie. -1) will append to the actual end of the array. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to insert </td></tr>
    <tr><td class="paramname">src</td><td>The items to insert, may not be 0 unless count is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8d1845c9e3d0e754c40807de07208d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_removeDuplicates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes duplicate entries from the array, keeping only the first instance of each value. </p>

</div>
</div>
<a class="anchor" id="ga9e7d83d6428ea82a43d4c44167e75c54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_reserve </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for <em>count</em> items. </p>
<p>This function reserves space for exactly <em>count</em> items unless <em>count</em> is less than the current list size. The function will retain the current data in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of items to reserve space for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga7b75e01c27f76b4d91aaa135e4e1a5c3" title="Reinitializes the XsArray with space for count items and copies them from src.">XsArray_assign</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_resize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the existing list to <em>count</em> items. </p>
<p>This function will keep the data of the remaining items intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of items the list should have </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9e7d83d6428ea82a43d4c44167e75c54" title="Reserves space for count items.">XsArray_reserve</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga7b75e01c27f76b4d91aaa135e4e1a5c3" title="Reinitializes the XsArray with space for count items and copies them from src.">XsArray_assign</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad01697484c2c698f779345d64e199a5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_swap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> with those of <em>b</em>. </p>
<p>Where possible, the pointers and administrative values are swapped. If for some reason thisArray is not possible, the lists are swapped one element at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The list to swap with <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>The list to swap with <em>a</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga704fac796d6899e53094d97403927442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate XsBaud_codeToRate </td>
          <td>(</td>
          <td class="paramtype">XsBaudCode&#160;</td>
          <td class="paramname"><em>baudcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Xsens baud code to XsBaudRate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudcode</td><td>: The code to convert to an XsBaudRate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An XsBaudrate </dd></dl>

</div>
</div>
<a class="anchor" id="ga7439bd0c058b38ce73d843d39fcef299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate XsBaud_numericToRate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numeric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a numeric baudrate in bps to XsBaudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numeric</td><td>: The numeric baudrate to convert to XsBaudRate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A XsBaudrate </dd></dl>

</div>
</div>
<a class="anchor" id="gaa587d7e451a00e7a3c2c4432c346cf9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudCode XsBaud_rateToCode </td>
          <td>(</td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a XsBaudRate to an Xsens baud code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>: The code to convert to an XsBaudCode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An XsBaudCode </dd></dl>

</div>
</div>
<a class="anchor" id="ga532744ada4da5b1e9c8a277cc98628a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsBaud_rateToNumeric </td>
          <td>(</td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a XsBaudrate to a numeric baudrate in bps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>: The XsBaudRate to convert to a numeric baudrate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A baudrate in bps </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8f40f309a7a5e3aec100dc8414104c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* XsDataFlags_toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the XsDataFlags to a human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The flags to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a statically allocated memory buffer. Do not free this buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is NOT reentrant, multiple simultaneous calls may cause crashes. Also, later calls will invalidate the results of earlier calls. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1bb2c43334630ab37781b05d5a0a076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDataPacket_altitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position altitude component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>The altitude stored in the packet or XsMath_infinity if no altitude is available </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gaf17e37b4198366ef799fac69e4301ee9" title="Check if data item contains position altitude data.">XsDataPacket_containsAltitude</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaa45af0d8bfc4107fb0c09640cbda1f09" title="The position lat lon alt component of a data item.">XsDataPacket_positionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga74073fd7f88c1d458c6fbb4314d041b9" title="The position latitude longitude component of a data item.">XsDataPacket_latitudeLongitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga984fcbb151bb425bed68fd15f214e530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> * XsDataPacket_analogIn1Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analog in 1 component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> object that the analog in 1 value will be assigned to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> containing the analog in 1 value </dd></dl>

</div>
</div>
<a class="anchor" id="ga742702ec9806c8ce2ad92d3e3bdab699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> * XsDataPacket_analogIn2Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analog in 2 component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> object that the analog in 2 value will be assigned to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> containing the analog in 2 value </dd></dl>

</div>
</div>
<a class="anchor" id="gaec420bb6de5d632e4fa3f5e4751ef3f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> * XsDataPacket_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the data items from <em>other</em> to the packet. </p>
<p>The data items contained in <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> <em>other</em> will be appended to this packet. Items that are already contained will not be overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>: The <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> to read the data items from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the updated data packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fddb259bdabf11dcc062770c50f0fb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_calibratedAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calibrated accelerometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> that the calibrated acceleration will be assigned to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gabc6048d525e0e5e7bb504d7a7c08ebb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> * XsDataPacket_calibratedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the calibrated Data component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>Storage for the requested data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the supplied <em>returnVal</em> filled with the requested data </dd></dl>

</div>
</div>
<a class="anchor" id="ga48f8510e32c5ce64be24aa4e4357977c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_calibratedGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calibrated gyroscope component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b29dfe4997c15a16cc47524353a0b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_calibratedMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calibrated magnetometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gaf17e37b4198366ef799fac69e4301ee9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsAltitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains position altitude data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains position altitude data </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gaf3fd8178e684cfe66bb696540bab029d" title="Check if data item contains position lat lon alt data.">XsDataPacket_containsPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga84873964429e40c3dec1ad5f5cbff300" title="Check if data item contains position latitude longitude data.">XsDataPacket_containsLatitudeLongitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e15bfb90ba4a319b147edd5c69b093f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsAnalogIn1Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains analog in 1 data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains analog in 1 data </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b909a7cf3d951bd587e462167ed8943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsAnalogIn2Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains analog in 2 data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains analog in 2 data </dd></dl>

</div>
</div>
<a class="anchor" id="ga97126b54948708a4fe4396ed6c1c377f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated accelerometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains calibrated accelerometer data </dd></dl>

</div>
</div>
<a class="anchor" id="ga87c01a1ed158b5e3537fe702377611f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated Data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the packet contains calibrated data or not </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calibrated data is only present if <em>all</em> components are present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60ed952bed9c7ca76e937ce062a09fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated gyroscope data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains calibrated gyroscope data </dd></dl>

</div>
</div>
<a class="anchor" id="gaef4578f0373d56a4f810bd2b11c75660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated magnetometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains calibrated magnetometer data </dd></dl>

</div>
</div>
<a class="anchor" id="ga74ac53ce205dd1188f542d68cfe4489d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsDetailedStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains detailed status data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains detailed status data </dd></dl>

</div>
</div>
<a class="anchor" id="gad58130ed5eb306a370faf88dd3b5dc83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsFrameRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the datapacket contains a framerange. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the datapacket contains a framerange </dd></dl>

</div>
</div>
<a class="anchor" id="gae1307b6dfe823a65ae9e035295e485f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsFreeAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains free acceleration. </p>
<p>Free acceleration is the acceleration with the local gravity vector subtracted. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains free acceleration </dd></dl>

</div>
</div>
<a class="anchor" id="ga4592f786dece1c41d0a2c480cc83338d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsGpsPvtData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains gps PVT data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains gps PVT data </dd></dl>

</div>
</div>
<a class="anchor" id="ga84873964429e40c3dec1ad5f5cbff300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsLatitudeLongitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains position latitude longitude data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains position latitude longitude data </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gaf3fd8178e684cfe66bb696540bab029d" title="Check if data item contains position lat lon alt data.">XsDataPacket_containsPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaf17e37b4198366ef799fac69e4301ee9" title="Check if data item contains position altitude data.">XsDataPacket_containsAltitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca7c3cdac9092bcabd206fb6a634919d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains orientation Data of any kind. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="ga8aa1b7a6f13ea2bdd22ce75332601b34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPacketCounter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains a packet counter. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains a packet counter </dd></dl>

</div>
</div>
<a class="anchor" id="ga72422178927a7ce88254b0b9e37076da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPacketCounter8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains an 8 bit packet counter. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains an 8 bit packet counter </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3fd8178e684cfe66bb696540bab029d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPositionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains position lat lon alt data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains position lat lon alt data </dd></dl>

</div>
</div>
<a class="anchor" id="ga47889699665bb08e201fae0f3e6eb984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPressure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains pressure data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains pressure data </dd></dl>

</div>
</div>
<a class="anchor" id="gaf45a927643b25f86b659ee60784590c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPressureAge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains pressure age data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains pressure age data </dd></dl>

</div>
</div>
<a class="anchor" id="gab4cf09e402b3a79ae77f2f2b8319667f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains Raw Accelerometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw acceleration data </dd></dl>

</div>
</div>
<a class="anchor" id="ga517f271754bceccef3989b9b9d939755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw data </dd></dl>

</div>
</div>
<a class="anchor" id="gaf41fa8c51bc0bdd7a948c26f29cb993a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw gyroscope data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw gyroscope data </dd></dl>

</div>
</div>
<a class="anchor" id="ga957722c94b3de10844beb19bceb9499f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawGyroscopeTemperatureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw gyroscope temperature data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw gyroscope temperature data </dd></dl>

</div>
</div>
<a class="anchor" id="gabbd354b23b58b9a25af2ed141dd4ba48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw magnetometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw magnetometer data </dd></dl>

</div>
</div>
<a class="anchor" id="gae33c1f5eb46f0e30ecbdb2f5f3f52680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawTemperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw temperature data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw temperature data </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f360268043a4fc135884256f00e34e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the datapacket contains an rssi value. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the datapacket contains an rssi value </dd></dl>

</div>
</div>
<a class="anchor" id="gab69c00776dc3a25fa9a0bf6d178d6e29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSampleTime64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> contains a full 64-bit sample time. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> contains both a fine and coarse sample time </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bd77491910c63fabf11167c66f5dc3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSampleTimeCoarse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item XsDataPacket_contains a sample time coarse. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet XsDataPacket_contains a sample time coarse </dd></dl>

</div>
</div>
<a class="anchor" id="ga00be954b34a7a3697229bfd6f04dccaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSampleTimeFine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item XsDataPacket_contains a sample time fine. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet XsDataPacket_contains a sample time fine </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f5ecc04a489160f62f261de66a02497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSdiData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains strapdown integration data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this packet contains sdi data </dd></dl>

</div>
</div>
<a class="anchor" id="gad1713a40540a9d9e74feddde498b429b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains legacy status data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains legacy status data </dd></dl>

</div>
</div>
<a class="anchor" id="gabdb321aba93424a38c986c10972bb4b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsStatusByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns wether the XsDataPacket contains a statusbyte. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this packet contains a statusbyte </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a768d2f6b29b740b110e869b54f682b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsTemperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains temperature data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains temperature data </dd></dl>

</div>
</div>
<a class="anchor" id="ga45de3d34c2383f51ff85c41d042da13f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsTriggerIndication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>triggerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains trigger indication data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerId</td><td>The trigger data identifier to check (e.g. XDI_TriggerIn1 or XDI_TriggerIn2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains trigger indication data </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fddd1161e2606088e18804c47edc0d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsUtcTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains utc time data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains utc time data </dd></dl>

</div>
</div>
<a class="anchor" id="ga075b55f7591d36c2eb93bf4b5e6690fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains velocity NED data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains velocity NED data </dd></dl>

</div>
</div>
<a class="anchor" id="gab33cedaf486f7ea05478fc1891dbd59e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_coordinateSystemOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate system of the first orientation data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the coordinate system of the first orientation data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bb8f791a622d1594b2985a89101e975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_coordinateSystemVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate system of the first velocity data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the coordinate system of the first velocity data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga00224a13a6b7220f43dacf6e90645298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_dataFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dataformat of a specific data identifier in the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: The XsDataIdentifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns XDI_None if the packet does not contain the dataidentifier, the data format otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252" title="Defines the data identifiers.">XsDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa9a426ac35cf230d4d6016ebee6d6c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_range.html">XsRange</a> * XsDataPacket_frameRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the frame range contained in the datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_range.html" title="A class whose objects can be used to store a range. It provides method to check whether a value is in...">XsRange</a> object that will get the range from the packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="struct_xs_range.html" title="A class whose objects can be used to store a range. It provides method to check whether a value is in...">XsRange</a> object with the range from the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga67e1ec4bf4fde8f406bc8743eb5eeeb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_freeAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The free acceleration component of a data item. </p>
<p>Free acceleration is the acceleration with the local gravity vector subtracted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the gravity acceleration </dd></dl>

</div>
</div>
<a class="anchor" id="gae0a782bc042f7cc6eb779d78aa5e20b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsDataPacket_getFPValueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the byte size of <em>id</em> if the format is a floating point format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: The XsDataIdentifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte size of XsDataIdentifier <em>id</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ga159f5666dafb668580256c6af709dce6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> * XsDataPacket_gpsPvtData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The gps PVT data component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_gps_pvt_data.html" title="Data from the GPS unit of a legacy MTi-G.">XsGpsPvtData</a> object to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_gps_pvt_data.html" title="Data from the GPS unit of a legacy MTi-G.">XsGpsPvtData</a> containing the gps PVT data </dd></dl>

</div>
</div>
<a class="anchor" id="ga9652cd8a68c2389fe27822e35d7d4fa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_itemOffsetExact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item offset of the supplied data identifier <em>id</em> using strict matching criteria. </p>
<p>This function will search for an exact match of <em>id</em>, including the subformat. Equivalent to XsDataPacket_itemOffsetMasked(thisPtr, id, XDI_FullMask); </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The data identifier to return the offset off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in the message where the data of this identifier can be found or -1 if it could not be found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gac8965ee66cdb54fedb30532722588ba6" title="Return the item offset of the supplied data identifier id using loose matching criteria.">XsDataPacket_itemOffsetLoose</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaccc7556dbcc95a99751eca59d41b1001" title="Return the item offset of the supplied data identifier id using matching criteria specified by mask...">XsDataPacket_itemOffsetMasked</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac8965ee66cdb54fedb30532722588ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_itemOffsetLoose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item offset of the supplied data identifier <em>id</em> using loose matching criteria. </p>
<p>This function will ignore the subformat of the data when searching for <em>id</em>. Equivalent to XsDataPacket_itemOffsetMasked(thisPtr, id, ~XDI_SubFormatMask); </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The data identifier to return the offset off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in the message where the data of this identifier can be found or -1 if it could not be found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9652cd8a68c2389fe27822e35d7d4fa9" title="Return the item offset of the supplied data identifier id using strict matching criteria.">XsDataPacket_itemOffsetExact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaccc7556dbcc95a99751eca59d41b1001"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_itemOffsetMasked </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item offset of the supplied data identifier <em>id</em> using matching criteria specified by <em>mask</em>. </p>
<p>This function will ignore the bits not in the mask when searching for <em>id</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The data identifier to return the offset off </td></tr>
    <tr><td class="paramname">mask</td><td>The bits to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in the message where the data of this identifier can be found or -1 if it could not be found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9652cd8a68c2389fe27822e35d7d4fa9" title="Return the item offset of the supplied data identifier id using strict matching criteria.">XsDataPacket_itemOffsetExact</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gac8965ee66cdb54fedb30532722588ba6" title="Return the item offset of the supplied data identifier id using loose matching criteria.">XsDataPacket_itemOffsetLoose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga74073fd7f88c1d458c6fbb4314d041b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_latitudeLongitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position latitude longitude component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to return the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the latitude and longitude values in that order </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga84873964429e40c3dec1ad5f5cbff300" title="Check if data item contains position latitude longitude data.">XsDataPacket_containsLatitudeLongitude</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaa45af0d8bfc4107fb0c09640cbda1f09" title="The position lat lon alt component of a data item.">XsDataPacket_positionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaf1bb2c43334630ab37781b05d5a0a076" title="The position altitude component of a data item.">XsDataPacket_altitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1605983648c9e678da6b2e04213293d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_euler.html">XsEuler</a> * XsDataPacket_orientationEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_euler.html">XsEuler</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the orientation component of a data item as a euler angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>An XsEuler to put the requested orientation in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested orientation. If this does not match the stored coordinate system, it will be transformed to the requested orientation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A XsEuler containing the orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="gad47cd95b1d759e97eecca58161eeee5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_orientationIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data identifier of the first orientation data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the first orientation data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f622e95ca566c0e8627b6b5a362d9d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> * XsDataPacket_orientationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the orientation component of a data item as a orientation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>An XsMatrix to put the requested orientation in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested orientation. If this does not match the stored coordinate system, it will be transformed to the requested orientation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An XsMatrix containing the orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="ga0149c98d71b9bfe8803485775d41f0ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> * XsDataPacket_orientationQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the orientation component of a data item as a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>An XsQuaternion to put the requested orientation in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested orientation. If this does not match the stored coordinate system, it will be transformed to the requested orientation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_quaternion.html" title="A class that implements a quaternion.">XsQuaternion</a> containing the orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="ga6333be127f949ebb5c3cc3839046a86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a>* XsDataPacket_originalMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the original message of the data packet. </p>
<p>This returns the original message that was last set with setMessage, or in the constructor. When the packet was constructed from a legacy message, the legacy message will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>The XsMessage that the message of the packet is copied to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returnVal </dd></dl>

</div>
</div>
<a class="anchor" id="gac897f266dc357670ff551f82edbf7bae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDataPacket_packetCounter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet/frame counter of a packet. </p>
<p>For strapdown integration data, this function will return the m_wlastFrameNumber For other data, this function will return the m_sc</p>
<p>This way there is a function that will always return the counter of a packet</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the packet/frame counter of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="gac33cb466ebe40612bd66801cb3bf65d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsDataPacket_packetCounter8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 8 bit packet counter of a packet. </p>
<p>This function returns an 8 bit packet counter as used by some third party devices</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the 8 bit packet counter of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="gaa45af0d8bfc4107fb0c09640cbda1f09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_positionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position lat lon alt component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to return the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the latitude, longitude and altitude values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gacb5562328d6b7612efb2263f9216f444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_pressure.html">XsPressure</a> * XsDataPacket_pressure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_pressure.html">XsPressure</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The air pressure component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_pressure.html" title="Pressure data.">XsPressure</a> object to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_pressure.html" title="Pressure data.">XsPressure</a> object containing the pressure and if available the pressure age </dd></dl>

</div>
</div>
<a class="anchor" id="gae0f76199c6002f84e70d052f5734cd77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw accelerometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga5604d1a08bfcf788d9dc5cc5143f7008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw gyroscope component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d19682f28bbccf51ede5129a489308e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawGyroscopeTemperatureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw gyroscope temperature component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gae5c11ad29680b10e01f52a0f140554be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw magnetometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb399f7bef85d6305b33a8c2a8dc9aa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDataPacket_rawTemperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw temperature component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>An uint16_t containing the raw temperature value </dd></dl>

</div>
</div>
<a class="anchor" id="ga30697102dfb8de08d4b8f4b3e5362834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_rssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rssi value contained in the datapacket. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the rssi value contained in the datapacket </dd></dl>

</div>
</div>
<a class="anchor" id="gaba3aabf7c48a5972924c6274ca8d28e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDataPacket_sampleTimeFine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fine sample time of a packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the fine sample time of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga954395b7b5af631e31e9b0493acec7b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> * XsDataPacket_sdiData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the strapdown integration data component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>Storage for the requested data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the supplied <em>returnVal</em> filled with the requested data </dd></dl>

</div>
</div>
<a class="anchor" id="gaeffa2fd1c18474fe885b643abb25399f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setAltitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update altitude data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The altitude data to store in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga20fd010f517f69c99199f28a43474a3c" title="Add/update position lat lon alt data for the item.">XsDataPacket_setPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga99054a34e98f315e4fd31b6be56a97a9" title="Add/update position latitude longitude data for the item.">XsDataPacket_setLatitudeLongitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga48d69b7bbbd2c6393c908f511085f31d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setFrameRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets or updates the frame range in the datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>: The <a class="el" href="struct_xs_range.html" title="A class whose objects can be used to store a range. It provides method to check whether a value is in...">XsRange</a> object that should be added to the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ebbb512b59c7748a45fa70f3da5c667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setFreeAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update free acceleration data for the item. </p>
<p>Free acceleration is the acceleration with the local gravity vector subtracted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A 3-component vector containing the new free acceleration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9674a10af2e9f0f25da5afb1ea569893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setGpsPvtData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update gps PVT data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The data to update the <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga99054a34e98f315e4fd31b6be56a97a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setLatitudeLongitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update position latitude longitude data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> that contains the latitude longitude data to store in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga20fd010f517f69c99199f28a43474a3c" title="Add/update position lat lon alt data for the item.">XsDataPacket_setPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaeffa2fd1c18474fe885b643abb25399f" title="Add/update altitude data for the item.">XsDataPacket_setAltitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4598964d5372f185a2b67ba82846ee72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a message in a datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20fd010f517f69c99199f28a43474a3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setPositionLLA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update position lat lon alt data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> that conrtains the Lat/Long/Alt data to store in the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c1939610911dbe628aa86fdaf60e191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setRawAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update raw accelerometer data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>: The data to update the <a class="el" href="struct_xs_data_packet.html" title="Contains data received from a device or read from a file.">XsDataPacket</a> with</td></tr>
  </table>
  </dd>
</dl>
<p>This will add the raw acceleration from <em>vec</em> to the data packet. If the packet already contains raw acceleration, it will be replaced. </p>

</div>
</div>
<a class="anchor" id="gaee18c6de4dd432a2361dd981f9c4e7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setRssi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets or updates the rssi value in the datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>: The rssi value that should be added to the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52705223ff52de6e52f0f8746da3d2da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setSdiData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update strapdown integration data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The updated data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaecd3755ae9c05a6e03db67ae8fa6a178"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setTemperature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>temperature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds or updates the temperature data in the datapacket. </p>
<p>The <em>temp</em> is added to the datapacket. If the packet already contains temperature it is replaced with the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temperature</td><td>: The temperature to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4e80aaced3a3102ad4b6e4cc732eb77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setTriggerIndication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>triggerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> const *&#160;</td>
          <td class="paramname"><em>triggerIndicationData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update trigger indication data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerId</td><td>The trigger data identifier to add data for (e.g. XDI_TriggerIn1 or XDI_TriggerIn2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerIndicationData</td><td>pointer the a <a class="el" href="struct_xs_trigger_indication_data.html" title="Data for a trigger indication message.">XsTriggerIndicationData</a> buffer containing the data to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8aad732d8ba37df041168b8aa256a49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDataPacket_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The status component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>An uint32_t containing the status value </dd></dl>

</div>
</div>
<a class="anchor" id="gac6d218f313dc1be12638fd38d9fe39a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDataPacket_temperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The temperature component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>A double containing the temperature value, -1000.0 if the packet does not contain temperature </dd></dl>

</div>
</div>
<a class="anchor" id="gad2b22f2e3d9ed049488d6797fb279370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> * XsDataPacket_triggerIndication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>triggerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trigger indication data of a packet If the packet does not contain the requested data, the return val struct will be set to all zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerId</td><td>The trigger data identifier to add data for (e.g. XDI_TriggerIn1 or XDI_TriggerIn2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returnVal</td><td>pointer to the trigger indication data of a packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returnVal should point to a buffer large enough to hold sizeof(XsTriggerIndicationData) bytes of data </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the trigger indication data of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d14dd8d8800650f30c10b8592bcf7c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> * XsDataPacket_utcTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The utc time component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> to return the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> containing the utc time value </dd></dl>

</div>
</div>
<a class="anchor" id="gaa11d6d994aa40c6f8277081ecadb9216"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_velocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The velocity NWU component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the data in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested velocity. If this does not match the stored coordinate system, it will be transformed to the requested velocity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b78a321c23bc634ccfe41730e748824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_velocityIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data identifier of the first velocity data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the first velocity data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3aa84511f07c5b343ee77112361dfaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsMatrix_multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsReal&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies all values in this <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> by <em>scalar</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>: Value to multiply by </td></tr>
    <tr><td class="paramname">dest</td><td>: The <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> to store the result in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84490340feeeb8c23327124019db1dde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsMatrix_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset in the data for accessing the value at <em>row</em> and <em>column</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row of the value </td></tr>
    <tr><td class="paramname">column</td><td>The column of the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the requested item in the internal buffer </dd></dl>

</div>
</div>
<a class="anchor" id="gab4218a181d23c28cf3e927b7504a9069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsMatrix_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> and <em>b</em>. </p>
<p>This function swaps the internal buffers so no actual data is moved around. This won't work for unmanaged data such as fixed size matrices (<a class="el" href="struct_xs_matrix3x3.html" title="A class that represents a fixed size (3x3) matrix.">XsMatrix3x3</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Object whose contents will be placed in <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>Object whose contents will be placed in <em>a</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9da904b977b09ad3aaa4e32c4672cd12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reinitializes the XsMessage object and reserves <em>dataSize</em> bytes for data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>the expected size of the message payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02356a5cefd94aa7719c39ba9692b598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* XsMessage_constData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a const pointer to the <em>offset</em> in the data of the message in <em>thisptr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset of the data to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data at offset <em>offset</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3aff1ac742c36f378747f4df0a7eb65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_constructSized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the XsMessage object and reserves <em>dataSize</em> bytes for data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>the expected size of the message payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5926dcf4e25e601ae0059b95afc5e226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies from <em>thisPtr</em> to <em>copy</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the object to copy to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4ca57ead95b63178f60835f2374039e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsMessage_dataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the datasize of the message in <em>thisptr</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga9212be8c3889701fad8c40da79822bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_deleteData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>count</em> bytes of data from the message at <em>offset</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of bytes to remove </td></tr>
    <tr><td class="paramname">offset</td><td>the offset at which to remove the bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee251864355965b32fe3af9fa07e2419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the data in the message. </p>

</div>
</div>
<a class="anchor" id="gaa07140d194f0089a8c40e7738d1622ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsMessage_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this message is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if this message is empty, zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gac06b9bc8c27a860d057a39d9c208c327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_message_header.html">XsMessageHeader</a>* XsMessage_getConstHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the message header </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e1ab9a85f8b5c16a798d8920f1b69c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* XsMessage_getDataBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const pointer to the data buffer of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the data buffer of the message </dd></dl>

</div>
</div>
<a class="anchor" id="ga91ca4b85ce514c4688055917e7ec0591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsMessage_getDataByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the byte value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga73b548351bd3eb7e86187679ac83f572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsMessage_getDataDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the double at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double precision floating point value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cf009aeda779d5955bba969390a1fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsMessage_getDataF1220 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the F12.20 value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 12.20 fixed point value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="gafd25a9320f3fbfabcd193bff5b5185c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float XsMessage_getDataFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the float value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single precision float value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga127c683e09b2db4ce8e161949e778bb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsMessage_getDataFP1632 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the F16.32 value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 16.32 fixed point value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c80c694ccbad9cc68b216a318a85463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_getDataFPValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>outputSettings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current data values as a double(64 bits), after converting it from float, double, FP1632 or FP1220 depending on outputSettings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputSettings</td><td>the output settings containing the current floating/fixed point settings </td></tr>
    <tr><td class="paramname">dest</td><td>an array of double values containing at least <em>numValues</em> items </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to start reading </td></tr>
    <tr><td class="paramname">numValues</td><td>the amount of numbers to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae0f330f1e8ff7b541f721dcf9211030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_getDataFPValuesById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current data values as double, conversion depends on outputSetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination array </td></tr>
    <tr><td class="paramname">dataIdentifier</td><td>Data identifier containing data precision </td></tr>
    <tr><td class="paramname">offset</td><td>offset in the data buffer from where to start reading. </td></tr>
    <tr><td class="paramname">numValues</td><td>number of values to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42d5a40697d57c0da08e1d21c82fb6e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsMessage_getDataLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the long value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 32-bit integer value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="gabc53fffde12da101d13f3528111e1dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsMessage_getDataShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the short value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 16-bit integer value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="gad4ef5f47b2fe7bca6d550001b5b09296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* XsMessage_getMessageStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a const pointer to the header of the message in <em>thisptr</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the message </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dd01bb00c8b697a56aafc443c1ddfd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsMessage_getTotalMessageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of the message buffer. </p>
<p>The function returns the total size of the message, including the checksum. This is in effect the number of bytes that would be transferred if the message were to be sent over a communications channel.</p>
<dl class="section return"><dt>Returns</dt><dd>the total message size </dd></dl>

</div>
</div>
<a class="anchor" id="ga4901534c43c5716f67f1b73ae215626e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_insertData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <em>count</em> bytes of empty space at <em>offset</em> in this message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of bytes to reserve </td></tr>
    <tr><td class="paramname">offset</td><td>the offset at which to allocate the space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f7081af4eca1ef8996da037155ce72a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsMessage_isChecksumOk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if the checksum inside the message is correct for the message, zero otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>true (non-zero) if the checksum inside the message is correct, false (zero) otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gad4dde94962cb03ca78d207d7ed7f5b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>msgSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the XsMessage object and reserves <em>msgSize</em> bytes for data, it then copies in the data from <em>src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgSize</td><td>the size of the data pointed to by src </td></tr>
    <tr><td class="paramname">src</td><td>the data to load the message from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a71f01ef77db025407f19e93dae9ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_resizeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the buffer of message to <em>newSize</em> bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the message payload buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf083ca2bf41d2efdd4fd224bc53c9fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setBusId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>busId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bus id for this message to <em>busId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busId</td><td>the bus identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga44cefb784042cbd1494268a2735c095f" title="The bus broadcast bus identifier (all devices)">XS_BID_BROADCAST</a> <a class="el" href="group__cinterface.html#gae8321d23871bd495a735cccbac26b451" title="The bus identifier of the master device.">XS_BID_MASTER</a> <a class="el" href="group__cinterface.html#gab9478ee24f1f927f712dd4ad6caa7bc7" title="The bus identifier for the first MT on the bus.">XS_BID_MT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab68055a504cd3ad0108b216d7ec447fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts <em>size</em> number of bytes from <em>buffer</em> into the message at <em>offset</em>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The buffersize of will be increased if <em>buffer</em> is too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer to copy </td></tr>
    <tr><td class="paramname">size</td><td>the size of the buffer </td></tr>
    <tr><td class="paramname">offset</td><td>the offset at which to copy the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa23c89aa06c089d2fec7a4d11c573fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the byte at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga497e871bda0c859a73dfe1f1e29de6a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the double at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the double precision floating point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga366d27f459a11717add7e69ee6c85878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataF1220 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the F12.20 at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 12.20 fixed point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1234b6e6d4411d8b0c702fa440841ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the float at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the single precision floating point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf69a92d482776fa1c730e6dc1247e5f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFP1632 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the F16.32 at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16.32 fixed point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04bcae80049f7b33e84ebdffc116b321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFPValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>outputSettings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a floating/fixed point value into to the data buffer, conversion depends on outputSettings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputSettings</td><td>MT output settings </td></tr>
    <tr><td class="paramname">data</td><td>The data array to be written to the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the data buffer from where to start writing. </td></tr>
    <tr><td class="paramname">numValues</td><td>number of values to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadde1d1e334dbf921acf03ee0a25eada3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFPValuesById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a number of floating/fixed point values into to the data buffer, conversion depends on outputSettings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataIdentifier</td><td>Data Identifier </td></tr>
    <tr><td class="paramname">data</td><td>The data array to be written to the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the data buffer from where to start writing. </td></tr>
    <tr><td class="paramname">numValues</td><td>number of values to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga64de205a7a48f0b109856f2e105e7ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the long at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga359dc1326aa818e5168db40264d80502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the short at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga235e41e089f2c0fc8860bf83df1311d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setMessageId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a>&#160;</td>
          <td class="paramname"><em>msgId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the message id for this message to <em>msgId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>the message identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b9e73d2db2d034d0ae1c3f95fb37cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> and <em>b</em>. </p>
<p>This function swaps the internal buffers so no actual data is moved around. A result is that it won't work for unmanaged data such as fixed size vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the object to receive <em>b's</em> contents </td></tr>
    <tr><td class="paramname">b</td><td>the object to receive <em>a's</em> contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa32b87ad68904738bb4ad9e64758f05a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsPortInfo_portNumber </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port number. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the port number </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Available on Windows only </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f7a31f4a8a7aaf3a18c9152d9e993ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsPortInfo_usbAddress </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The usb address. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the usb address </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Available on Linux only </dd></dl>

</div>
</div>
<a class="anchor" id="ga07a9ed806c36fb0f13e476ad29ff6876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsPortInfo_usbBus </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The usb bus. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Usb bus number </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Available on Linux only </dd></dl>

</div>
</div>
<a class="anchor" id="ga5021de7e1f89887d357b80e69c15d5ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsQuaternion_fromRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>ori</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a quaternion representation of orientation matrix <em>ori</em>. </p>
<p>The matrix <em>ori</em> is interpreted as an orthonormal orientation matrix, which is translated into a quaternion representation. If <em>ori</em> is not a 3x3 matrix, a null-quaternion is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ori</td><td>The source orientation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b7269b337234843b87fd7df7f68efa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsQuaternion_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse/conjugate of this quaternion. </p>
<p>Where <em>q</em> = a + bi + cj + dk, this function will return a - bi - cj - dk in <em>dest</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The object to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga217fd03f808db0b06765e3bbb85fc9cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsQuaternion_invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert this quaternion. </p>
<p>Where <em>q</em> = a + bi + cj + dk, this function will replace it with a - bi - cj - dk. </p>

</div>
</div>
<a class="anchor" id="ga13553237cb71fff5792dda83f4fa0126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsRange_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of values in the range. </p>
<dl class="section note"><dt>Note</dt><dd>The range is <em>inclusive</em> [first, last] instead of [first, last&gt;. So count [1, 2] = 2 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of values in the range (inclusive) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6de65698e6d8914121c8fde5832fd5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsRange_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the range is empty. </p>
<p>An empty range has a last element that is lower than its first element. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the range is empty, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gabc5d89008b194a4404db1c8f0cdf35b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsRange_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of values in the range. </p>
<dl class="section note"><dt>Note</dt><dd>The range is <em>exclusive</em> [first, last&gt; instead of [first, last]. So interval [1, 2] = 1 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of values in the range (exclusive) </dd></dl>

</div>
</div>
<a class="anchor" id="ga79baa392a62fc5e3ed73d351e4f2c403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsRssi_unbiased </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the raw RSSI value transformed into a usable (unbiased) number. </p>
<p>Actual rssi is calculated by <em>raw</em> + XS_RSSI_MAX, where <em>raw</em> is a negative number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The RSSI value as reported by the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unbiased RSSI value. </dd></dl>

</div>
</div>
<a class="anchor" id="gade542196fc0232e0801ff67f5ae19abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsSdiData_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XsReal *&#160;</td>
          <td class="paramname"><em>orientationIncrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XsReal *&#160;</td>
          <td class="paramname"><em>velocityIncrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an XsSdiData object with the optional arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientationIncrement</td><td>The orientation increment to initialize the object with, may be 0 </td></tr>
    <tr><td class="paramname">velocityIncrement</td><td>The velocity increment to initialize the object with, may be 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae38505926760a0a5e7dd314e683ae546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getDateAsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the date as string representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 bytes </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga393705293aa555086514c8835ad019da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getDateAsWString </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the date as wstring representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 wchars </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae059db4e22b6f6d69ae31bb7291cd9f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTime_getDateTime </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the date and time (platform-independent) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>: if non-zero the local (!) date and time is stored in the tm struct this parameter points to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTC date and time as seconds since 1970 </dd></dl>

</div>
</div>
<a class="anchor" id="gafb389fca2f6341c79b2262caf7a9d6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getTimeAsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 bytes </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>(for now hundreths are set to 0) </dd></dl>

</div>
</div>
<a class="anchor" id="ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getTimeAsWString </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 wchars </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>(for now hundreths are set to 0) </dd></dl>

</div>
</div>
<a class="anchor" id="gac54582842a30b1029a66050279844a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsTime_getTimeOfDay </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>date_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t *&#160;</td>
          <td class="paramname"><em>secs_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the current time of day in ms since midnight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_</td><td>When not 0, the corresponding current date is put in here. </td></tr>
    <tr><td class="paramname">secs_</td><td>When not 0, the full timestamp in seconds since the epoch is put in here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of milliseconds that have passed since midnight. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1b31cc058a52b02959dc1b80e729fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_initializeTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stabilize the clock. </p>
<p>Repeatedly call XsTime_timeStampNow for 16-32 ms to stabilize the clock </p>

</div>
</div>
<a class="anchor" id="ga28efdfd01aad10c9da7baaeb6d7b8931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_msleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the current thread sleep for at least <em>ms</em> milliseconds. </p>
<p>A platform independent sleep routine to sleep for at least <em>ms</em> milliseconds.</p>
<p>On linux we are using pthread_cond_t, which implies that the timedwait() is a cancellation point. This function might return sooner than expected in some cases due to system events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The number of milliseconds to sleep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga45d819f679819b2c2c6bc4f7a35f2dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTime_timeStampNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname"><em>now</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current time in ms since the epoch (Jan 1st 1970) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">now</td><td>Pointer to XsTimeStamp container for the returned value, may be 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current time in ms since the epoch (Jan 1st 1970) as a 64-bit integer </dd></dl>

</div>
</div>
<a class="anchor" id="ga8268408ade85db6aa5f5a8bb56f00f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_udelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays the current thread for at least <em>us</em> microseconds. </p>
<p>A platform independent delay routine to sleep for at least <em>us</em> microseconds.</p>
<p>On linux we are using pthread_cond_t, which implies that the timedwait() is a cancellation point. This function might return sooner than expected in some cases due to system events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>The number of microseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96fc3ee8f0b8597295311adb4ff8c78a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTimeStamp_fromUtcTime </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td>
          <td class="paramname"><em>utc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps.">XsTimeStamp</a> from an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utc</td><td>The UTC time to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted time in ms since the epoch (Jan 1st 1970) </dd></dl>

</div>
</div>
<a class="anchor" id="ga471299f2a92ca43888c34e0088f8808d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTimeStamp_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current time in ms since the epoch (Jan 1st 1970) </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga45d819f679819b2c2c6bc4f7a35f2dde" title="Returns the current time in ms since the epoch (Jan 1st 1970)">XsTime_timeStampNow</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The object to write the time to, may be 0 in which case only the return value is generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current time in ms since the epoch (Jan 1st 1970) </dd></dl>

</div>
</div>
<a class="anchor" id="gad2760d12880e4b6dcd77dac1be3d1068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsTimeStamp_toUtcTime </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td>
          <td class="paramname"><em>utc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the timestamp into an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utc</td><td>The UTC time object to write the conversion result to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c6ac21c4bbc663e10723e982150e1b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsVector_angularVelocityFromQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsReal&#160;</td>
          <td class="paramname"><em>deltaT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an effective angular velocity from the quaternion, which must represent a delta angle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deltaT</td><td>The length of the time interval over which <em>quat</em> was integrated in seconds </td></tr>
    <tr><td class="paramname">quat</td><td>The orientation increment to convert to an angular velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the effective angular velocity in radians around each axis. </dd></dl>

</div>
</div>
<a class="anchor" id="gafd92f0315fa77840940cd63b25612f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsVector_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XsReal *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> using <em>sz</em> number of items from <em>src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>The desired size of the vector </td></tr>
    <tr><td class="paramname">src</td><td>0 or a pointer to a buffer containing <em>sz</em> items to copy into the XsVector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga217ff6e4b3e3624cd6d93e7c4e7b61a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsReal XsVector_cartesianLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the cartesian length. </p>
<dl class="section return"><dt>Returns</dt><dd>The cartesian length (square root of the dot product) of the vector </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ff1df86948c024ea56939838641a05e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsVector_equal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero when the two vectors are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector to compare against <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>Vector to compare against <em>a</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero when the vectors are identical </dd></dl>

</div>
</div>
<a class="anchor" id="ga7097bb62e03b0dd0bf57efcb2fa54e7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsVector_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> and <em>b</em>. </p>
<p>This function swaps the internal buffers so no actual data is moved around. For unmanaged data an elementwise swap is done, but only if the vectors are the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Object whose contents will be placed in <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>Object whose contents will be placed in <em>a</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Wed Jan 8 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
