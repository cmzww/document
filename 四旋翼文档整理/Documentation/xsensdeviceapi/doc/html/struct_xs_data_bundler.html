<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsDataBundler Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_xs_data_bundler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsDataBundler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Combines data from multiple sources into one stream.  
 <a href="struct_xs_data_bundler.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a67d3234d66b2e6b2bc1d157ba01830"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a67d3234d66b2e6b2bc1d157ba01830"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830">destruct</a> (void)</td></tr>
<tr class="memdesc:a7a67d3234d66b2e6b2bc1d157ba01830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a> object and free all memory allocated for it. <br/></td></tr>
<tr class="separator:a7a67d3234d66b2e6b2bc1d157ba01830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e5f03418179418747b6afd101aac75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a92e5f03418179418747b6afd101aac75">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:a92e5f03418179418747b6afd101aac75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="#a92e5f03418179418747b6afd101aac75"></a><br/></td></tr>
<tr class="separator:a92e5f03418179418747b6afd101aac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee33d2d07a889447c8b7382aab4d414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a1ee33d2d07a889447c8b7382aab4d414">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a1ee33d2d07a889447c8b7382aab4d414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="#a1ee33d2d07a889447c8b7382aab4d414"></a><br/></td></tr>
<tr class="separator:a1ee33d2d07a889447c8b7382aab4d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a4a11f8e767730db39168a156f3a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a45a4a11f8e767730db39168a156f3a24">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a45a4a11f8e767730db39168a156f3a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#a45a4a11f8e767730db39168a156f3a24"></a><br/></td></tr>
<tr class="separator:a45a4a11f8e767730db39168a156f3a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8287ac015c8cc377195d3094630cecc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a8287ac015c8cc377195d3094630cecc6">toCallbackPlainC</a> (void)</td></tr>
<tr class="separator:a8287ac015c8cc377195d3094630cecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae656d6159ec83e47361df9ffe225b0d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#ae656d6159ec83e47361df9ffe225b0d6">addDevice</a> (const <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ae656d6159ec83e47361df9ffe225b0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device to expect data from.  <a href="#ae656d6159ec83e47361df9ffe225b0d6"></a><br/></td></tr>
<tr class="separator:ae656d6159ec83e47361df9ffe225b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae406cdc9ceac2d41d6f57560f0a19d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#ae406cdc9ceac2d41d6f57560f0a19d3d">removeDevice</a> (const <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ae406cdc9ceac2d41d6f57560f0a19d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device to expect data from.  <a href="#ae406cdc9ceac2d41d6f57560f0a19d3d"></a><br/></td></tr>
<tr class="separator:ae406cdc9ceac2d41d6f57560f0a19d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68ef48c8fa30ffed96246dac5c23426"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#ad68ef48c8fa30ffed96246dac5c23426">packet</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceId)</td></tr>
<tr class="memdesc:ad68ef48c8fa30ffed96246dac5c23426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> sent by a specific device from the current full bundle for which a callback is currently called.  <a href="#ad68ef48c8fa30ffed96246dac5c23426"></a><br/></td></tr>
<tr class="separator:ad68ef48c8fa30ffed96246dac5c23426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbc4da04ec21e1b877a20c122ba51c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a1dbc4da04ec21e1b877a20c122ba51c3">at</a> (unsigned idx)</td></tr>
<tr class="memdesc:a1dbc4da04ec21e1b877a20c122ba51c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> at a specified index in the current full bundle for which a callback is currently called.  <a href="#a1dbc4da04ec21e1b877a20c122ba51c3"></a><br/></td></tr>
<tr class="separator:a1dbc4da04ec21e1b877a20c122ba51c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dd163a5b2377fe72671301729f40ae"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#ac7dd163a5b2377fe72671301729f40ae">count</a> (void) const </td></tr>
<tr class="memdesc:ac7dd163a5b2377fe72671301729f40ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data packets in the current full bundle for which a callback is currently called.  <a href="#ac7dd163a5b2377fe72671301729f40ae"></a><br/></td></tr>
<tr class="separator:ac7dd163a5b2377fe72671301729f40ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b28599e9f82dab5a89b700a3df571c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a87b28599e9f82dab5a89b700a3df571c">~XsDataBundler</a> ()</td></tr>
<tr class="memdesc:a87b28599e9f82dab5a89b700a3df571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, calls <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function to clean up object.  <a href="#a87b28599e9f82dab5a89b700a3df571c"></a><br/></td></tr>
<tr class="separator:a87b28599e9f82dab5a89b700a3df571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3aec558cfac70dfcdf264c8b5f5136df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aec558cfac70dfcdf264c8b5f5136df"></a>
static <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df">construct</a> (void)</td></tr>
<tr class="memdesc:a3aec558cfac70dfcdf264c8b5f5136df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new XsDataBundler* object. Clean it up with the <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function. <br/></td></tr>
<tr class="separator:a3aec558cfac70dfcdf264c8b5f5136df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aba65cc329d4170f871cb126e99f919ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba65cc329d4170f871cb126e99f919ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#aba65cc329d4170f871cb126e99f919ec">operator delete</a> (void *)</td></tr>
<tr class="memdesc:aba65cc329d4170f871cb126e99f919ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded delete operator to allow user to use delete instead of calling <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function <br/></td></tr>
<tr class="separator:aba65cc329d4170f871cb126e99f919ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab899f5fd02ca4fd7dfd34f3ac9f67dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#aab899f5fd02ca4fd7dfd34f3ac9f67dd">XsDataBundler</a> ()</td></tr>
<tr class="memdesc:aab899f5fd02ca4fd7dfd34f3ac9f67dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df" title="Construct a new XsDataBundler* object. Clean it up with the destruct() function.">construct()</a> function instead.  <a href="#aab899f5fd02ca4fd7dfd34f3ac9f67dd"></a><br/></td></tr>
<tr class="separator:aab899f5fd02ca4fd7dfd34f3ac9f67dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace66862f9f64d807b14e2ff663a1163a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace66862f9f64d807b14e2ff663a1163a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#ace66862f9f64d807b14e2ff663a1163a">operator new</a> (size_t)</td></tr>
<tr class="memdesc:ace66862f9f64d807b14e2ff663a1163a"><td class="mdescLeft">&#160;</td><td class="mdescRight">new operator not implemented to prevent faulty memory allocation by user, use <a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df" title="Construct a new XsDataBundler* object. Clean it up with the destruct() function.">construct()</a> function instead <br/></td></tr>
<tr class="separator:ace66862f9f64d807b14e2ff663a1163a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654e875c534da0541e3f12dd13f4f3a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a654e875c534da0541e3f12dd13f4f3a3"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a654e875c534da0541e3f12dd13f4f3a3">operator new[]</a> (size_t)</td></tr>
<tr class="memdesc:a654e875c534da0541e3f12dd13f4f3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">array new operator not implemented to prevent faulty memory allocation by user, use <a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df" title="Construct a new XsDataBundler* object. Clean it up with the destruct() function.">construct()</a> function instead <br/></td></tr>
<tr class="separator:a654e875c534da0541e3f12dd13f4f3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bca547812a8da5c38afcb39c6202359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bca547812a8da5c38afcb39c6202359"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_data_bundler.html#a6bca547812a8da5c38afcb39c6202359">operator delete[]</a> (void *)</td></tr>
<tr class="memdesc:a6bca547812a8da5c38afcb39c6202359"><td class="mdescLeft">&#160;</td><td class="mdescRight">array delete operator not implemented to prevent faulty memory deallocation by user, use <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function instead <br/></td></tr>
<tr class="separator:a6bca547812a8da5c38afcb39c6202359"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Combines data from multiple sources into one stream. </p>
<p>The data bundler class can be attached to several devices and provide a callback when it has received data from all those devices. It will use the packetId of the received data packets to find matching packets.</p>
<p>DataPacketSource --&mdash;+-&gt; <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a> +-&gt; DataBundleQueue +-&gt; DataBundle -&gt; <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>[] -+&gt; Callback 1 DataPacketSource --&mdash;+ | (callback 1) +-&gt; DataBundle -&gt; <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>[] -+ DataPacketSource --&mdash;+ | +-&gt; DataBundle -&gt; <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>[] -+ DataPacketSource --&mdash;+ | +-&gt; DataBundleQueue +-&gt; DataBundle -&gt; <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>[] -+&gt; Callback 2 (Callback 2) +-&gt; DataBundle -&gt; <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>[] -+ +-&gt; DataBundle -&gt; <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>[] -+ </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a87b28599e9f82dab5a89b700a3df571c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDataBundler::~XsDataBundler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, calls <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function to clean up object. </p>
<p>Destructor.</p>
<p>The destructor unregisters the object from all <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> objects it is attached to and then cleans itself up. </p>

</div>
</div>
<a class="anchor" id="aab899f5fd02ca4fd7dfd34f3ac9f67dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDataBundler::XsDataBundler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df" title="Construct a new XsDataBundler* object. Clean it up with the destruct() function.">construct()</a> function instead. </p>
<p>Default constructor, initializes the object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1ee33d2d07a889447c8b7382aab4d414"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDataBundler::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="ae656d6159ec83e47361df9ffe225b0d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler::addDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a device to expect data from. </p>
<p>Use this function to tell the data bundler that it should include data from the supplied device in its bundled data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to add to the internal list of devices to expect data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_data_bundler.html#ae406cdc9ceac2d41d6f57560f0a19d3d" title="Remove a device to expect data from.">removeDevice</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbc4da04ec21e1b877a20c122ba51c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> * XsDataBundler::at </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> at a specified index in the current full bundle for which a callback is currently called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the packet in the bundle</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only valid when called from within the data callback functions. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> at a specified index </dd></dl>

</div>
</div>
<a class="anchor" id="a92e5f03418179418747b6afd101aac75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDataBundler::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all child devices as well (true, default) or just the callback handlers of this XsDevice object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7dd163a5b2377fe72671301729f40ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XsDataBundler::count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of data packets in the current full bundle for which a callback is currently called. </p>
<p>This function is only valid when called from within the data callback functions. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of data packets in the current full bundle for which a callback is currently called </dd></dl>

</div>
</div>
<a class="anchor" id="ad68ef48c8fa30ffed96246dac5c23426"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> * XsDataBundler::packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> sent by a specific device from the current full bundle for which a callback is currently called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The id of the device that sent the packet</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only valid when called from within the data callback functions. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> send by a specific device </dd></dl>

</div>
</div>
<a class="anchor" id="a45a4a11f8e767730db39168a156f3a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDataBundler::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="ae406cdc9ceac2d41d6f57560f0a19d3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler::removeDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a device to expect data from. </p>
<p>Use this function to tell the data bundler that it should no longer include data from the supplied device in its bundled data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to remove from the internal list of devices to expect data from. When NULL is supplied, all devices are removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_data_bundler.html#ae656d6159ec83e47361df9ffe225b0d6" title="Add a device to expect data from.">addDevice</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8287ac015c8cc377195d3094630cecc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> * XsDataBundler::toCallbackPlainC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API.">XsCallbackPlainC</a> pointer that can be used to register the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a> as a callback handler </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Thu Jan 16 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
