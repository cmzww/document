<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Callback functions.</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Callback functions.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24d179eecbcde2ca2f3206cb6f7c05f0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0">XsCallback::onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <br/></td></tr>
<tr class="separator:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a65730e9aa35fe9c52c92807741f088"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a65730e9aa35fe9c52c92807741f088"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088">XsCallback::onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga9a65730e9aa35fe9c52c92807741f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <br/></td></tr>
<tr class="separator:ga9a65730e9aa35fe9c52c92807741f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32f20ce601f007ba4e571e40a4f8f71e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e">XsCallback::onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <br/></td></tr>
<tr class="separator:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac8d7f94d6cb77f5fe56effaa36752e4a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a">XsCallback::onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <br/></td></tr>
<tr class="separator:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70ff4796b9bb5e3d79eac2c7cd870e59"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59">XsCallback::onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <br/></td></tr>
<tr class="separator:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d34298b034dda9f344f3eb9fc132290"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290">XsCallback::onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:ga5d34298b034dda9f344f3eb9fc132290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.   <a href="#ga5d34298b034dda9f344f3eb9fc132290"></a><br/></td></tr>
<tr class="separator:ga5d34298b034dda9f344f3eb9fc132290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69aabc16295d1503527badccbef3378"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa69aabc16295d1503527badccbef3378">XsCallback::onWriteDataToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data)</td></tr>
<tr class="memdesc:gaa69aabc16295d1503527badccbef3378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.   <a href="#gaa69aabc16295d1503527badccbef3378"></a><br/></td></tr>
<tr class="separator:gaa69aabc16295d1503527badccbef3378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad6280b5dc0c8e458b22e26a50bad40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40">XsCallback::onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:gacad6280b5dc0c8e458b22e26a50bad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.   <a href="#gacad6280b5dc0c8e458b22e26a50bad40"></a><br/></td></tr>
<tr class="separator:gacad6280b5dc0c8e458b22e26a50bad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5">XsCallback::onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.   <a href="#ga224586f8f7e0e9f0b57091b7d9a24bc5"></a><br/></td></tr>
<tr class="separator:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4a31e495dde9ee053c070fbf06cbe89f">XsCallback::onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.   <a href="#ga4a31e495dde9ee053c070fbf06cbe89f"></a><br/></td></tr>
<tr class="separator:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656b04fa94f7b374dcbda27dba20b835"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga656b04fa94f7b374dcbda27dba20b835">XsCallback::onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga656b04fa94f7b374dcbda27dba20b835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.   <a href="#ga656b04fa94f7b374dcbda27dba20b835"></a><br/></td></tr>
<tr class="separator:ga656b04fa94f7b374dcbda27dba20b835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cc6f779fca5b3ced0480a731991b18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf7cc6f779fca5b3ced0480a731991b18">XsCallback::onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gaf7cc6f779fca5b3ced0480a731991b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.   <a href="#gaf7cc6f779fca5b3ced0480a731991b18"></a><br/></td></tr>
<tr class="separator:gaf7cc6f779fca5b3ced0480a731991b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae0b5c78ecbf3e01a754d4591cb88294f">XsCallback::onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.   <a href="#gae0b5c78ecbf3e01a754d4591cb88294f"></a><br/></td></tr>
<tr class="separator:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaca8357ec5742ef6d4049a2233f8e19a2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaca8357ec5742ef6d4049a2233f8e19a2">XsCallbackPlainC::m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:gaca8357ec5742ef6d4049a2233f8e19a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="#gaca8357ec5742ef6d4049a2233f8e19a2"></a><br/></td></tr>
<tr class="separator:gaca8357ec5742ef6d4049a2233f8e19a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a885ea2551982fff371bb7cc973675e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8a885ea2551982fff371bb7cc973675e">XsCallbackPlainC::m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8a885ea2551982fff371bb7cc973675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga8a885ea2551982fff371bb7cc973675e"></a><br/></td></tr>
<tr class="separator:ga8a885ea2551982fff371bb7cc973675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0fe0a8618b800d5b3fb010b1f12747b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf0fe0a8618b800d5b3fb010b1f12747b">XsCallbackPlainC::m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:gaf0fe0a8618b800d5b3fb010b1f12747b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="#gaf0fe0a8618b800d5b3fb010b1f12747b"></a><br/></td></tr>
<tr class="separator:gaf0fe0a8618b800d5b3fb010b1f12747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ebc107cb25d2f5634e851a2fcf7dde6"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga6ebc107cb25d2f5634e851a2fcf7dde6">XsCallbackPlainC::m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga6ebc107cb25d2f5634e851a2fcf7dde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="#ga6ebc107cb25d2f5634e851a2fcf7dde6"></a><br/></td></tr>
<tr class="separator:ga6ebc107cb25d2f5634e851a2fcf7dde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390b75d6831b352dba4e5d9d0fb16c1e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga390b75d6831b352dba4e5d9d0fb16c1e">XsCallbackPlainC::m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga390b75d6831b352dba4e5d9d0fb16c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="#ga390b75d6831b352dba4e5d9d0fb16c1e"></a><br/></td></tr>
<tr class="separator:ga390b75d6831b352dba4e5d9d0fb16c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de6ee9c01f30e0d77b6c5a62df6a3d3"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga1de6ee9c01f30e0d77b6c5a62df6a3d3">XsCallbackPlainC::m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:ga1de6ee9c01f30e0d77b6c5a62df6a3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="#ga1de6ee9c01f30e0d77b6c5a62df6a3d3"></a><br/></td></tr>
<tr class="separator:ga1de6ee9c01f30e0d77b6c5a62df6a3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f265234224a0c3e2f56f73dfadc848"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gac0f265234224a0c3e2f56f73dfadc848">XsCallbackPlainC::m_onWriteDataToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data)</td></tr>
<tr class="memdesc:gac0f265234224a0c3e2f56f73dfadc848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="#gac0f265234224a0c3e2f56f73dfadc848"></a><br/></td></tr>
<tr class="separator:gac0f265234224a0c3e2f56f73dfadc848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7714ef8ed4e49f2f1b97ea2a3dded9"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga5c7714ef8ed4e49f2f1b97ea2a3dded9">XsCallbackPlainC::m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga5c7714ef8ed4e49f2f1b97ea2a3dded9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="#ga5c7714ef8ed4e49f2f1b97ea2a3dded9"></a><br/></td></tr>
<tr class="separator:ga5c7714ef8ed4e49f2f1b97ea2a3dded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc5e6f11e0d31c9be1ba9d7c6a1d892"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaacc5e6f11e0d31c9be1ba9d7c6a1d892">XsCallbackPlainC::m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:gaacc5e6f11e0d31c9be1ba9d7c6a1d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="#gaacc5e6f11e0d31c9be1ba9d7c6a1d892"></a><br/></td></tr>
<tr class="separator:gaacc5e6f11e0d31c9be1ba9d7c6a1d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833ea7b93e5b738e22b8ba572a06b8cc"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga833ea7b93e5b738e22b8ba572a06b8cc">XsCallbackPlainC::m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga833ea7b93e5b738e22b8ba572a06b8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="#ga833ea7b93e5b738e22b8ba572a06b8cc"></a><br/></td></tr>
<tr class="separator:ga833ea7b93e5b738e22b8ba572a06b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d20b1bf629eb3c261c3ccaa9718fd0b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8d20b1bf629eb3c261c3ccaa9718fd0b">XsCallbackPlainC::m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga8d20b1bf629eb3c261c3ccaa9718fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="#ga8d20b1bf629eb3c261c3ccaa9718fd0b"></a><br/></td></tr>
<tr class="separator:ga8d20b1bf629eb3c261c3ccaa9718fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97563380f7297f58f2e3323b698feef7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga97563380f7297f58f2e3323b698feef7">XsCallbackPlainC::m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga97563380f7297f58f2e3323b698feef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="#ga97563380f7297f58f2e3323b698feef7"></a><br/></td></tr>
<tr class="separator:ga97563380f7297f58f2e3323b698feef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33d298036ba7621e0bddf8b51ccdb63"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gad33d298036ba7621e0bddf8b51ccdb63">XsCallbackPlainC::m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gad33d298036ba7621e0bddf8b51ccdb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="#gad33d298036ba7621e0bddf8b51ccdb63"></a><br/></td></tr>
<tr class="separator:gad33d298036ba7621e0bddf8b51ccdb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gacad6280b5dc0c8e458b22e26a50bad40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onConnectivityChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td>
          <td class="paramname"><em>newState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has detected a change in the connectivity state of a device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">newState</td><td>The new connectivity state </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4a31e495dde9ee053c070fbf06cbe89f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an error has occurred while handling incoming data.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">error</td><td>The error code that specifies exactly what problem occurred </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga224586f8f7e0e9f0b57091b7d9a24bc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onInfoResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a>&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an information request has resulted in a response.  </p>
<p>When the information request has completed, the data can be retrieved through the usual functions. Ie. when a requestBatteryLevel() resulted in an onInfoResponse(.., XIR_BatteryLevel), the <a class="el" href="struct_xs_device.html#ad9a5dd4a13161a69e4927191a7295cd3" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">XsDevice::batteryLevel</a> function will return the received battery level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">request</td><td>The type of request that was completed </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf7cc6f779fca5b3ced0480a731991b18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageReceivedFromDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a valid message (after parsing) is received from the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="gae0b5c78ecbf3e01a754d4591cb88294f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageSentToDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a message is sent to the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that will receive the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga656b04fa94f7b374dcbda27dba20b835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onNonDataMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a non data, non reply message has been received.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="gaa69aabc16295d1503527badccbef3378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int XsCallback::onWriteDataToLogFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has a data packet that could be written to a log file.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>0 to prevent the message from being written, non-0 to allow the write. This applies only to data packets, not to other messages. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>onWriteMessageToLogFile </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device, such as the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a>. </td></tr>
    <tr><td class="paramname">data</td><td>The data that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5d34298b034dda9f344f3eb9fc132290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int XsCallback::onWriteMessageToLogFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has a message that could be written to a log file.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>0 to prevent the message from being written, non-0 to allow the write. This includes data packets. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___callbacks.html#gac0f265234224a0c3e2f56f73dfadc848" title="Called when XDA has a data packet that could be written to a log file.">m_onWriteDataToLogFile</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device, such as the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a>. </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>
 </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga5c7714ef8ed4e49f2f1b97ea2a3dded9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onConnectivityChanged)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has detected a change in the connectivity state of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">newState</td><td>The new connectivity state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8a885ea2551982fff371bb7cc973675e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDataAvailable)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device, such as the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a>. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca8357ec5742ef6d4049a2233f8e19a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDeviceStateChanged)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a device's state has changed (ie config mode, measurement mode, recording mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 in some cases. </td></tr>
    <tr><td class="paramname">newState</td><td>The new device state </td></tr>
    <tr><td class="paramname">oldState</td><td>The old device state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga833ea7b93e5b738e22b8ba572a06b8cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onError)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an error has occurred while handling incoming data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">error</td><td>The error code that specifies exactly what problem occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaacc5e6f11e0d31c9be1ba9d7c6a1d892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onInfoResponse)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an information request has resulted in a response. </p>
<p>When the information request has completed, the data can be retrieved through the usual functions. Ie. when a requestBatteryLevel() resulted in an onInfoResponse(.., XIR_BatteryLevel), the <a class="el" href="struct_xs_device.html#ad9a5dd4a13161a69e4927191a7295cd3" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">XsDevice::batteryLevel</a> function will return the received battery level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">request</td><td>The type of request that was completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97563380f7297f58f2e3323b698feef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageReceivedFromDevice)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a valid message (after parsing) is received from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad33d298036ba7621e0bddf8b51ccdb63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageSentToDevice)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a message is sent to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that will receive the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0fe0a8618b800d5b3fb010b1f12747b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMissedPackets)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA detects that packets have been missed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device. </td></tr>
    <tr><td class="paramname">count</td><td>The number of samples that were missed </td></tr>
    <tr><td class="paramname">first</td><td>The sample counter / packet identifier of the first missed sample </td></tr>
    <tr><td class="paramname">last</td><td>The sample counter / packet identifier of the last missed sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d20b1bf629eb3c261c3ccaa9718fd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onNonDataMessage)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a non data, non reply message has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga390b75d6831b352dba4e5d9d0fb16c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onProgressUpdated)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device. </td></tr>
    <tr><td class="paramname">current</td><td>The current progress. </td></tr>
    <tr><td class="paramname">total</td><td>The total work to be done. When <em>current</em> equals <em>total</em>, the task is completed. </td></tr>
    <tr><td class="paramname">identifier</td><td>An identifier for the task. This may for example be a filename for file read operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6ebc107cb25d2f5634e851a2fcf7dde6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onWakeupReceived)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac0f265234224a0c3e2f56f73dfadc848"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* XsCallbackPlainC::m_onWriteDataToLogFile)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has a data packet that could be written to a log file. </p>
<dl class="section return"><dt>Returns</dt><dd>0 to prevent the message from being written, non-0 to allow the write. This applies only to data packets, not to other messages. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>onWriteMessageToLogFile </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device, such as the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a>. </td></tr>
    <tr><td class="paramname">data</td><td>The data that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1de6ee9c01f30e0d77b6c5a62df6a3d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* XsCallbackPlainC::m_onWriteMessageToLogFile)(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has a message that could be written to a log file. </p>
<dl class="section return"><dt>Returns</dt><dd>0 to prevent the message from being written, non-0 to allow the write. This includes data packets. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___callbacks.html#gac0f265234224a0c3e2f56f73dfadc848" title="Called when XDA has a data packet that could be written to a log file.">m_onWriteDataToLogFile</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 when the callback originates from a non-device, such as the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a>. </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Thu Jan 16 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
