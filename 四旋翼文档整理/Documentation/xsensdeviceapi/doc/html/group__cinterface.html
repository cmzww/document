<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>C Interface</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">C Interface</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae8321d23871bd495a735cccbac26b451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8321d23871bd495a735cccbac26b451"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae8321d23871bd495a735cccbac26b451">XS_BID_MASTER</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:gae8321d23871bd495a735cccbac26b451"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus identifier of the master device. <br/></td></tr>
<tr class="separator:gae8321d23871bd495a735cccbac26b451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cefb784042cbd1494268a2735c095f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga44cefb784042cbd1494268a2735c095f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga44cefb784042cbd1494268a2735c095f">XS_BID_BROADCAST</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga44cefb784042cbd1494268a2735c095f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus broadcast bus identifier (all devices) <br/></td></tr>
<tr class="separator:ga44cefb784042cbd1494268a2735c095f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9478ee24f1f927f712dd4ad6caa7bc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9478ee24f1f927f712dd4ad6caa7bc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab9478ee24f1f927f712dd4ad6caa7bc7">XS_BID_MT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:gab9478ee24f1f927f712dd4ad6caa7bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus identifier for the first MT on the bus. <br/></td></tr>
<tr class="separator:gab9478ee24f1f927f712dd4ad6caa7bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccb6071d965b3115cf7e696e70b0292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ccb6071d965b3115cf7e696e70b0292"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5ccb6071d965b3115cf7e696e70b0292">XS_BID_INVALID</a>&#160;&#160;&#160;0xFE</td></tr>
<tr class="memdesc:ga5ccb6071d965b3115cf7e696e70b0292"><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid bus identifier. <br/></td></tr>
<tr class="separator:ga5ccb6071d965b3115cf7e696e70b0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5c9e4b694fa198168f177ddb6f749f54"><td class="memItemLeft" align="right" valign="top">typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a></td></tr>
<tr class="separator:ga5c9e4b694fa198168f177ddb6f749f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1db0cf1b8591c59afba7a3a0d13eb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee1db0cf1b8591c59afba7a3a0d13eb9"></a>
typedef __off64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a></td></tr>
<tr class="memdesc:gaee1db0cf1b8591c59afba7a3a0d13eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that is used for positioning inside a file. <br/></td></tr>
<tr class="separator:gaee1db0cf1b8591c59afba7a3a0d13eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8caac814a4ee656f1774ad23ccc5f16e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8caac814a4ee656f1774ad23ccc5f16e"></a>
typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8caac814a4ee656f1774ad23ccc5f16e">XsIoHandle</a></td></tr>
<tr class="memdesc:ga8caac814a4ee656f1774ad23ccc5f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that is used for low-level identification of an open I/O device. <br/></td></tr>
<tr class="separator:ga8caac814a4ee656f1774ad23ccc5f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e67937a1394ad0c13d4d8f6b6f1d67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74e67937a1394ad0c13d4d8f6b6f1d67"></a>
typedef FILE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga74e67937a1394ad0c13d4d8f6b6f1d67">XsFileHandle</a></td></tr>
<tr class="memdesc:ga74e67937a1394ad0c13d4d8f6b6f1d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type that is used for low-level identification of an open file. <br/></td></tr>
<tr class="separator:ga74e67937a1394ad0c13d4d8f6b6f1d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga54600eb4ab8da7bbfc16f0d754feda33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54600eb4ab8da7bbfc16f0d754feda33"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga54600eb4ab8da7bbfc16f0d754feda33">XsConnectivityState_toString</a> (<a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> s)</td></tr>
<tr class="memdesc:ga54600eb4ab8da7bbfc16f0d754feda33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the device state to a human readable string. <br/></td></tr>
<tr class="separator:ga54600eb4ab8da7bbfc16f0d754feda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe6f7da6b5a9518d003857427b0d9ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3fe6f7da6b5a9518d003857427b0d9ac">XsDeviceMode_setModeFlag</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a> flag, int enabled)</td></tr>
<tr class="memdesc:ga3fe6f7da6b5a9518d003857427b0d9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear a <em>flag</em> of the output mode.  <a href="#ga3fe6f7da6b5a9518d003857427b0d9ac"></a><br/></td></tr>
<tr class="separator:ga3fe6f7da6b5a9518d003857427b0d9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cb97f31b66f487ef57e8b8df6ba247"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga44cb97f31b66f487ef57e8b8df6ba247">XsDeviceMode_isModeFlagEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a> flag)</td></tr>
<tr class="memdesc:ga44cb97f31b66f487ef57e8b8df6ba247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the state of the output mode <em>flag</em>.  <a href="#ga44cb97f31b66f487ef57e8b8df6ba247"></a><br/></td></tr>
<tr class="separator:ga44cb97f31b66f487ef57e8b8df6ba247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d6a4e1c6b3d5e7d569928623b399b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga61d6a4e1c6b3d5e7d569928623b399b9">XsDeviceMode_setSettingsFlag</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a> flag, int enabled)</td></tr>
<tr class="memdesc:ga61d6a4e1c6b3d5e7d569928623b399b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear a <em>flag</em> of the output settings.  <a href="#ga61d6a4e1c6b3d5e7d569928623b399b9"></a><br/></td></tr>
<tr class="separator:ga61d6a4e1c6b3d5e7d569928623b399b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6889b176bd9961209213bbecc064eca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab6889b176bd9961209213bbecc064eca">XsDeviceMode_isSettingsFlagEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a> flag)</td></tr>
<tr class="memdesc:gab6889b176bd9961209213bbecc064eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the state of the output settings <em>flag</em>.  <a href="#gab6889b176bd9961209213bbecc064eca"></a><br/></td></tr>
<tr class="separator:gab6889b176bd9961209213bbecc064eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3be05747aa4927396987a285a5a1a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadf3be05747aa4927396987a285a5a1a4">XsDeviceMode_sampleRate</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:gadf3be05747aa4927396987a285a5a1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample rate in Hz.  <a href="#gadf3be05747aa4927396987a285a5a1a4"></a><br/></td></tr>
<tr class="separator:gadf3be05747aa4927396987a285a5a1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537b419910590a3b6feb961ed20bc3d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga537b419910590a3b6feb961ed20bc3d8">XsDeviceMode_setUpdateRate</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int rate)</td></tr>
<tr class="memdesc:ga537b419910590a3b6feb961ed20bc3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the update rate to the given <em>rate</em>.  <a href="#ga537b419910590a3b6feb961ed20bc3d8"></a><br/></td></tr>
<tr class="separator:ga537b419910590a3b6feb961ed20bc3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e15a2624cfb7a42b0e1618b28a85236"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8e15a2624cfb7a42b0e1618b28a85236">XsDeviceMode_updateRate</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga8e15a2624cfb7a42b0e1618b28a85236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the update rate in Hz.  <a href="#ga8e15a2624cfb7a42b0e1618b28a85236"></a><br/></td></tr>
<tr class="separator:ga8e15a2624cfb7a42b0e1618b28a85236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1334e81ca26f55a89f4a5035ee199f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaca1334e81ca26f55a89f4a5035ee199f">XsDeviceMode_setOrientationMode</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#ga126d8e6e843bb9ec4b39dff76fd20dd5">XsOrientationMode</a> mode)</td></tr>
<tr class="memdesc:gaca1334e81ca26f55a89f4a5035ee199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set orientation output mode to <em>mode</em>.  <a href="#gaca1334e81ca26f55a89f4a5035ee199f"></a><br/></td></tr>
<tr class="separator:gaca1334e81ca26f55a89f4a5035ee199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72837d79b36d66d6f2196ae640c1bb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga126d8e6e843bb9ec4b39dff76fd20dd5">XsOrientationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga72837d79b36d66d6f2196ae640c1bb27">XsDeviceMode_orientationMode</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga72837d79b36d66d6f2196ae640c1bb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current orientation mode.  <a href="#ga72837d79b36d66d6f2196ae640c1bb27"></a><br/></td></tr>
<tr class="separator:ga72837d79b36d66d6f2196ae640c1bb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b832e7869732f349b2721afb19ebfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga96b832e7869732f349b2721afb19ebfd">XsDeviceMode_setDataFormat</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#gab069ea83c5534c084605d00747f02d3a">XsFloatFormat</a> ff)</td></tr>
<tr class="memdesc:ga96b832e7869732f349b2721afb19ebfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data format for floating point output.  <a href="#ga96b832e7869732f349b2721afb19ebfd"></a><br/></td></tr>
<tr class="separator:ga96b832e7869732f349b2721afb19ebfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b955d9f3394e47f737a0ba79c7d270e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#gab069ea83c5534c084605d00747f02d3a">XsFloatFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9b955d9f3394e47f737a0ba79c7d270e">XsDeviceMode_dataFormat</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga9b955d9f3394e47f737a0ba79c7d270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current floating point data format.  <a href="#ga9b955d9f3394e47f737a0ba79c7d270e"></a><br/></td></tr>
<tr class="separator:ga9b955d9f3394e47f737a0ba79c7d270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5bafbbed5153cace100d4efa1d51d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad5bafbbed5153cace100d4efa1d51d4e">XsDeviceMode_setCalibratedDataMode</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#gaf6d3ba49156a12dc63190c1bb9f01d28">XsCalibratedDataMode</a> mode)</td></tr>
<tr class="memdesc:gad5bafbbed5153cace100d4efa1d51d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the calibrated data mode to <em>mode</em>.  <a href="#gad5bafbbed5153cace100d4efa1d51d4e"></a><br/></td></tr>
<tr class="separator:gad5bafbbed5153cace100d4efa1d51d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc33a6257bdef8c1b94af98a9e4a687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#gaf6d3ba49156a12dc63190c1bb9f01d28">XsCalibratedDataMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7fc33a6257bdef8c1b94af98a9e4a687">XsDeviceMode_calibratedDataMode</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga7fc33a6257bdef8c1b94af98a9e4a687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the calibrated data mode.  <a href="#ga7fc33a6257bdef8c1b94af98a9e4a687"></a><br/></td></tr>
<tr class="separator:ga7fc33a6257bdef8c1b94af98a9e4a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20205fd7f6f611e1db2500df65902f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa20205fd7f6f611e1db2500df65902f0">XsDeviceMode_setAnalogInChannelEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int channelIndex, int enabled)</td></tr>
<tr class="memdesc:gaa20205fd7f6f611e1db2500df65902f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable an analog in channel.  <a href="#gaa20205fd7f6f611e1db2500df65902f0"></a><br/></td></tr>
<tr class="separator:gaa20205fd7f6f611e1db2500df65902f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a28dbcf2dfb21d591113941da2581e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga34a28dbcf2dfb21d591113941da2581e">XsDeviceMode_isAnalogInChannelEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int channelIndex)</td></tr>
<tr class="memdesc:ga34a28dbcf2dfb21d591113941da2581e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the analog in channel at <em>channelIndex</em> is enabled.  <a href="#ga34a28dbcf2dfb21d591113941da2581e"></a><br/></td></tr>
<tr class="separator:ga34a28dbcf2dfb21d591113941da2581e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768c534735515f8afc53010e0061e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga768c534735515f8afc53010e0061e21d">XsDeviceMode_setCoordinateSystem</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, <a class="el" href="group__enums.html#gab70862c87211b0172b995e269bb9f6b4">XsCoordinateSystem</a> coordinatesystem)</td></tr>
<tr class="memdesc:ga768c534735515f8afc53010e0061e21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate system used for calibrated and orientation output.  <a href="#ga768c534735515f8afc53010e0061e21d"></a><br/></td></tr>
<tr class="separator:ga768c534735515f8afc53010e0061e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe19019f785c9ec88688e55baf5f1a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#gab70862c87211b0172b995e269bb9f6b4">XsCoordinateSystem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafe19019f785c9ec88688e55baf5f1a50">XsDeviceMode_coordinateSystem</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:gafe19019f785c9ec88688e55baf5f1a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current used coordinate system.  <a href="#gafe19019f785c9ec88688e55baf5f1a50"></a><br/></td></tr>
<tr class="separator:gafe19019f785c9ec88688e55baf5f1a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26b2fa0de33a7e7933d358522aa8b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac26b2fa0de33a7e7933d358522aa8b8f">XsDeviceMode_setStatusOutputEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int enabled)</td></tr>
<tr class="memdesc:gac26b2fa0de33a7e7933d358522aa8b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the status output.  <a href="#gac26b2fa0de33a7e7933d358522aa8b8f"></a><br/></td></tr>
<tr class="separator:gac26b2fa0de33a7e7933d358522aa8b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37d63e8636a3b76b2bfe1dac69d6c89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab37d63e8636a3b76b2bfe1dac69d6c89">XsDeviceMode_isStatusOutputEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:gab37d63e8636a3b76b2bfe1dac69d6c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status of the status output.  <a href="#gab37d63e8636a3b76b2bfe1dac69d6c89"></a><br/></td></tr>
<tr class="separator:gab37d63e8636a3b76b2bfe1dac69d6c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56affb47cccafee34c80765b13208f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab56affb47cccafee34c80765b13208f4">XsDeviceMode_setTemperatureOutputEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int enabled)</td></tr>
<tr class="memdesc:gab56affb47cccafee34c80765b13208f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the temperature output.  <a href="#gab56affb47cccafee34c80765b13208f4"></a><br/></td></tr>
<tr class="separator:gab56affb47cccafee34c80765b13208f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366c1e61891fe32b343494a6bda15243"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga366c1e61891fe32b343494a6bda15243">XsDeviceMode_isTemperatureOutputEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga366c1e61891fe32b343494a6bda15243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status of the temperature output.  <a href="#ga366c1e61891fe32b343494a6bda15243"></a><br/></td></tr>
<tr class="separator:ga366c1e61891fe32b343494a6bda15243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918a42711bce561497949b17115b6165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga918a42711bce561497949b17115b6165">XsDeviceMode_setPositionDataEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int enabled)</td></tr>
<tr class="memdesc:ga918a42711bce561497949b17115b6165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the position output.  <a href="#ga918a42711bce561497949b17115b6165"></a><br/></td></tr>
<tr class="separator:ga918a42711bce561497949b17115b6165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7dcd4bd7715ab85e194607a1f1d1df3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab7dcd4bd7715ab85e194607a1f1d1df3">XsDeviceMode_isPositionDataEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:gab7dcd4bd7715ab85e194607a1f1d1df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status of the position output.  <a href="#gab7dcd4bd7715ab85e194607a1f1d1df3"></a><br/></td></tr>
<tr class="separator:gab7dcd4bd7715ab85e194607a1f1d1df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3735b2de3243bfb2b9596b3752c2e34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac3735b2de3243bfb2b9596b3752c2e34">XsDeviceMode_setVelocityDataEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int enabled)</td></tr>
<tr class="memdesc:gac3735b2de3243bfb2b9596b3752c2e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the velocity output.  <a href="#gac3735b2de3243bfb2b9596b3752c2e34"></a><br/></td></tr>
<tr class="separator:gac3735b2de3243bfb2b9596b3752c2e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b15b3c9c80ca1bbecd974fc701f500"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga58b15b3c9c80ca1bbecd974fc701f500">XsDeviceMode_isVelocityDataEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga58b15b3c9c80ca1bbecd974fc701f500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status of the velocity output.  <a href="#ga58b15b3c9c80ca1bbecd974fc701f500"></a><br/></td></tr>
<tr class="separator:ga58b15b3c9c80ca1bbecd974fc701f500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd697df5979cf11be18d79796cba2367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd697df5979cf11be18d79796cba2367">XsDeviceMode_setGpsPvtDataEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int enabled)</td></tr>
<tr class="memdesc:gafd697df5979cf11be18d79796cba2367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the gps pvt data output.  <a href="#gafd697df5979cf11be18d79796cba2367"></a><br/></td></tr>
<tr class="separator:gafd697df5979cf11be18d79796cba2367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58eb093cba0b229fa7253aef5123d268"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga58eb093cba0b229fa7253aef5123d268">XsDeviceMode_isGpsPvtDataEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga58eb093cba0b229fa7253aef5123d268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status of the gps pvt data output.  <a href="#ga58eb093cba0b229fa7253aef5123d268"></a><br/></td></tr>
<tr class="separator:ga58eb093cba0b229fa7253aef5123d268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a40e52a8a1cc26cd984548f457b660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac7a40e52a8a1cc26cd984548f457b660">XsDeviceMode_setRawDataOutputEnabled</a> (struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, int enabled)</td></tr>
<tr class="memdesc:gac7a40e52a8a1cc26cd984548f457b660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the raw data output.  <a href="#gac7a40e52a8a1cc26cd984548f457b660"></a><br/></td></tr>
<tr class="separator:gac7a40e52a8a1cc26cd984548f457b660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8361e349507f84cb3ddd242c6f384b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0e8361e349507f84cb3ddd242c6f384b">XsDeviceMode_isRawDataOutputEnabled</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:ga0e8361e349507f84cb3ddd242c6f384b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current status of the raw data output.  <a href="#ga0e8361e349507f84cb3ddd242c6f384b"></a><br/></td></tr>
<tr class="separator:ga0e8361e349507f84cb3ddd242c6f384b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7bf1d30f92fb298ed50943ea353b519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab7bf1d30f92fb298ed50943ea353b519">XsDeviceMode_toXsDeviceMode</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, struct <a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *modeR)</td></tr>
<tr class="memdesc:gab7bf1d30f92fb298ed50943ea353b519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device mode as a <a class="el" href="struct_xs_device_mode_r.html" title="A structure for storing device modes.">XsDeviceModeR</a> object.  <a href="#gab7bf1d30f92fb298ed50943ea353b519"></a><br/></td></tr>
<tr class="separator:gab7bf1d30f92fb298ed50943ea353b519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89291a18b727abb67e7fa7c9518abffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga89291a18b727abb67e7fa7c9518abffd">XsDeviceMode_toXsDeviceMode2</a> (const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *, struct <a class="el" href="struct_xs_device_mode_p_s.html">XsDeviceModePS</a> *modePS)</td></tr>
<tr class="memdesc:ga89291a18b727abb67e7fa7c9518abffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device mode as a <a class="el" href="struct_xs_device_mode_p_s.html" title="Stores device modes using period and skip factor.">XsDeviceModePS</a> object.  <a href="#ga89291a18b727abb67e7fa7c9518abffd"></a><br/></td></tr>
<tr class="separator:ga89291a18b727abb67e7fa7c9518abffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27bd555d485be3f9700ee77f3ffe9ac3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga27bd555d485be3f9700ee77f3ffe9ac3">XsDeviceModePS_updateRate</a> (const <a class="el" href="struct_xs_device_mode_p_s.html">XsDeviceModePS</a> *)</td></tr>
<tr class="memdesc:ga27bd555d485be3f9700ee77f3ffe9ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the update rate in Hz.  <a href="#ga27bd555d485be3f9700ee77f3ffe9ac3"></a><br/></td></tr>
<tr class="separator:ga27bd555d485be3f9700ee77f3ffe9ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9019e771ca7f5073451e2bad03a2b05d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9019e771ca7f5073451e2bad03a2b05d">XsDeviceModePS_setUpdateRate</a> (<a class="el" href="struct_xs_device_mode_p_s.html">XsDeviceModePS</a> *, int rate)</td></tr>
<tr class="memdesc:ga9019e771ca7f5073451e2bad03a2b05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the period and skip factor from an update rate and store them.  <a href="#ga9019e771ca7f5073451e2bad03a2b05d"></a><br/></td></tr>
<tr class="separator:ga9019e771ca7f5073451e2bad03a2b05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8c8aa5ec38f3397aae21b52b05e184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7c8c8aa5ec38f3397aae21b52b05e184">XsDeviceModeR_getPeriodAndSkipFactor</a> (const <a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *, uint16_t *period, uint16_t *skip)</td></tr>
<tr class="memdesc:ga7c8c8aa5ec38f3397aae21b52b05e184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the period and skip factor from the stored update rate.  <a href="#ga7c8c8aa5ec38f3397aae21b52b05e184"></a><br/></td></tr>
<tr class="separator:ga7c8c8aa5ec38f3397aae21b52b05e184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb33bd6a79065e3b87dd7b6cf294ef2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeeb33bd6a79065e3b87dd7b6cf294ef2">XsDeviceModeR_updateRate</a> (const <a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *)</td></tr>
<tr class="memdesc:gaeeb33bd6a79065e3b87dd7b6cf294ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real update rate in Hz.  <a href="#gaeeb33bd6a79065e3b87dd7b6cf294ef2"></a><br/></td></tr>
<tr class="separator:gaeeb33bd6a79065e3b87dd7b6cf294ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6812853d996fa61c9d7bbf3df0999390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6812853d996fa61c9d7bbf3df0999390">XsDeviceModeR_setPeriodAndSkipFactor</a> (<a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *, uint16_t period, uint16_t skip)</td></tr>
<tr class="memdesc:ga6812853d996fa61c9d7bbf3df0999390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the update rate from a period and skip factor.  <a href="#ga6812853d996fa61c9d7bbf3df0999390"></a><br/></td></tr>
<tr class="separator:ga6812853d996fa61c9d7bbf3df0999390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c06fbb59a2cba2335021036e27f067a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c06fbb59a2cba2335021036e27f067a"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2c06fbb59a2cba2335021036e27f067a">XsDeviceState_toString</a> (<a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> s)</td></tr>
<tr class="memdesc:ga2c06fbb59a2cba2335021036e27f067a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the device state to a human readable string. <br/></td></tr>
<tr class="separator:ga2c06fbb59a2cba2335021036e27f067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0d2a6dd76dda6f997d2365557a711b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a0d2a6dd76dda6f997d2365557a711b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8a0d2a6dd76dda6f997d2365557a711b">XsFilterProfile_toString</a> (<a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *out)</td></tr>
<tr class="memdesc:ga8a0d2a6dd76dda6f997d2365557a711b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts filter profile version and type information to string. <br/></td></tr>
<tr class="separator:ga8a0d2a6dd76dda6f997d2365557a711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40cbadc927588c9501eee5aaf4411c83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40cbadc927588c9501eee5aaf4411c83"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga40cbadc927588c9501eee5aaf4411c83">XsFilterProfile_empty</a> (<a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *)</td></tr>
<tr class="memdesc:ga40cbadc927588c9501eee5aaf4411c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the filter profile is empty. <br/></td></tr>
<tr class="separator:ga40cbadc927588c9501eee5aaf4411c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28ceabe2bcbb9744fe8dcf5a651df3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae28ceabe2bcbb9744fe8dcf5a651df3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae28ceabe2bcbb9744fe8dcf5a651df3e">XsFilterProfile_swap</a> (<a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *a, <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *b)</td></tr>
<tr class="memdesc:gae28ceabe2bcbb9744fe8dcf5a651df3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with <em>b</em>. <br/></td></tr>
<tr class="separator:gae28ceabe2bcbb9744fe8dcf5a651df3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4c55f739fde1df5aa2ccba48163313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b4c55f739fde1df5aa2ccba48163313"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6b4c55f739fde1df5aa2ccba48163313">XsRejectReason_toString</a> (<a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a> r)</td></tr>
<tr class="memdesc:ga6b4c55f739fde1df5aa2ccba48163313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the XsRejectReason to a human readable string. <br/></td></tr>
<tr class="separator:ga6b4c55f739fde1df5aa2ccba48163313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd2d9017d98760bd77cc7f8cdcf3dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabcd2d9017d98760bd77cc7f8cdcf3dff">XsUsbHubInfo_construct</a> (<a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *, <a class="el" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a> hub)</td></tr>
<tr class="memdesc:gabcd2d9017d98760bd77cc7f8cdcf3dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the XsUsbHubInfo with <em>hub</em>.  <a href="#gabcd2d9017d98760bd77cc7f8cdcf3dff"></a><br/></td></tr>
<tr class="separator:gabcd2d9017d98760bd77cc7f8cdcf3dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19eb9e1412205a548ecc54171bb2d707"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19eb9e1412205a548ecc54171bb2d707"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga19eb9e1412205a548ecc54171bb2d707">XsUsbHubInfo_destruct</a> (<a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *)</td></tr>
<tr class="memdesc:ga19eb9e1412205a548ecc54171bb2d707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the XsUsbHubInfo. <br/></td></tr>
<tr class="separator:ga19eb9e1412205a548ecc54171bb2d707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166f34f636ae6c30b3741ee0af30e027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga166f34f636ae6c30b3741ee0af30e027">XsUsbHubInfo_assign</a> (<a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *, <a class="el" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a> hub)</td></tr>
<tr class="memdesc:ga166f34f636ae6c30b3741ee0af30e027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new hub identifier to the XsUsbHubInfo.  <a href="#ga166f34f636ae6c30b3741ee0af30e027"></a><br/></td></tr>
<tr class="separator:ga166f34f636ae6c30b3741ee0af30e027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cda0534d7a45d878eb47f9a45b646c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5cda0534d7a45d878eb47f9a45b646c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5cda0534d7a45d878eb47f9a45b646c3">XsUsbHubInfo_copy</a> (<a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *copy, <a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> const *src)</td></tr>
<tr class="memdesc:ga5cda0534d7a45d878eb47f9a45b646c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsUsbHubInfo to <em>copy</em>. <br/></td></tr>
<tr class="separator:ga5cda0534d7a45d878eb47f9a45b646c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4afa7b8e3fe092f4e9c02b58808ff66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4afa7b8e3fe092f4e9c02b58808ff66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4afa7b8e3fe092f4e9c02b58808ff66">XsUsbHubInfo_swap</a> (<a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *, <a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *thatPtr)</td></tr>
<tr class="memdesc:gad4afa7b8e3fe092f4e9c02b58808ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the two XsUsbHubInfo items. <br/></td></tr>
<tr class="separator:gad4afa7b8e3fe092f4e9c02b58808ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2070c99d652844fdd3ce5216a7e33e75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2070c99d652844fdd3ce5216a7e33e75">XsUsbHubInfo_parentPathMatches</a> (const <a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *left, const <a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *right)</td></tr>
<tr class="memdesc:ga2070c99d652844fdd3ce5216a7e33e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the two hub info objects share the same device path.  <a href="#ga2070c99d652844fdd3ce5216a7e33e75"></a><br/></td></tr>
<tr class="separator:ga2070c99d652844fdd3ce5216a7e33e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f37496127474291e93fe41ed74f6f90"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0f37496127474291e93fe41ed74f6f90">XsControl_construct</a> (void)</td></tr>
<tr class="memdesc:ga0f37496127474291e93fe41ed74f6f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562" title="Construct a new XsControl* object. Clean it up with the destruct() function.">construct()</a> function instead.  </p>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed object </dd></dl>
 <a href="#ga0f37496127474291e93fe41ed74f6f90"></a><br/></td></tr>
<tr class="separator:ga0f37496127474291e93fe41ed74f6f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82cab815f07878eea0ee015ab3cfc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa82cab815f07878eea0ee015ab3cfc2f">XsControl_destruct</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:gaa82cab815f07878eea0ee015ab3cfc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, calls <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function to clean up object.   <a href="#gaa82cab815f07878eea0ee015ab3cfc2f"></a><br/></td></tr>
<tr class="separator:gaa82cab815f07878eea0ee015ab3cfc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac515d81784d4766fae9b28408fd578da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac515d81784d4766fae9b28408fd578da">XsControl_setSerialKey</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *key)</td></tr>
<tr class="memdesc:gac515d81784d4766fae9b28408fd578da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the serial key for XDA.   <a href="#gac515d81784d4766fae9b28408fd578da"></a><br/></td></tr>
<tr class="separator:gac515d81784d4766fae9b28408fd578da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c530bdcde7bb04b51582adf32f83041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3c530bdcde7bb04b51582adf32f83041">XsControl_flushInputBuffers</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, int complete)</td></tr>
<tr class="memdesc:ga3c530bdcde7bb04b51582adf32f83041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of all devices.   <a href="#ga3c530bdcde7bb04b51582adf32f83041"></a><br/></td></tr>
<tr class="separator:ga3c530bdcde7bb04b51582adf32f83041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8de07228c9e10a3d39424e0d14d46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadb8de07228c9e10a3d39424e0d14d46a">XsControl_version</a> (<a class="el" href="struct_xs_version.html">XsVersion</a> *)</td></tr>
<tr class="memdesc:gadb8de07228c9e10a3d39424e0d14d46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version of the XDA dll.   <a href="#gadb8de07228c9e10a3d39424e0d14d46a"></a><br/></td></tr>
<tr class="separator:gadb8de07228c9e10a3d39424e0d14d46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c18a03a34542a1dbaad6b1f7b742cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga46c18a03a34542a1dbaad6b1f7b742cc">XsControl_libraryPath</a> (<a class="el" href="struct_xs_string.html">XsString</a> *)</td></tr>
<tr class="memdesc:ga46c18a03a34542a1dbaad6b1f7b742cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical path of the XDA dll.   <a href="#ga46c18a03a34542a1dbaad6b1f7b742cc"></a><br/></td></tr>
<tr class="separator:ga46c18a03a34542a1dbaad6b1f7b742cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1ba2248bf3a249efec855f347b0c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4e1ba2248bf3a249efec855f347b0c0f">XsControl_resultText</a> (<a class="el" href="struct_xs_string.html">XsString</a> *, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> resultCode)</td></tr>
<tr class="memdesc:ga4e1ba2248bf3a249efec855f347b0c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptive text for the given <em>resultCode</em>.   <a href="#ga4e1ba2248bf3a249efec855f347b0c0f"></a><br/></td></tr>
<tr class="separator:ga4e1ba2248bf3a249efec855f347b0c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga887727f3d0444cb0a1d13fbb5ec4ef8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga887727f3d0444cb0a1d13fbb5ec4ef8f">XsControl_setLogPath</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *path)</td></tr>
<tr class="memdesc:ga887727f3d0444cb0a1d13fbb5ec4ef8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path where the xda.log file will be written.   <a href="#ga887727f3d0444cb0a1d13fbb5ec4ef8f"></a><br/></td></tr>
<tr class="separator:ga887727f3d0444cb0a1d13fbb5ec4ef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb06e76b5652fa33fcc228272bda3cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabb06e76b5652fa33fcc228272bda3cea">XsControl_close</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:gabb06e76b5652fa33fcc228272bda3cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all ports and files.   <a href="#gabb06e76b5652fa33fcc228272bda3cea"></a><br/></td></tr>
<tr class="separator:gabb06e76b5652fa33fcc228272bda3cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb2f9f95c5afdf5475f8a95ec7e67c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3cb2f9f95c5afdf5475f8a95ec7e67c5">XsControl_openPort</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *portname, XsBaudRate baudrate, uint32_t timeout, int detectRs485)</td></tr>
<tr class="memdesc:ga3cb2f9f95c5afdf5475f8a95ec7e67c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel on serial port with the given <em>portname</em>.   <a href="#ga3cb2f9f95c5afdf5475f8a95ec7e67c5"></a><br/></td></tr>
<tr class="separator:ga3cb2f9f95c5afdf5475f8a95ec7e67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dbe57ee850e68adf99cb35b99642365"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8dbe57ee850e68adf99cb35b99642365">XsControl_openPort_1</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *portinfo, uint32_t timeout)</td></tr>
<tr class="memdesc:ga8dbe57ee850e68adf99cb35b99642365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel using the details in the supplied XsPortInfo structure.   <a href="#ga8dbe57ee850e68adf99cb35b99642365"></a><br/></td></tr>
<tr class="separator:ga8dbe57ee850e68adf99cb35b99642365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a39a0608c4e7ab990c20175a251e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac5a39a0608c4e7ab990c20175a251e90">XsControl_closePort</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *portname)</td></tr>
<tr class="memdesc:gac5a39a0608c4e7ab990c20175a251e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portname</em>.   <a href="#gac5a39a0608c4e7ab990c20175a251e90"></a><br/></td></tr>
<tr class="separator:gac5a39a0608c4e7ab990c20175a251e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8246b014d3a477396c9dd512d97f3f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8246b014d3a477396c9dd512d97f3f96">XsControl_closePort_1</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:ga8246b014d3a477396c9dd512d97f3f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the port that is used for communication with the given <em>deviceId</em>.   <a href="#ga8246b014d3a477396c9dd512d97f3f96"></a><br/></td></tr>
<tr class="separator:ga8246b014d3a477396c9dd512d97f3f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874056753461eefd2ddd27573ff13627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga874056753461eefd2ddd27573ff13627">XsControl_closePort_2</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *portinfo)</td></tr>
<tr class="memdesc:ga874056753461eefd2ddd27573ff13627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port that matches <em>portinfo</em>.   <a href="#ga874056753461eefd2ddd27573ff13627"></a><br/></td></tr>
<tr class="separator:ga874056753461eefd2ddd27573ff13627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd07bde97cfa351d370c75e007bb2f41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd07bde97cfa351d370c75e007bb2f41">XsControl_openPort_2</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, int portNr, XsBaudRate baudrate, uint32_t timeout, int detectRs485)</td></tr>
<tr class="memdesc:gafd07bde97cfa351d370c75e007bb2f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel to the given COM <em>portNr</em>.   <a href="#gafd07bde97cfa351d370c75e007bb2f41"></a><br/></td></tr>
<tr class="separator:gafd07bde97cfa351d370c75e007bb2f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e3e638e8535296d9ed8477eb0061fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga58e3e638e8535296d9ed8477eb0061fa">XsControl_closePort_3</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, int portNr)</td></tr>
<tr class="memdesc:ga58e3e638e8535296d9ed8477eb0061fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portNr</em>.   <a href="#ga58e3e638e8535296d9ed8477eb0061fa"></a><br/></td></tr>
<tr class="separator:ga58e3e638e8535296d9ed8477eb0061fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0b69aa2989f11d785cda4c57d1db19b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf0b69aa2989f11d785cda4c57d1db19b">XsControl_openLogFile</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *filename)</td></tr>
<tr class="memdesc:gaf0b69aa2989f11d785cda4c57d1db19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the log file with the given <em>filename</em>.   <a href="#gaf0b69aa2989f11d785cda4c57d1db19b"></a><br/></td></tr>
<tr class="separator:gaf0b69aa2989f11d785cda4c57d1db19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dc73a16aa0c92698429b0631a8eb88a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8dc73a16aa0c92698429b0631a8eb88a">XsControl_lastResult</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:ga8dc73a16aa0c92698429b0631a8eb88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.   <a href="#ga8dc73a16aa0c92698429b0631a8eb88a"></a><br/></td></tr>
<tr class="separator:ga8dc73a16aa0c92698429b0631a8eb88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a19c01f2f544d49e68b42fcc762a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga86a19c01f2f544d49e68b42fcc762a53">XsControl_lastResultText</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *)</td></tr>
<tr class="memdesc:ga86a19c01f2f544d49e68b42fcc762a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text for the value returned by <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a>   <a href="#ga86a19c01f2f544d49e68b42fcc762a53"></a><br/></td></tr>
<tr class="separator:ga86a19c01f2f544d49e68b42fcc762a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78e04c47668197a0b72509fc2a1489b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac78e04c47668197a0b72509fc2a1489b">XsControl_deviceCount</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:gac78e04c47668197a0b72509fc2a1489b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected devices.   <a href="#gac78e04c47668197a0b72509fc2a1489b"></a><br/></td></tr>
<tr class="separator:gac78e04c47668197a0b72509fc2a1489b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1436bec551ee6c4da1f6aedf878cc60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae1436bec551ee6c4da1f6aedf878cc60">XsControl_mainDeviceCount</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:gae1436bec551ee6c4da1f6aedf878cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of main devices.   <a href="#gae1436bec551ee6c4da1f6aedf878cc60"></a><br/></td></tr>
<tr class="separator:gae1436bec551ee6c4da1f6aedf878cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714d1eb9ee25fc259089a6ed46c223a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga714d1eb9ee25fc259089a6ed46c223a4">XsControl_mainDeviceIds</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *)</td></tr>
<tr class="memdesc:ga714d1eb9ee25fc259089a6ed46c223a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available main devices.   <a href="#ga714d1eb9ee25fc259089a6ed46c223a4"></a><br/></td></tr>
<tr class="separator:ga714d1eb9ee25fc259089a6ed46c223a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d8e1378c41638421fece79b8cb6fe1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga44d8e1378c41638421fece79b8cb6fe1">XsControl_mtCount</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:ga44d8e1378c41638421fece79b8cb6fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected MTs.   <a href="#ga44d8e1378c41638421fece79b8cb6fe1"></a><br/></td></tr>
<tr class="separator:ga44d8e1378c41638421fece79b8cb6fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebcb70851f14af84e3e089e0bd3971d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadebcb70851f14af84e3e089e0bd3971d">XsControl_mtDeviceIds</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *)</td></tr>
<tr class="memdesc:gadebcb70851f14af84e3e089e0bd3971d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available MTs.   <a href="#gadebcb70851f14af84e3e089e0bd3971d"></a><br/></td></tr>
<tr class="separator:gadebcb70851f14af84e3e089e0bd3971d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273d552a680f46e47601aa42f8450a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga273d552a680f46e47601aa42f8450a3b">XsControl_deviceIds</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *)</td></tr>
<tr class="memdesc:ga273d552a680f46e47601aa42f8450a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of all the connected devices.   <a href="#ga273d552a680f46e47601aa42f8450a3b"></a><br/></td></tr>
<tr class="separator:ga273d552a680f46e47601aa42f8450a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf16d3145d1c12f52ad8f57b32bc09f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8bf16d3145d1c12f52ad8f57b32bc09f">XsControl_getDeviceIdFromLocationId</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *, uint16_t locationId)</td></tr>
<tr class="memdesc:ga8bf16d3145d1c12f52ad8f57b32bc09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of the device on the given <em>locationId</em>.   <a href="#ga8bf16d3145d1c12f52ad8f57b32bc09f"></a><br/></td></tr>
<tr class="separator:ga8bf16d3145d1c12f52ad8f57b32bc09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2b4d9be6860077f2d86248b0e656ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c2b4d9be6860077f2d86248b0e656ea">XsControl_dockDeviceId</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:ga6c2b4d9be6860077f2d86248b0e656ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of the dock device for the given <em>deviceId</em>.   <a href="#ga6c2b4d9be6860077f2d86248b0e656ea"></a><br/></td></tr>
<tr class="separator:ga6c2b4d9be6860077f2d86248b0e656ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931f28451900dcf98c9fab8e2737140a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga931f28451900dcf98c9fab8e2737140a">XsControl_isDeviceWireless</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:ga931f28451900dcf98c9fab8e2737140a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected.   <a href="#ga931f28451900dcf98c9fab8e2737140a"></a><br/></td></tr>
<tr class="separator:ga931f28451900dcf98c9fab8e2737140a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e578eff35444c48a8917f849ad109e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac8e578eff35444c48a8917f849ad109e">XsControl_isDeviceDocked</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:gac8e578eff35444c48a8917f849ad109e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is an MTw and whether it is docked (or USB connected).   <a href="#gac8e578eff35444c48a8917f849ad109e"></a><br/></td></tr>
<tr class="separator:gac8e578eff35444c48a8917f849ad109e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3445b3e8a8723b5ac00a993a35b4cece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3445b3e8a8723b5ac00a993a35b4cece">XsControl_setQueueMode</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> mode)</td></tr>
<tr class="memdesc:ga3445b3e8a8723b5ac00a993a35b4cece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the queue mode to the given <em>mode</em>.   <a href="#ga3445b3e8a8723b5ac00a993a35b4cece"></a><br/></td></tr>
<tr class="separator:ga3445b3e8a8723b5ac00a993a35b4cece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5451d380cfac67e0cf16ab11105383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeb5451d380cfac67e0cf16ab11105383">XsControl_queueMode</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:gaeb5451d380cfac67e0cf16ab11105383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently used queue mode.   <a href="#gaeb5451d380cfac67e0cf16ab11105383"></a><br/></td></tr>
<tr class="separator:gaeb5451d380cfac67e0cf16ab11105383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96a0a258612316c96df5796ef8f8f4d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga96a0a258612316c96df5796ef8f8f4d5">XsControl_loadFilterProfiles</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *filename)</td></tr>
<tr class="memdesc:ga96a0a258612316c96df5796ef8f8f4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load filter profile definitions from a settings file with the given <em>filename</em>.   <a href="#ga96a0a258612316c96df5796ef8f8f4d5"></a><br/></td></tr>
<tr class="separator:ga96a0a258612316c96df5796ef8f8f4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787f79e2cabf59cd1fe1ecdec7558b0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga787f79e2cabf59cd1fe1ecdec7558b0c">XsControl_setOptionEnabled</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option, int enabled)</td></tr>
<tr class="memdesc:ga787f79e2cabf59cd1fe1ecdec7558b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristently enable or disable an option.   <a href="#ga787f79e2cabf59cd1fe1ecdec7558b0c"></a><br/></td></tr>
<tr class="separator:ga787f79e2cabf59cd1fe1ecdec7558b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa16988955f61cb3034eef77395633ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafa16988955f61cb3034eef77395633ab">XsControl_isOptionEnabled</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option)</td></tr>
<tr class="memdesc:gafa16988955f61cb3034eef77395633ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an option is persistently enabled or not.   <a href="#gafa16988955f61cb3034eef77395633ab"></a><br/></td></tr>
<tr class="separator:gafa16988955f61cb3034eef77395633ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab148a4920630560c88437a9a4681d095"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab148a4920630560c88437a9a4681d095">XsControl_setLatLonAlt</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *lla)</td></tr>
<tr class="memdesc:gab148a4920630560c88437a9a4681d095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current GPS position of the system.   <a href="#gab148a4920630560c88437a9a4681d095"></a><br/></td></tr>
<tr class="separator:gab148a4920630560c88437a9a4681d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec511d6fa250e76c13a531fc338f0caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaec511d6fa250e76c13a531fc338f0caf">XsControl_device</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:gaec511d6fa250e76c13a531fc338f0caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface object associated with the supplied <em>deviceId</em>.   <a href="#gaec511d6fa250e76c13a531fc338f0caf"></a><br/></td></tr>
<tr class="separator:gaec511d6fa250e76c13a531fc338f0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9ce27149a78fffa7c08a7a1fae28b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6d9ce27149a78fffa7c08a7a1fae28b3">XsControl_mainDevices</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *)</td></tr>
<tr class="memdesc:ga6d9ce27149a78fffa7c08a7a1fae28b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface objects.   <a href="#ga6d9ce27149a78fffa7c08a7a1fae28b3"></a><br/></td></tr>
<tr class="separator:ga6d9ce27149a78fffa7c08a7a1fae28b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fab73e2eae146da77c45a460724665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab7fab73e2eae146da77c45a460724665">XsControl_broadcast</a> (const struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:gab7fab73e2eae146da77c45a460724665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the broadcast device.   <a href="#gab7fab73e2eae146da77c45a460724665"></a><br/></td></tr>
<tr class="separator:gab7fab73e2eae146da77c45a460724665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga453f95a4e626964cf7dfe07382cd999d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga453f95a4e626964cf7dfe07382cd999d">XsControl_testSynchronization</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *)</td></tr>
<tr class="memdesc:ga453f95a4e626964cf7dfe07382cd999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connected main devices are hardware-synchronized.   <a href="#ga453f95a4e626964cf7dfe07382cd999d"></a><br/></td></tr>
<tr class="separator:ga453f95a4e626964cf7dfe07382cd999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a57b82050cc78d2bc5db3e4a45274a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1a57b82050cc78d2bc5db3e4a45274a6">XsControl_clearCallbackHandlers</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, int chain)</td></tr>
<tr class="memdesc:ga1a57b82050cc78d2bc5db3e4a45274a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.   <a href="#ga1a57b82050cc78d2bc5db3e4a45274a6"></a><br/></td></tr>
<tr class="separator:ga1a57b82050cc78d2bc5db3e4a45274a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e96881405fc87c270bfbfa2711c792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad1e96881405fc87c270bfbfa2711c792">XsControl_addCallbackHandler</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, int chain)</td></tr>
<tr class="memdesc:gad1e96881405fc87c270bfbfa2711c792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.   <a href="#gad1e96881405fc87c270bfbfa2711c792"></a><br/></td></tr>
<tr class="separator:gad1e96881405fc87c270bfbfa2711c792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e5c759c2b7cbb45903247352df7dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga91e5c759c2b7cbb45903247352df7dcc">XsControl_removeCallbackHandler</a> (struct <a class="el" href="struct_xs_control.html">XsControl</a> *, <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, int chain)</td></tr>
<tr class="memdesc:ga91e5c759c2b7cbb45903247352df7dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.   <a href="#ga91e5c759c2b7cbb45903247352df7dcc"></a><br/></td></tr>
<tr class="separator:ga91e5c759c2b7cbb45903247352df7dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9c166eaf7e215910c714799231c8a7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2b9c166eaf7e215910c714799231c8a7">XsDataBundler_construct</a> (void)</td></tr>
<tr class="memdesc:ga2b9c166eaf7e215910c714799231c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df" title="Construct a new XsDataBundler* object. Clean it up with the destruct() function.">construct()</a> function instead.  </p>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed object </dd></dl>
 <a href="#ga2b9c166eaf7e215910c714799231c8a7"></a><br/></td></tr>
<tr class="separator:ga2b9c166eaf7e215910c714799231c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07506012a5a75030035294cc5174817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa07506012a5a75030035294cc5174817">XsDataBundler_destruct</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *)</td></tr>
<tr class="memdesc:gaa07506012a5a75030035294cc5174817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, calls <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function to clean up object.   <a href="#gaa07506012a5a75030035294cc5174817"></a><br/></td></tr>
<tr class="separator:gaa07506012a5a75030035294cc5174817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06e9fff4c115fbbcce75054c7d56f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac06e9fff4c115fbbcce75054c7d56f50">XsDataBundler_clearCallbackHandlers</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, int chain)</td></tr>
<tr class="memdesc:gac06e9fff4c115fbbcce75054c7d56f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.   <a href="#gac06e9fff4c115fbbcce75054c7d56f50"></a><br/></td></tr>
<tr class="separator:gac06e9fff4c115fbbcce75054c7d56f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f1a79f00a7df41b7afdbf35b38b0d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4f1a79f00a7df41b7afdbf35b38b0d8b">XsDataBundler_addCallbackHandler</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, int chain)</td></tr>
<tr class="memdesc:ga4f1a79f00a7df41b7afdbf35b38b0d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.   <a href="#ga4f1a79f00a7df41b7afdbf35b38b0d8b"></a><br/></td></tr>
<tr class="separator:ga4f1a79f00a7df41b7afdbf35b38b0d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca92809c6e9a88abd9ae0ed8bd74ecda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaca92809c6e9a88abd9ae0ed8bd74ecda">XsDataBundler_removeCallbackHandler</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, int chain)</td></tr>
<tr class="memdesc:gaca92809c6e9a88abd9ae0ed8bd74ecda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.   <a href="#gaca92809c6e9a88abd9ae0ed8bd74ecda"></a><br/></td></tr>
<tr class="separator:gaca92809c6e9a88abd9ae0ed8bd74ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e98663a9c12c541d1c7d8626cd6766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad5e98663a9c12c541d1c7d8626cd6766">XsDataBundler_toCallbackPlainC</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *)</td></tr>
<tr class="memdesc:gad5e98663a9c12c541d1c7d8626cd6766"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#gad5e98663a9c12c541d1c7d8626cd6766"></a><br/></td></tr>
<tr class="separator:gad5e98663a9c12c541d1c7d8626cd6766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff02b87fac9fb758346fb7cd84d7f67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0ff02b87fac9fb758346fb7cd84d7f67">XsDataBundler_addDevice</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, const <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga0ff02b87fac9fb758346fb7cd84d7f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device to expect data from.   <a href="#ga0ff02b87fac9fb758346fb7cd84d7f67"></a><br/></td></tr>
<tr class="separator:ga0ff02b87fac9fb758346fb7cd84d7f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecb79e7d7b9d1a9b919194b4509cd76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9ecb79e7d7b9d1a9b919194b4509cd76">XsDataBundler_removeDevice</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, const <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9ecb79e7d7b9d1a9b919194b4509cd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device to expect data from.   <a href="#ga9ecb79e7d7b9d1a9b919194b4509cd76"></a><br/></td></tr>
<tr class="separator:ga9ecb79e7d7b9d1a9b919194b4509cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0f211beb25ec471f3be91d44f8a9ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2f0f211beb25ec471f3be91d44f8a9ba">XsDataBundler_packet</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceId)</td></tr>
<tr class="memdesc:ga2f0f211beb25ec471f3be91d44f8a9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> sent by a specific device from the current full bundle for which a callback is currently called.   <a href="#ga2f0f211beb25ec471f3be91d44f8a9ba"></a><br/></td></tr>
<tr class="separator:ga2f0f211beb25ec471f3be91d44f8a9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4caf535333470f8ec444a2a6c86924e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4caf535333470f8ec444a2a6c86924e9">XsDataBundler_at</a> (struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *, unsigned idx)</td></tr>
<tr class="memdesc:ga4caf535333470f8ec444a2a6c86924e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> at a specified index in the current full bundle for which a callback is currently called.   <a href="#ga4caf535333470f8ec444a2a6c86924e9"></a><br/></td></tr>
<tr class="separator:ga4caf535333470f8ec444a2a6c86924e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef507ea67a16b837ee41d9a94d91a8d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafef507ea67a16b837ee41d9a94d91a8d">XsDataBundler_count</a> (const struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *)</td></tr>
<tr class="memdesc:gafef507ea67a16b837ee41d9a94d91a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data packets in the current full bundle for which a callback is currently called.   <a href="#gafef507ea67a16b837ee41d9a94d91a8d"></a><br/></td></tr>
<tr class="separator:gafef507ea67a16b837ee41d9a94d91a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425c92339b79c1426cc69f86109a209a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga425c92339b79c1426cc69f86109a209a">XsDevice_addRef</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga425c92339b79c1426cc69f86109a209a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase reference count of <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer stay alive while reference counter is not zero Also increases the reference count of each child device with 1.   <a href="#ga425c92339b79c1426cc69f86109a209a"></a><br/></td></tr>
<tr class="separator:ga425c92339b79c1426cc69f86109a209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga237ac924a24a256b0fb54ae14286cf3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga237ac924a24a256b0fb54ae14286cf3e">XsDevice_removeRef</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga237ac924a24a256b0fb54ae14286cf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1.   <a href="#ga237ac924a24a256b0fb54ae14286cf3e"></a><br/></td></tr>
<tr class="separator:ga237ac924a24a256b0fb54ae14286cf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a3729ce4e995ccc0f9ecf751cdb89a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga85a3729ce4e995ccc0f9ecf751cdb89a">XsDevice_refCounter</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga85a3729ce4e995ccc0f9ecf751cdb89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current reference counter.   <a href="#ga85a3729ce4e995ccc0f9ecf751cdb89a"></a><br/></td></tr>
<tr class="separator:ga85a3729ce4e995ccc0f9ecf751cdb89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115250037637279b60ec456fb7d6017f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga115250037637279b60ec456fb7d6017f">XsDevice_master</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga115250037637279b60ec456fb7d6017f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the master device of this device.   <a href="#ga115250037637279b60ec456fb7d6017f"></a><br/></td></tr>
<tr class="separator:ga115250037637279b60ec456fb7d6017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad725f8ef14d1bccf9d5206eab09247dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad725f8ef14d1bccf9d5206eab09247dc">XsDevice_children</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *)</td></tr>
<tr class="memdesc:gad725f8ef14d1bccf9d5206eab09247dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child devices of this device.   <a href="#gad725f8ef14d1bccf9d5206eab09247dc"></a><br/></td></tr>
<tr class="separator:gad725f8ef14d1bccf9d5206eab09247dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a51517b9d0dba36d079111d920bfdcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9a51517b9d0dba36d079111d920bfdcb">XsDevice_findDevice</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceid)</td></tr>
<tr class="memdesc:ga9a51517b9d0dba36d079111d920bfdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the child device with <em>deviceid</em>.   <a href="#ga9a51517b9d0dba36d079111d920bfdcb"></a><br/></td></tr>
<tr class="separator:ga9a51517b9d0dba36d079111d920bfdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae6cf0ed7f8961f135405e433f24673"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafae6cf0ed7f8961f135405e433f24673">XsDevice_busId</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gafae6cf0ed7f8961f135405e433f24673"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus ID for this device.   <a href="#gafae6cf0ed7f8961f135405e433f24673"></a><br/></td></tr>
<tr class="separator:gafae6cf0ed7f8961f135405e433f24673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaa7176a241b9c18bf9ac080a0675e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeeaa7176a241b9c18bf9ac080a0675e9">XsDevice_deviceId</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaeeaa7176a241b9c18bf9ac080a0675e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device ID of the device.   <a href="#gaeeaa7176a241b9c18bf9ac080a0675e9"></a><br/></td></tr>
<tr class="separator:gaeeaa7176a241b9c18bf9ac080a0675e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752fe10bd8c2330f115bbb846b80a084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga752fe10bd8c2330f115bbb846b80a084">XsDevice_firmwareVersion</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_version.html">XsVersion</a> *)</td></tr>
<tr class="memdesc:ga752fe10bd8c2330f115bbb846b80a084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the firmware version.   <a href="#ga752fe10bd8c2330f115bbb846b80a084"></a><br/></td></tr>
<tr class="separator:ga752fe10bd8c2330f115bbb846b80a084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74c67a2851082d707abc1703d3eb3fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab74c67a2851082d707abc1703d3eb3fa">XsDevice_isMasterDevice</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gab74c67a2851082d707abc1703d3eb3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is the master device (not a child of another device)   <a href="#gab74c67a2851082d707abc1703d3eb3fa"></a><br/></td></tr>
<tr class="separator:gab74c67a2851082d707abc1703d3eb3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2888024c9ec677ddbd73e681254bc6b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2888024c9ec677ddbd73e681254bc6b0">XsDevice_isInitialized</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga2888024c9ec677ddbd73e681254bc6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the device is initialized.   <a href="#ga2888024c9ec677ddbd73e681254bc6b0"></a><br/></td></tr>
<tr class="separator:ga2888024c9ec677ddbd73e681254bc6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892b23a533a48f8b997e91318cea31df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga892b23a533a48f8b997e91318cea31df">XsDevice_deviceAtBusId</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int busid)</td></tr>
<tr class="memdesc:ga892b23a533a48f8b997e91318cea31df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.   <a href="#ga892b23a533a48f8b997e91318cea31df"></a><br/></td></tr>
<tr class="separator:ga892b23a533a48f8b997e91318cea31df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedab581c1f3b2f91bb9943f248fd4cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaedab581c1f3b2f91bb9943f248fd4cf6">XsDevice_deviceAtBusId_1</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int busid)</td></tr>
<tr class="memdesc:gaedab581c1f3b2f91bb9943f248fd4cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.   <a href="#gaedab581c1f3b2f91bb9943f248fd4cf6"></a><br/></td></tr>
<tr class="separator:gaedab581c1f3b2f91bb9943f248fd4cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fe597420621e768f13ca9e5a5cd001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga86fe597420621e768f13ca9e5a5cd001">XsDevice_setGotoConfigOnClose</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int gotoConfigOnClose)</td></tr>
<tr class="memdesc:ga86fe597420621e768f13ca9e5a5cd001"><td class="mdescLeft">&#160;</td><td class="mdescRight">On closePort the device will go to config by default, with this function it is possible to prevent that.   <a href="#ga86fe597420621e768f13ca9e5a5cd001"></a><br/></td></tr>
<tr class="separator:ga86fe597420621e768f13ca9e5a5cd001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83bcbcc58ae663664a5c5f7ab8660099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga83bcbcc58ae663664a5c5f7ab8660099">XsDevice_createLogFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *filename)</td></tr>
<tr class="memdesc:ga83bcbcc58ae663664a5c5f7ab8660099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a log file for logging.   <a href="#ga83bcbcc58ae663664a5c5f7ab8660099"></a><br/></td></tr>
<tr class="separator:ga83bcbcc58ae663664a5c5f7ab8660099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2dc8165edebc1a24a9994359b9dabb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf2dc8165edebc1a24a9994359b9dabb5">XsDevice_closeLogFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gaf2dc8165edebc1a24a9994359b9dabb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.   <a href="#gaf2dc8165edebc1a24a9994359b9dabb5"></a><br/></td></tr>
<tr class="separator:gaf2dc8165edebc1a24a9994359b9dabb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e18679976d487a4ec0bcb019cbaa67f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0e18679976d487a4ec0bcb019cbaa67f">XsDevice_isMeasuring</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga0e18679976d487a4ec0bcb019cbaa67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a measuring state.   <a href="#ga0e18679976d487a4ec0bcb019cbaa67f"></a><br/></td></tr>
<tr class="separator:ga0e18679976d487a4ec0bcb019cbaa67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc4626713a8d46822d1c84acd9229f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7fc4626713a8d46822d1c84acd9229f4">XsDevice_isRecording</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga7fc4626713a8d46822d1c84acd9229f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a recording state.   <a href="#ga7fc4626713a8d46822d1c84acd9229f4"></a><br/></td></tr>
<tr class="separator:ga7fc4626713a8d46822d1c84acd9229f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8a2f97ab635be446b14de3d31292eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7e8a2f97ab635be446b14de3d31292eb">XsDevice_isReadingFromFile</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga7e8a2f97ab635be446b14de3d31292eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is reading from a file.   <a href="#ga7e8a2f97ab635be446b14de3d31292eb"></a><br/></td></tr>
<tr class="separator:ga7e8a2f97ab635be446b14de3d31292eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc88a0e3e0e90ca2b0cfc18c7593ce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaedc88a0e3e0e90ca2b0cfc18c7593ce5">XsDevice_restartFilter</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gaedc88a0e3e0e90ca2b0cfc18c7593ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">restart the filter used by this device   <a href="#gaedc88a0e3e0e90ca2b0cfc18c7593ce5"></a><br/></td></tr>
<tr class="separator:gaedc88a0e3e0e90ca2b0cfc18c7593ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93eba46bc4d58a3d0c80d183fc2081a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae93eba46bc4d58a3d0c80d183fc2081a">XsDevice_queueLength</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gae93eba46bc4d58a3d0c80d183fc2081a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently in the cache for the device.   <a href="#gae93eba46bc4d58a3d0c80d183fc2081a"></a><br/></td></tr>
<tr class="separator:gae93eba46bc4d58a3d0c80d183fc2081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa59d6b0eda3ef324247fe98fece1e2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa59d6b0eda3ef324247fe98fece1e2cd">XsDevice_deviceState</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gaa59d6b0eda3ef324247fe98fece1e2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of this device.   <a href="#gaa59d6b0eda3ef324247fe98fece1e2cd"></a><br/></td></tr>
<tr class="separator:gaa59d6b0eda3ef324247fe98fece1e2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfd3b8e038c3fe9a75c4ea73057ecd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4cfd3b8e038c3fe9a75c4ea73057ecd6">XsDevice_nextAvailableDataPacket</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga4cfd3b8e038c3fe9a75c4ea73057ecd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next data packet in the live stream.   <a href="#ga4cfd3b8e038c3fe9a75c4ea73057ecd6"></a><br/></td></tr>
<tr class="separator:ga4cfd3b8e038c3fe9a75c4ea73057ecd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fa8643cae1be3a80a278ca91e5650af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8fa8643cae1be3a80a278ca91e5650af">XsDevice_dataPacketByIndex</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t index)</td></tr>
<tr class="memdesc:ga8fa8643cae1be3a80a278ca91e5650af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <em>index'th</em> data packet for the device.   <a href="#ga8fa8643cae1be3a80a278ca91e5650af"></a><br/></td></tr>
<tr class="separator:ga8fa8643cae1be3a80a278ca91e5650af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104505acf91e117647ef5b3897501545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga104505acf91e117647ef5b3897501545">XsDevice_dataPacketById</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint64_t packetId)</td></tr>
<tr class="memdesc:ga104505acf91e117647ef5b3897501545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a data packet for the device with the supplied <em>packetId</em>.   <a href="#ga104505acf91e117647ef5b3897501545"></a><br/></td></tr>
<tr class="separator:ga104505acf91e117647ef5b3897501545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276ae344a1491db450443c8b54f37949"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga276ae344a1491db450443c8b54f37949">XsDevice_clearCallbackHandlers</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int chain)</td></tr>
<tr class="memdesc:ga276ae344a1491db450443c8b54f37949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.   <a href="#ga276ae344a1491db450443c8b54f37949"></a><br/></td></tr>
<tr class="separator:ga276ae344a1491db450443c8b54f37949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7854ff15bf1a2e484a4341ba5d0b2e2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7854ff15bf1a2e484a4341ba5d0b2e2b">XsDevice_addCallbackHandler</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, int chain)</td></tr>
<tr class="memdesc:ga7854ff15bf1a2e484a4341ba5d0b2e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.   <a href="#ga7854ff15bf1a2e484a4341ba5d0b2e2b"></a><br/></td></tr>
<tr class="separator:ga7854ff15bf1a2e484a4341ba5d0b2e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5628642c3b68a4e20399da909fb0882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae5628642c3b68a4e20399da909fb0882">XsDevice_removeCallbackHandler</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, int chain)</td></tr>
<tr class="memdesc:gae5628642c3b68a4e20399da909fb0882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.   <a href="#gae5628642c3b68a4e20399da909fb0882"></a><br/></td></tr>
<tr class="separator:gae5628642c3b68a4e20399da909fb0882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b4e1b34a4696a6929a48c4e45533a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga98b4e1b34a4696a6929a48c4e45533a6">XsDevice_deviceConfiguration</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *)</td></tr>
<tr class="memdesc:ga98b4e1b34a4696a6929a48c4e45533a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device configuration.   <a href="#ga98b4e1b34a4696a6929a48c4e45533a6"></a><br/></td></tr>
<tr class="separator:ga98b4e1b34a4696a6929a48c4e45533a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c17451847c5216daba5d4f0a8ef374f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c17451847c5216daba5d4f0a8ef374f">XsDevice_clear</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga8c17451847c5216daba5d4f0a8ef374f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all fields, possibly removing stuff like filters and calibration info.   <a href="#ga8c17451847c5216daba5d4f0a8ef374f"></a><br/></td></tr>
<tr class="separator:ga8c17451847c5216daba5d4f0a8ef374f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d53adcaeb193459fdef6a6e7f57f19b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3d53adcaeb193459fdef6a6e7f57f19b">XsDevice_batteryLevel</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga3d53adcaeb193459fdef6a6e7f57f19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication.   <a href="#ga3d53adcaeb193459fdef6a6e7f57f19b"></a><br/></td></tr>
<tr class="separator:ga3d53adcaeb193459fdef6a6e7f57f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99b2c6e0df6904201fdcc1e7041a610"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad99b2c6e0df6904201fdcc1e7041a610">XsDevice_updateRateForDataIdentifier</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType)</td></tr>
<tr class="memdesc:gad99b2c6e0df6904201fdcc1e7041a610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.   <a href="#gad99b2c6e0df6904201fdcc1e7041a610"></a><br/></td></tr>
<tr class="separator:gad99b2c6e0df6904201fdcc1e7041a610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0256554521df8a45fce8788045f1dfd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0256554521df8a45fce8788045f1dfd0">XsDevice_updateRateForProcessedDataIdentifier</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType)</td></tr>
<tr class="memdesc:ga0256554521df8a45fce8788045f1dfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.   <a href="#ga0256554521df8a45fce8788045f1dfd0"></a><br/></td></tr>
<tr class="separator:ga0256554521df8a45fce8788045f1dfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c4eee95b954077a08ba711445391e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_int_array.html">XsIntArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa4c4eee95b954077a08ba711445391e0">XsDevice_supportedUpdateRates</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_int_array.html">XsIntArray</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType)</td></tr>
<tr class="memdesc:gaa4c4eee95b954077a08ba711445391e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the device for its supported update rates for the given <em>dataType</em>.   <a href="#gaa4c4eee95b954077a08ba711445391e0"></a><br/></td></tr>
<tr class="separator:gaa4c4eee95b954077a08ba711445391e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6d065d058d93d15f4dcc3fca27ead7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4d6d065d058d93d15f4dcc3fca27ead7">XsDevice_maximumUpdateRate</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga4d6d065d058d93d15f4dcc3fca27ead7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum update rate for the device.   <a href="#ga4d6d065d058d93d15f4dcc3fca27ead7"></a><br/></td></tr>
<tr class="separator:ga4d6d065d058d93d15f4dcc3fca27ead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b0b026fe4120e8bb37482d940aafc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga32b0b026fe4120e8bb37482d940aafc6">XsDevice_hasDataEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType)</td></tr>
<tr class="memdesc:ga32b0b026fe4120e8bb37482d940aafc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em>.   <a href="#ga32b0b026fe4120e8bb37482d940aafc6"></a><br/></td></tr>
<tr class="separator:ga32b0b026fe4120e8bb37482d940aafc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf588f5257803e28cd1ebe99c99f6bc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacf588f5257803e28cd1ebe99c99f6bc1">XsDevice_hasProcessedDataEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType)</td></tr>
<tr class="memdesc:gacf588f5257803e28cd1ebe99c99f6bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em> after processing on the host.   <a href="#gacf588f5257803e28cd1ebe99c99f6bc1"></a><br/></td></tr>
<tr class="separator:gacf588f5257803e28cd1ebe99c99f6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6353605129f7e35d1c052e182e7cc77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6353605129f7e35d1c052e182e7cc77b">XsDevice_productCode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *)</td></tr>
<tr class="memdesc:ga6353605129f7e35d1c052e182e7cc77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product code of the device.   <a href="#ga6353605129f7e35d1c052e182e7cc77b"></a><br/></td></tr>
<tr class="separator:ga6353605129f7e35d1c052e182e7cc77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d320267f604321c745822d8896e222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga49d320267f604321c745822d8896e222">XsDevice_portName</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *)</td></tr>
<tr class="memdesc:ga49d320267f604321c745822d8896e222"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port name of the connection.   <a href="#ga49d320267f604321c745822d8896e222"></a><br/></td></tr>
<tr class="separator:ga49d320267f604321c745822d8896e222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a5d0bb1f29b5aa3a156327afca6071"><td class="memItemLeft" align="right" valign="top">XsBaudRate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3a5d0bb1f29b5aa3a156327afca6071">XsDevice_baudRate</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, XsBaudRate *)</td></tr>
<tr class="memdesc:gaf3a5d0bb1f29b5aa3a156327afca6071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected.   <a href="#gaf3a5d0bb1f29b5aa3a156327afca6071"></a><br/></td></tr>
<tr class="separator:gaf3a5d0bb1f29b5aa3a156327afca6071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69feb6c87e988db55fe3817fe42a9db9"><td class="memItemLeft" align="right" valign="top">XsBaudRate *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga69feb6c87e988db55fe3817fe42a9db9">XsDevice_serialBaudRate</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, XsBaudRate *)</td></tr>
<tr class="memdesc:ga69feb6c87e988db55fe3817fe42a9db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The baud rate configured for cabled connection.   <a href="#ga69feb6c87e988db55fe3817fe42a9db9"></a><br/></td></tr>
<tr class="separator:ga69feb6c87e988db55fe3817fe42a9db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf36b035e5ddddb9c7f570a3cc9b348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadaf36b035e5ddddb9c7f570a3cc9b348">XsDevice_hardwareVersion</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_version.html">XsVersion</a> *)</td></tr>
<tr class="memdesc:gadaf36b035e5ddddb9c7f570a3cc9b348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hardware version of the device.   <a href="#gadaf36b035e5ddddb9c7f570a3cc9b348"></a><br/></td></tr>
<tr class="separator:gadaf36b035e5ddddb9c7f570a3cc9b348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2014d2c4c0f043a590e4a9c537c94b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5c2014d2c4c0f043a590e4a9c537c94b">XsDevice_portNumber</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga5c2014d2c4c0f043a590e4a9c537c94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the port number of the connection.   <a href="#ga5c2014d2c4c0f043a590e4a9c537c94b"></a><br/></td></tr>
<tr class="separator:ga5c2014d2c4c0f043a590e4a9c537c94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe89a20af07aaf119268ce2a2728204f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabe89a20af07aaf119268ce2a2728204f">XsDevice_startRecording</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gabe89a20af07aaf119268ce2a2728204f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording incoming data.   <a href="#gabe89a20af07aaf119268ce2a2728204f"></a><br/></td></tr>
<tr class="separator:gabe89a20af07aaf119268ce2a2728204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53894ab4b85fd020e48fdfb46049f21a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga53894ab4b85fd020e48fdfb46049f21a">XsDevice_stopRecording</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga53894ab4b85fd020e48fdfb46049f21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording incoming data.   <a href="#ga53894ab4b85fd020e48fdfb46049f21a"></a><br/></td></tr>
<tr class="separator:ga53894ab4b85fd020e48fdfb46049f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1861f21718630fc4e37f4bbbe86e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0d1861f21718630fc4e37f4bbbe86e84">XsDevice_setOptionEnabled</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option, int enabled)</td></tr>
<tr class="memdesc:ga0d1861f21718630fc4e37f4bbbe86e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a processing option.   <a href="#ga0d1861f21718630fc4e37f4bbbe86e84"></a><br/></td></tr>
<tr class="separator:ga0d1861f21718630fc4e37f4bbbe86e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c820010c978c684903e6a2d402eb3ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5c820010c978c684903e6a2d402eb3ce">XsDevice_isOptionEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option)</td></tr>
<tr class="memdesc:ga5c820010c978c684903e6a2d402eb3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a processing option is enabled or not.   <a href="#ga5c820010c978c684903e6a2d402eb3ce"></a><br/></td></tr>
<tr class="separator:ga5c820010c978c684903e6a2d402eb3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14503f0d88b547789f165f95ad87cd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf14503f0d88b547789f165f95ad87cd2">XsDevice_initializeFilter</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gaf14503f0d88b547789f165f95ad87cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the filter used by this device.   <a href="#gaf14503f0d88b547789f165f95ad87cd2"></a><br/></td></tr>
<tr class="separator:gaf14503f0d88b547789f165f95ad87cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3e43d391898ef292808326f2bd7cd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6d3e43d391898ef292808326f2bd7cd8">XsDevice_sendCustomMessage</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_message.html">XsMessage</a> *messageSend, int waitForResult, <a class="el" href="struct_xs_message.html">XsMessage</a> *messageReceive, int timeout)</td></tr>
<tr class="memdesc:ga6d3e43d391898ef292808326f2bd7cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a custom message <em>messageSend</em> to the device and possibly wait for a result.   <a href="#ga6d3e43d391898ef292808326f2bd7cd8"></a><br/></td></tr>
<tr class="separator:ga6d3e43d391898ef292808326f2bd7cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5634ddaba4cc5a16f6b474885a1b3a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab5634ddaba4cc5a16f6b474885a1b3a4">XsDevice_sendRawMessage</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gab5634ddaba4cc5a16f6b474885a1b3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message directly to the communicator.   <a href="#gab5634ddaba4cc5a16f6b474885a1b3a4"></a><br/></td></tr>
<tr class="separator:gab5634ddaba4cc5a16f6b474885a1b3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c96a310c0a3d2ab4df1d2983f9d2c40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7c96a310c0a3d2ab4df1d2983f9d2c40">XsDevice_setSerialBaudRate</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, XsBaudRate baudrate)</td></tr>
<tr class="memdesc:ga7c96a310c0a3d2ab4df1d2983f9d2c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the serial baudrate to <em>baudrate</em>.   <a href="#ga7c96a310c0a3d2ab4df1d2983f9d2c40"></a><br/></td></tr>
<tr class="separator:ga7c96a310c0a3d2ab4df1d2983f9d2c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ce8a92edf2e45874ce642a0ec21955"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab0ce8a92edf2e45874ce642a0ec21955">XsDevice_isMotionTracker</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gab0ce8a92edf2e45874ce642a0ec21955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a motion tracker.   <a href="#gab0ce8a92edf2e45874ce642a0ec21955"></a><br/></td></tr>
<tr class="separator:gab0ce8a92edf2e45874ce642a0ec21955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a778d52f507c0a9e0fcbd20cfaaeea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00a778d52f507c0a9e0fcbd20cfaaeea">XsDevice_outputMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga00a778d52f507c0a9e0fcbd20cfaaeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output mode.   <a href="#ga00a778d52f507c0a9e0fcbd20cfaaeea"></a><br/></td></tr>
<tr class="separator:ga00a778d52f507c0a9e0fcbd20cfaaeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c48b3146a7675ba240a6b0ad1b2a9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00c48b3146a7675ba240a6b0ad1b2a9f">XsDevice_setOutputMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a> mode)</td></tr>
<tr class="memdesc:ga00c48b3146a7675ba240a6b0ad1b2a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the outputmode for this device.   <a href="#ga00c48b3146a7675ba240a6b0ad1b2a9f"></a><br/></td></tr>
<tr class="separator:ga00c48b3146a7675ba240a6b0ad1b2a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad411e49744b4a2fb53b59b7a4616a240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad411e49744b4a2fb53b59b7a4616a240">XsDevice_outputSettings</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gad411e49744b4a2fb53b59b7a4616a240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output settings.   <a href="#gad411e49744b4a2fb53b59b7a4616a240"></a><br/></td></tr>
<tr class="separator:gad411e49744b4a2fb53b59b7a4616a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf24f6099e011cf5d51968ede3b5c806"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadf24f6099e011cf5d51968ede3b5c806">XsDevice_setOutputSettings</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a> outputsettings)</td></tr>
<tr class="memdesc:gadf24f6099e011cf5d51968ede3b5c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output settings for this device.   <a href="#gadf24f6099e011cf5d51968ede3b5c806"></a><br/></td></tr>
<tr class="separator:gadf24f6099e011cf5d51968ede3b5c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0e9bc213a1a0cf58e33628413184d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5b0e9bc213a1a0cf58e33628413184d4">XsDevice_updateRate</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga5b0e9bc213a1a0cf58e33628413184d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the legacy update rate of the device.   <a href="#ga5b0e9bc213a1a0cf58e33628413184d4"></a><br/></td></tr>
<tr class="separator:ga5b0e9bc213a1a0cf58e33628413184d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770d9a6979879556c83dec1f93d899e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga770d9a6979879556c83dec1f93d899e3">XsDevice_setUpdateRate</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int rate)</td></tr>
<tr class="memdesc:ga770d9a6979879556c83dec1f93d899e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the legacy update rate of the device.   <a href="#ga770d9a6979879556c83dec1f93d899e3"></a><br/></td></tr>
<tr class="separator:ga770d9a6979879556c83dec1f93d899e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b4da552d60f0e5ad0975065615e6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga52b4da552d60f0e5ad0975065615e6eb">XsDevice_outputConfiguration</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *)</td></tr>
<tr class="memdesc:ga52b4da552d60f0e5ad0975065615e6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured output of the device.   <a href="#ga52b4da552d60f0e5ad0975065615e6eb"></a><br/></td></tr>
<tr class="separator:ga52b4da552d60f0e5ad0975065615e6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13abf7bef0fad2e4e3b2a9fa5f3828a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac13abf7bef0fad2e4e3b2a9fa5f3828a">XsDevice_processedOutputConfiguration</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *)</td></tr>
<tr class="memdesc:gac13abf7bef0fad2e4e3b2a9fa5f3828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full output configuration including post processing outputs.   <a href="#gac13abf7bef0fad2e4e3b2a9fa5f3828a"></a><br/></td></tr>
<tr class="separator:gac13abf7bef0fad2e4e3b2a9fa5f3828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f9cab62ad8270a3da396432469dfa7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga89f9cab62ad8270a3da396432469dfa7">XsDevice_setOutputConfiguration</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *config)</td></tr>
<tr class="memdesc:ga89f9cab62ad8270a3da396432469dfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output configuration for this device When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.   <a href="#ga89f9cab62ad8270a3da396432469dfa7"></a><br/></td></tr>
<tr class="separator:ga89f9cab62ad8270a3da396432469dfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35fea1d072eeae5938ac04023e964e48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga35fea1d072eeae5938ac04023e964e48">XsDevice_isInLegacyMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga35fea1d072eeae5938ac04023e964e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device is outputting data in legacy mode.   <a href="#ga35fea1d072eeae5938ac04023e964e48"></a><br/></td></tr>
<tr class="separator:ga35fea1d072eeae5938ac04023e964e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb4f5d5d1e47b12df7b1d846e00439b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1cb4f5d5d1e47b12df7b1d846e00439b">XsDevice_isInStringOutputMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga1cb4f5d5d1e47b12df7b1d846e00439b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device is outputting data in string mode.   <a href="#ga1cb4f5d5d1e47b12df7b1d846e00439b"></a><br/></td></tr>
<tr class="separator:ga1cb4f5d5d1e47b12df7b1d846e00439b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6718b4b462e2786ac3fe16313fade6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6718b4b462e2786ac3fe16313fade6d">XsDevice_usesLegacyDeviceMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gae6718b4b462e2786ac3fe16313fade6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the device uses legacy device mode.   <a href="#gae6718b4b462e2786ac3fe16313fade6d"></a><br/></td></tr>
<tr class="separator:gae6718b4b462e2786ac3fe16313fade6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c7446796090cdeb7ffab5582877f9a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55c7446796090cdeb7ffab5582877f9a">XsDevice_stringOutputType</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga55c7446796090cdeb7ffab5582877f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string output type.   <a href="#ga55c7446796090cdeb7ffab5582877f9a"></a><br/></td></tr>
<tr class="separator:ga55c7446796090cdeb7ffab5582877f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a07fbe9718701612851375103c7eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac9a07fbe9718701612851375103c7eef">XsDevice_setStringOutputType</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, uint16_t type)</td></tr>
<tr class="memdesc:gac9a07fbe9718701612851375103c7eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the string output type for this device.   <a href="#gac9a07fbe9718701612851375103c7eef"></a><br/></td></tr>
<tr class="separator:gac9a07fbe9718701612851375103c7eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b005dc85df40251142f7d33f188cb8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga48b005dc85df40251142f7d33f188cb8">XsDevice_samplePeriod</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga48b005dc85df40251142f7d33f188cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample period.   <a href="#ga48b005dc85df40251142f7d33f188cb8"></a><br/></td></tr>
<tr class="separator:ga48b005dc85df40251142f7d33f188cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f712d6dae335d193250b9a2b8422e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab5f712d6dae335d193250b9a2b8422e3">XsDevice_setSamplePeriod</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, uint16_t period)</td></tr>
<tr class="memdesc:gab5f712d6dae335d193250b9a2b8422e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample period for this device.   <a href="#gab5f712d6dae335d193250b9a2b8422e3"></a><br/></td></tr>
<tr class="separator:gab5f712d6dae335d193250b9a2b8422e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a047956060ff6d68743023b61b3292"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac4a047956060ff6d68743023b61b3292">XsDevice_outputSkipFactor</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gac4a047956060ff6d68743023b61b3292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output skip factor.   <a href="#gac4a047956060ff6d68743023b61b3292"></a><br/></td></tr>
<tr class="separator:gac4a047956060ff6d68743023b61b3292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9da9741cd6278d11f2d2bedee89e45b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf9da9741cd6278d11f2d2bedee89e45b">XsDevice_setOutputSkipFactor</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, uint16_t skipFactor)</td></tr>
<tr class="memdesc:gaf9da9741cd6278d11f2d2bedee89e45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output skip factor for this device.   <a href="#gaf9da9741cd6278d11f2d2bedee89e45b"></a><br/></td></tr>
<tr class="separator:gaf9da9741cd6278d11f2d2bedee89e45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad918781c339b0c3aad2de95bd4aefe48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad918781c339b0c3aad2de95bd4aefe48">XsDevice_deviceMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *)</td></tr>
<tr class="memdesc:gad918781c339b0c3aad2de95bd4aefe48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the legacy output configuration as an XsDeviceMode object.   <a href="#gad918781c339b0c3aad2de95bd4aefe48"></a><br/></td></tr>
<tr class="separator:gad918781c339b0c3aad2de95bd4aefe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4775d23ad08d8e4b5186b48314d26043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4775d23ad08d8e4b5186b48314d26043">XsDevice_setDeviceMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *mode)</td></tr>
<tr class="memdesc:ga4775d23ad08d8e4b5186b48314d26043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the legacy output configuration of the device.   <a href="#ga4775d23ad08d8e4b5186b48314d26043"></a><br/></td></tr>
<tr class="separator:ga4775d23ad08d8e4b5186b48314d26043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d5420a7f104687e7b350aabf3bf098"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae4d5420a7f104687e7b350aabf3bf098">XsDevice_dataLength</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gae4d5420a7f104687e7b350aabf3bf098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the data in the legacy MTData packets that the device will send in measurement mode.   <a href="#gae4d5420a7f104687e7b350aabf3bf098"></a><br/></td></tr>
<tr class="separator:gae4d5420a7f104687e7b350aabf3bf098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee314655b7f989dbba833e40c34a377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadee314655b7f989dbba833e40c34a377">XsDevice_clearCache</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gadee314655b7f989dbba833e40c34a377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the caches of this device.   <a href="#gadee314655b7f989dbba833e40c34a377"></a><br/></td></tr>
<tr class="separator:gadee314655b7f989dbba833e40c34a377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7516215631c6202fbba319998945434a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7516215631c6202fbba319998945434a">XsDevice_syncSettings</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *)</td></tr>
<tr class="memdesc:ga7516215631c6202fbba319998945434a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the current synchronization settings of the device.   <a href="#ga7516215631c6202fbba319998945434a"></a><br/></td></tr>
<tr class="separator:ga7516215631c6202fbba319998945434a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cad862a34f2363fbef1e0b8e751788b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5cad862a34f2363fbef1e0b8e751788b">XsDevice_setSyncSettings</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *settingList)</td></tr>
<tr class="memdesc:ga5cad862a34f2363fbef1e0b8e751788b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the synchronization settings of the device.   <a href="#ga5cad862a34f2363fbef1e0b8e751788b"></a><br/></td></tr>
<tr class="separator:ga5cad862a34f2363fbef1e0b8e751788b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70dab11f1a4389403732ea76722e9d70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga70dab11f1a4389403732ea76722e9d70">XsDevice_isSyncMaster</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga70dab11f1a4389403732ea76722e9d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a master role regarding the device synchronization   <a href="#ga70dab11f1a4389403732ea76722e9d70"></a><br/></td></tr>
<tr class="separator:ga70dab11f1a4389403732ea76722e9d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca48050228c8e3d5815d1ed57f4b5c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabca48050228c8e3d5815d1ed57f4b5c0">XsDevice_isSyncSlave</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gabca48050228c8e3d5815d1ed57f4b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a slave role regarding the device synchronization   <a href="#gabca48050228c8e3d5815d1ed57f4b5c0"></a><br/></td></tr>
<tr class="separator:gabca48050228c8e3d5815d1ed57f4b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa837d3c8dfb99a0ac5daa5f2e9caef9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa837d3c8dfb99a0ac5daa5f2e9caef9b">XsDevice_supportedSyncSettings</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *)</td></tr>
<tr class="memdesc:gaa837d3c8dfb99a0ac5daa5f2e9caef9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all supported synchronization settings available on the device.   <a href="#gaa837d3c8dfb99a0ac5daa5f2e9caef9b"></a><br/></td></tr>
<tr class="separator:gaa837d3c8dfb99a0ac5daa5f2e9caef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c361c712c7eed18b05ef54c3c8d2b96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c361c712c7eed18b05ef54c3c8d2b96">XsDevice_gotoMeasurement</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga6c361c712c7eed18b05ef54c3c8d2b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put this device in measurement mode.   <a href="#ga6c361c712c7eed18b05ef54c3c8d2b96"></a><br/></td></tr>
<tr class="separator:ga6c361c712c7eed18b05ef54c3c8d2b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18abf6549ee2b0aed00a9a0423090aa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga18abf6549ee2b0aed00a9a0423090aa4">XsDevice_gotoConfig</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga18abf6549ee2b0aed00a9a0423090aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in config mode.   <a href="#ga18abf6549ee2b0aed00a9a0423090aa4"></a><br/></td></tr>
<tr class="separator:ga18abf6549ee2b0aed00a9a0423090aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cee7d5dd56589754ab39f143493d7b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6cee7d5dd56589754ab39f143493d7b9">XsDevice_restoreFactoryDefaults</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga6cee7d5dd56589754ab39f143493d7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the device to its factory default settings.   <a href="#ga6cee7d5dd56589754ab39f143493d7b9"></a><br/></td></tr>
<tr class="separator:ga6cee7d5dd56589754ab39f143493d7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41f9da7a2d99d151e20eb57ed426f7eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga41f9da7a2d99d151e20eb57ed426f7eb">XsDevice_reset</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga41f9da7a2d99d151e20eb57ed426f7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the device.   <a href="#ga41f9da7a2d99d151e20eb57ed426f7eb"></a><br/></td></tr>
<tr class="separator:ga41f9da7a2d99d151e20eb57ed426f7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae978c4d9a80b1e5cd445a0dc39471cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae978c4d9a80b1e5cd445a0dc39471cce">XsDevice_writeDeviceSettingsToFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gae978c4d9a80b1e5cd445a0dc39471cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the emts/wms/xms of the device and all its children to the open logfile.   <a href="#gae978c4d9a80b1e5cd445a0dc39471cce"></a><br/></td></tr>
<tr class="separator:gae978c4d9a80b1e5cd445a0dc39471cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedad213da27e9dc5478be9c0b437d582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaedad213da27e9dc5478be9c0b437d582">XsDevice_flushInputBuffers</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int complete)</td></tr>
<tr class="memdesc:gaedad213da27e9dc5478be9c0b437d582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of the device.   <a href="#gaedad213da27e9dc5478be9c0b437d582"></a><br/></td></tr>
<tr class="separator:gaedad213da27e9dc5478be9c0b437d582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88933de954028c4c52e88e56011fd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac88933de954028c4c52e88e56011fd3a">XsDevice_syncRole</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gac88933de954028c4c52e88e56011fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the synchronization role of the device.   <a href="#gac88933de954028c4c52e88e56011fd3a"></a><br/></td></tr>
<tr class="separator:gac88933de954028c4c52e88e56011fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c337874d7ccc052b3867b35f5fcd31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga64c337874d7ccc052b3867b35f5fcd31">XsDevice_loadLogFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga64c337874d7ccc052b3867b35f5fcd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a complete logfile.   <a href="#ga64c337874d7ccc052b3867b35f5fcd31"></a><br/></td></tr>
<tr class="separator:ga64c337874d7ccc052b3867b35f5fcd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c9a1c98604c4eef1eed69b11bd6d22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga14c9a1c98604c4eef1eed69b11bd6d22">XsDevice_abortLoadLogFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga14c9a1c98604c4eef1eed69b11bd6d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts loading a logfile.   <a href="#ga14c9a1c98604c4eef1eed69b11bd6d22"></a><br/></td></tr>
<tr class="separator:ga14c9a1c98604c4eef1eed69b11bd6d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4925a997b89c889a349c9c11e310d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac4925a997b89c889a349c9c11e310d3d">XsDevice_logFileName</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *)</td></tr>
<tr class="memdesc:gac4925a997b89c889a349c9c11e310d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the log file the device is reading from.   <a href="#gac4925a997b89c889a349c9c11e310d3d"></a><br/></td></tr>
<tr class="separator:gac4925a997b89c889a349c9c11e310d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae321f1876daa2d3f750252580afcd80a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae321f1876daa2d3f750252580afcd80a">XsDevice_droppedPacketCount</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gae321f1876daa2d3f750252580afcd80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of packets dropped by the port.   <a href="#gae321f1876daa2d3f750252580afcd80a"></a><br/></td></tr>
<tr class="separator:gae321f1876daa2d3f750252580afcd80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab043c28de7ce0a55da322b4b26354ac4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab043c28de7ce0a55da322b4b26354ac4">XsDevice_resetOrientation</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a> resetmethod)</td></tr>
<tr class="memdesc:gab043c28de7ce0a55da322b4b26354ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an orientation reset on the device using the given <em>resetMethod</em>.   <a href="#gab043c28de7ce0a55da322b4b26354ac4"></a><br/></td></tr>
<tr class="separator:gab043c28de7ce0a55da322b4b26354ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675bde3ebc205e6e5884d33eeb7f37d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga675bde3ebc205e6e5884d33eeb7f37d8">XsDevice_peekMessageId</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga675bde3ebc205e6e5884d33eeb7f37d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a peek at the next message's message ID in the file.   <a href="#ga675bde3ebc205e6e5884d33eeb7f37d8"></a><br/></td></tr>
<tr class="separator:ga675bde3ebc205e6e5884d33eeb7f37d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50da46c88502787679b6209f3000c840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga50da46c88502787679b6209f3000c840">XsDevice_resetLogFileReadPosition</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga50da46c88502787679b6209f3000c840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read position of the open log file to the start of the file.   <a href="#ga50da46c88502787679b6209f3000c840"></a><br/></td></tr>
<tr class="separator:ga50da46c88502787679b6209f3000c840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5579af141e879efb50048942920038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabd5579af141e879efb50048942920038">XsDevice_logFileSize</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gabd5579af141e879efb50048942920038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the log file the device is reading from.   <a href="#gabd5579af141e879efb50048942920038"></a><br/></td></tr>
<tr class="separator:gabd5579af141e879efb50048942920038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45568a2353e6b07375a3f91c8805eedb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga45568a2353e6b07375a3f91c8805eedb">XsDevice_logFileReadPosition</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga45568a2353e6b07375a3f91c8805eedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current read position of the open log file.   <a href="#ga45568a2353e6b07375a3f91c8805eedb"></a><br/></td></tr>
<tr class="separator:ga45568a2353e6b07375a3f91c8805eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17a7d374252e7daeda758bc8a8fe3bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab17a7d374252e7daeda758bc8a8fe3bd">XsDevice_updateCachedDeviceInformation</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gab17a7d374252e7daeda758bc8a8fe3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the cached device information for all devices connected to this port.   <a href="#gab17a7d374252e7daeda758bc8a8fe3bd"></a><br/></td></tr>
<tr class="separator:gab17a7d374252e7daeda758bc8a8fe3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16025755416a93905984e5efa4e3816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab16025755416a93905984e5efa4e3816">XsDevice_enableProtocol</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:gab16025755416a93905984e5efa4e3816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an additional communication protocol when reading messages.   <a href="#gab16025755416a93905984e5efa4e3816"></a><br/></td></tr>
<tr class="separator:gab16025755416a93905984e5efa4e3816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205fbb4d9bb04ba7a201d9949f2d0fd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga205fbb4d9bb04ba7a201d9949f2d0fd0">XsDevice_disableProtocol</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:ga205fbb4d9bb04ba7a201d9949f2d0fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#ab8e5368ad9948b79ff0d45ec5068b9c6" title="Enable an additional communication protocol when reading messages.">XsDevice::enableProtocol</a>.   <a href="#ga205fbb4d9bb04ba7a201d9949f2d0fd0"></a><br/></td></tr>
<tr class="separator:ga205fbb4d9bb04ba7a201d9949f2d0fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc28e9c468bd06725a327c82fca09818"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadc28e9c468bd06725a327c82fca09818">XsDevice_isProtocolEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:gadc28e9c468bd06725a327c82fca09818"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#gadc28e9c468bd06725a327c82fca09818"></a><br/></td></tr>
<tr class="separator:gadc28e9c468bd06725a327c82fca09818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0755cc7df836cb7d82560db0fbce8035"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0755cc7df836cb7d82560db0fbce8035">XsDevice_resetDroppedPacketCount</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga0755cc7df836cb7d82560db0fbce8035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the dropped packet count.   <a href="#ga0755cc7df836cb7d82560db0fbce8035"></a><br/></td></tr>
<tr class="separator:ga0755cc7df836cb7d82560db0fbce8035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8deac8b2a3914349f161cedf257de816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8deac8b2a3914349f161cedf257de816">XsDevice_setQueueMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> mode)</td></tr>
<tr class="memdesc:ga8deac8b2a3914349f161cedf257de816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the queue mode to the given <em>mode</em>.   <a href="#ga8deac8b2a3914349f161cedf257de816"></a><br/></td></tr>
<tr class="separator:ga8deac8b2a3914349f161cedf257de816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588928e550376412fd3c5ff048734556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga588928e550376412fd3c5ff048734556">XsDevice_queueMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga588928e550376412fd3c5ff048734556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently used queue mode.   <a href="#ga588928e550376412fd3c5ff048734556"></a><br/></td></tr>
<tr class="separator:ga588928e550376412fd3c5ff048734556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371831a389bc5772fa5fc399485ab394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga371831a389bc5772fa5fc399485ab394">XsDevice_connectivityState</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> *)</td></tr>
<tr class="memdesc:ga371831a389bc5772fa5fc399485ab394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connectivity state of the device.   <a href="#ga371831a389bc5772fa5fc399485ab394"></a><br/></td></tr>
<tr class="separator:ga371831a389bc5772fa5fc399485ab394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd59e37cfa50acf2cf614d34779c61ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacd59e37cfa50acf2cf614d34779c61ff">XsDevice_enableRadio</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int channel)</td></tr>
<tr class="memdesc:gacd59e37cfa50acf2cf614d34779c61ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio channel to use for wireless communication.   <a href="#gacd59e37cfa50acf2cf614d34779c61ff"></a><br/></td></tr>
<tr class="separator:gacd59e37cfa50acf2cf614d34779c61ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8df03ab9f8fb0cf1bc733ce07769c50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae8df03ab9f8fb0cf1bc733ce07769c50">XsDevice_disableRadio</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gae8df03ab9f8fb0cf1bc733ce07769c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the radio for this station, resetting all children to disconnected state.   <a href="#gae8df03ab9f8fb0cf1bc733ce07769c50"></a><br/></td></tr>
<tr class="separator:gae8df03ab9f8fb0cf1bc733ce07769c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ba9f8c5c5a33147e4d2d2f9a404947"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga71ba9f8c5c5a33147e4d2d2f9a404947">XsDevice_radioChannel</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga71ba9f8c5c5a33147e4d2d2f9a404947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radio channel used for wireless communication.   <a href="#ga71ba9f8c5c5a33147e4d2d2f9a404947"></a><br/></td></tr>
<tr class="separator:ga71ba9f8c5c5a33147e4d2d2f9a404947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a2e38147c7d707bfcdf43cb5ec0832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad7a2e38147c7d707bfcdf43cb5ec0832">XsDevice_isRadioEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gad7a2e38147c7d707bfcdf43cb5ec0832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the radio is enabled.   <a href="#gad7a2e38147c7d707bfcdf43cb5ec0832"></a><br/></td></tr>
<tr class="separator:gad7a2e38147c7d707bfcdf43cb5ec0832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d8c392a61d7163f0217b7c4cf4e039"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga13d8c392a61d7163f0217b7c4cf4e039">XsDevice_makeOperational</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga13d8c392a61d7163f0217b7c4cf4e039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets te Awinda station to operational state.   <a href="#ga13d8c392a61d7163f0217b7c4cf4e039"></a><br/></td></tr>
<tr class="separator:ga13d8c392a61d7163f0217b7c4cf4e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a94468f0c2531aedefaabf19232a337"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1a94468f0c2531aedefaabf19232a337">XsDevice_isOperational</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga1a94468f0c2531aedefaabf19232a337"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#ga1a94468f0c2531aedefaabf19232a337"></a><br/></td></tr>
<tr class="separator:ga1a94468f0c2531aedefaabf19232a337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66dd3a2f2535c3dbe9927d5b23d8e0ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga66dd3a2f2535c3dbe9927d5b23d8e0ab">XsDevice_isInSyncBoxMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga66dd3a2f2535c3dbe9927d5b23d8e0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#ga66dd3a2f2535c3dbe9927d5b23d8e0ab"></a><br/></td></tr>
<tr class="separator:ga66dd3a2f2535c3dbe9927d5b23d8e0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893486efde59d7f237f26829e7f86521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga893486efde59d7f237f26829e7f86521">XsDevice_setSyncBoxMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int enabled)</td></tr>
<tr class="memdesc:ga893486efde59d7f237f26829e7f86521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sync box mode of the Awinda Station device.   <a href="#ga893486efde59d7f237f26829e7f86521"></a><br/></td></tr>
<tr class="separator:ga893486efde59d7f237f26829e7f86521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a7239ecb03d1d0dbc2934e6239c07c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga08a7239ecb03d1d0dbc2934e6239c07c">XsDevice_abortFlushing</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga08a7239ecb03d1d0dbc2934e6239c07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the wireless flushing operation and finalize the recording.   <a href="#ga08a7239ecb03d1d0dbc2934e6239c07c"></a><br/></td></tr>
<tr class="separator:ga08a7239ecb03d1d0dbc2934e6239c07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0e915e3b33b2e2b587d3b27130d43c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd0e915e3b33b2e2b587d3b27130d43c">XsDevice_setDeviceAccepted</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:gafd0e915e3b33b2e2b587d3b27130d43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a device.   <a href="#gafd0e915e3b33b2e2b587d3b27130d43c"></a><br/></td></tr>
<tr class="separator:gafd0e915e3b33b2e2b587d3b27130d43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9ae201860023e86437e4719ae4a804"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5c9ae201860023e86437e4719ae4a804">XsDevice_setDeviceRejected</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *deviceId)</td></tr>
<tr class="memdesc:ga5c9ae201860023e86437e4719ae4a804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejects a device.   <a href="#ga5c9ae201860023e86437e4719ae4a804"></a><br/></td></tr>
<tr class="separator:ga5c9ae201860023e86437e4719ae4a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cd84992f97ea64374de890161cbac4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga28cd84992f97ea64374de890161cbac4">XsDevice_acceptConnection</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga28cd84992f97ea64374de890161cbac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connections from the device on the parent/master device.   <a href="#ga28cd84992f97ea64374de890161cbac4"></a><br/></td></tr>
<tr class="separator:ga28cd84992f97ea64374de890161cbac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f392866b0b0a69f6974bf961d7106c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9f392866b0b0a69f6974bf961d7106c0">XsDevice_rejectConnection</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga9f392866b0b0a69f6974bf961d7106c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject connections from the device on the parent/master device.   <a href="#ga9f392866b0b0a69f6974bf961d7106c0"></a><br/></td></tr>
<tr class="separator:ga9f392866b0b0a69f6974bf961d7106c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc9344d5074c5b6836456e16601d7f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabfc9344d5074c5b6836456e16601d7f5">XsDevice_wirelessPriority</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gabfc9344d5074c5b6836456e16601d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wireless priority of the device.   <a href="#gabfc9344d5074c5b6836456e16601d7f5"></a><br/></td></tr>
<tr class="separator:gabfc9344d5074c5b6836456e16601d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687f8875ca5c3c200ecf21c295c8935e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga687f8875ca5c3c200ecf21c295c8935e">XsDevice_setWirelessPriority</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int priority)</td></tr>
<tr class="memdesc:ga687f8875ca5c3c200ecf21c295c8935e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wireless priority of the device.   <a href="#ga687f8875ca5c3c200ecf21c295c8935e"></a><br/></td></tr>
<tr class="separator:ga687f8875ca5c3c200ecf21c295c8935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f365d72af98216e8631c0018fa537b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad6f365d72af98216e8631c0018fa537b">XsDevice_rejectReason</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gad6f365d72af98216e8631c0018fa537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason why a device's connection was rejected.   <a href="#gad6f365d72af98216e8631c0018fa537b"></a><br/></td></tr>
<tr class="separator:gad6f365d72af98216e8631c0018fa537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7a649d821feee34eb62f1773328347"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaff7a649d821feee34eb62f1773328347">XsDevice_requestBatteryLevel</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gaff7a649d821feee34eb62f1773328347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the battery level from the device.   <a href="#gaff7a649d821feee34eb62f1773328347"></a><br/></td></tr>
<tr class="separator:gaff7a649d821feee34eb62f1773328347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07718994b8cd089e11c2dd43f7133c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf07718994b8cd089e11c2dd43f7133c1">XsDevice_setTransportMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int transportModeEnabled)</td></tr>
<tr class="memdesc:gaf07718994b8cd089e11c2dd43f7133c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the transport mode for the device.   <a href="#gaf07718994b8cd089e11c2dd43f7133c1"></a><br/></td></tr>
<tr class="separator:gaf07718994b8cd089e11c2dd43f7133c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafce827017c16f5866b4a4f741164402c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafce827017c16f5866b4a4f741164402c">XsDevice_transportMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gafce827017c16f5866b4a4f741164402c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the transport mode feature.   <a href="#gafce827017c16f5866b4a4f741164402c"></a><br/></td></tr>
<tr class="separator:gafce827017c16f5866b4a4f741164402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10b0a703c516121b81816b517854243"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf10b0a703c516121b81816b517854243">XsDevice_lastKnownRssi</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gaf10b0a703c516121b81816b517854243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last known RSSI value of the device.   <a href="#gaf10b0a703c516121b81816b517854243"></a><br/></td></tr>
<tr class="separator:gaf10b0a703c516121b81816b517854243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f33a324b590970a580713b5ceb07bba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1f33a324b590970a580713b5ceb07bba">XsDevice_isBlueToothEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga1f33a324b590970a580713b5ceb07bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device has its BlueTooth radio enabled (Xbus Master only)   <a href="#ga1f33a324b590970a580713b5ceb07bba"></a><br/></td></tr>
<tr class="separator:ga1f33a324b590970a580713b5ceb07bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451e7c3e1f7bbca6902ac072cc2b9f8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga451e7c3e1f7bbca6902ac072cc2b9f8d">XsDevice_setBlueToothEnabled</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int enabled)</td></tr>
<tr class="memdesc:ga451e7c3e1f7bbca6902ac072cc2b9f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the BlueTooth radio of the device (Xbus Master only)   <a href="#ga451e7c3e1f7bbca6902ac072cc2b9f8d"></a><br/></td></tr>
<tr class="separator:ga451e7c3e1f7bbca6902ac072cc2b9f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401cf56b1145730f773e1a19ef5c15d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga401cf56b1145730f773e1a19ef5c15d3">XsDevice_isDualOutputEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga401cf56b1145730f773e1a19ef5c15d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is sending output over its BlueTooth radio and over the serial connection (Xbus Master only)   <a href="#ga401cf56b1145730f773e1a19ef5c15d3"></a><br/></td></tr>
<tr class="separator:ga401cf56b1145730f773e1a19ef5c15d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69555474816894135e201867491beb05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga69555474816894135e201867491beb05">XsDevice_setDualOutputEnabled</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int enabled)</td></tr>
<tr class="memdesc:ga69555474816894135e201867491beb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the BlueTooth radio of the device (Xbus Master only)   <a href="#ga69555474816894135e201867491beb05"></a><br/></td></tr>
<tr class="separator:ga69555474816894135e201867491beb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6319695dc214b742f6eb5410636e2d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac6319695dc214b742f6eb5410636e2d8">XsDevice_isBusPowerEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gac6319695dc214b742f6eb5410636e2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Xbus Master is powering its child devices or not.   <a href="#gac6319695dc214b742f6eb5410636e2d8"></a><br/></td></tr>
<tr class="separator:gac6319695dc214b742f6eb5410636e2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5539f6a7d8abc5fa633951b7c21c44c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5539f6a7d8abc5fa633951b7c21c44c7">XsDevice_setBusPowerEnabled</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int enabled)</td></tr>
<tr class="memdesc:ga5539f6a7d8abc5fa633951b7c21c44c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the Xbus Master to provide power to its child devices or not.   <a href="#ga5539f6a7d8abc5fa633951b7c21c44c7"></a><br/></td></tr>
<tr class="separator:ga5539f6a7d8abc5fa633951b7c21c44c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac8ddf3b5e663766f7b002c089da498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7ac8ddf3b5e663766f7b002c089da498">XsDevice_powerDown</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga7ac8ddf3b5e663766f7b002c089da498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the device to power down completely (Xbus Master only)   <a href="#ga7ac8ddf3b5e663766f7b002c089da498"></a><br/></td></tr>
<tr class="separator:ga7ac8ddf3b5e663766f7b002c089da498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e567a1373427a84763b1bee353d881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga17e567a1373427a84763b1bee353d881">XsDevice_errorMode</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga17e567a1373427a84763b1bee353d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error mode of the device (Xbus Master only)   <a href="#ga17e567a1373427a84763b1bee353d881"></a><br/></td></tr>
<tr class="separator:ga17e567a1373427a84763b1bee353d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8dd28c41c94af5b949b058d1ab421b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7f8dd28c41c94af5b949b058d1ab421b">XsDevice_setErrorMode</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> errormode)</td></tr>
<tr class="memdesc:ga7f8dd28c41c94af5b949b058d1ab421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error mode of the device (Xbus Master only)   <a href="#ga7f8dd28c41c94af5b949b058d1ab421b"></a><br/></td></tr>
<tr class="separator:ga7f8dd28c41c94af5b949b058d1ab421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae466d3d3551c6892d8603f9202777b13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae466d3d3551c6892d8603f9202777b13">XsDevice_setHeadingOffset</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, double offset)</td></tr>
<tr class="memdesc:gae466d3d3551c6892d8603f9202777b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'heading offset' setting of the device.   <a href="#gae466d3d3551c6892d8603f9202777b13"></a><br/></td></tr>
<tr class="separator:gae466d3d3551c6892d8603f9202777b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d46f0fabd260391848e2ba5593e530"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga68d46f0fabd260391848e2ba5593e530">XsDevice_headingOffset</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga68d46f0fabd260391848e2ba5593e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 'heading offset' setting of the device.   <a href="#ga68d46f0fabd260391848e2ba5593e530"></a><br/></td></tr>
<tr class="separator:ga68d46f0fabd260391848e2ba5593e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4245d6d59921f1db3b26db7974fdd6fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4245d6d59921f1db3b26db7974fdd6fc">XsDevice_setLocationId</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int id)</td></tr>
<tr class="memdesc:ga4245d6d59921f1db3b26db7974fdd6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location ID of the device.   <a href="#ga4245d6d59921f1db3b26db7974fdd6fc"></a><br/></td></tr>
<tr class="separator:ga4245d6d59921f1db3b26db7974fdd6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b5cd858739361e0c9e7162e4139791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad5b5cd858739361e0c9e7162e4139791">XsDevice_locationId</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gad5b5cd858739361e0c9e7162e4139791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location ID of the device.   <a href="#gad5b5cd858739361e0c9e7162e4139791"></a><br/></td></tr>
<tr class="separator:gad5b5cd858739361e0c9e7162e4139791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08162bf38bbc8fbbd8638d9550a2665b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga08162bf38bbc8fbbd8638d9550a2665b">XsDevice_objectAlignment</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:ga08162bf38bbc8fbbd8638d9550a2665b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object alignment matrix of the device.   <a href="#ga08162bf38bbc8fbbd8638d9550a2665b"></a><br/></td></tr>
<tr class="separator:ga08162bf38bbc8fbbd8638d9550a2665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fba448ad00e8d6e506f9056b8568625"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6fba448ad00e8d6e506f9056b8568625">XsDevice_setObjectAlignment</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *matrix)</td></tr>
<tr class="memdesc:ga6fba448ad00e8d6e506f9056b8568625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the object alignment of the device to the given <em>matrix</em>.   <a href="#ga6fba448ad00e8d6e506f9056b8568625"></a><br/></td></tr>
<tr class="separator:ga6fba448ad00e8d6e506f9056b8568625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f86796fdea4468a4f7c37b612d2b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae4f86796fdea4468a4f7c37b612d2b66">XsDevice_labMagneticField</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:gae4f86796fdea4468a4f7c37b612d2b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'Lab Magnetic Field' of the device.   <a href="#gae4f86796fdea4468a4f7c37b612d2b66"></a><br/></td></tr>
<tr class="separator:gae4f86796fdea4468a4f7c37b612d2b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace30fc664530c201d05c689f5bc29212"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gace30fc664530c201d05c689f5bc29212">XsDevice_setLabMagneticField</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *magfield)</td></tr>
<tr class="memdesc:gace30fc664530c201d05c689f5bc29212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Lab Magnetic Field' of the device to the given <em>vector</em>.   <a href="#gace30fc664530c201d05c689f5bc29212"></a><br/></td></tr>
<tr class="separator:gace30fc664530c201d05c689f5bc29212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f34f4d2050cdd2a573f942a24e2376"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad5f34f4d2050cdd2a573f942a24e2376">XsDevice_gravityMagnitude</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gad5f34f4d2050cdd2a573f942a24e2376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'Gravity Magnitude' of the device.   <a href="#gad5f34f4d2050cdd2a573f942a24e2376"></a><br/></td></tr>
<tr class="separator:gad5f34f4d2050cdd2a573f942a24e2376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3930a26da06230ed2429128602c360a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3930a26da06230ed2429128602c360a3">XsDevice_setGravityMagnitude</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, double mag)</td></tr>
<tr class="memdesc:ga3930a26da06230ed2429128602c360a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>.   <a href="#ga3930a26da06230ed2429128602c360a3"></a><br/></td></tr>
<tr class="separator:ga3930a26da06230ed2429128602c360a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c134d84f62b87e63b8c0e7feebef66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c134d84f62b87e63b8c0e7feebef66f">XsDevice_latLonAlt</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga6c134d84f62b87e63b8c0e7feebef66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'Latitude Longitude Altitude' setting of the device.   <a href="#ga6c134d84f62b87e63b8c0e7feebef66f"></a><br/></td></tr>
<tr class="separator:ga6c134d84f62b87e63b8c0e7feebef66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8462cf6a3d008e18eef4619ee02ecc64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8462cf6a3d008e18eef4619ee02ecc64">XsDevice_setLatLonAlt</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *lla)</td></tr>
<tr class="memdesc:ga8462cf6a3d008e18eef4619ee02ecc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>.   <a href="#ga8462cf6a3d008e18eef4619ee02ecc64"></a><br/></td></tr>
<tr class="separator:ga8462cf6a3d008e18eef4619ee02ecc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdd8400ff6613e6bb721363d0441ee6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8cdd8400ff6613e6bb721363d0441ee6">XsDevice_reinitialize</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga8cdd8400ff6613e6bb721363d0441ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>.   <a href="#ga8cdd8400ff6613e6bb721363d0441ee6"></a><br/></td></tr>
<tr class="separator:ga8cdd8400ff6613e6bb721363d0441ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga822044193bb1949eceac4de83cafe82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga822044193bb1949eceac4de83cafe82d">XsDevice_xdaFilterProfile</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *)</td></tr>
<tr class="memdesc:ga822044193bb1949eceac4de83cafe82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use for computing orientations on the host PC.   <a href="#ga822044193bb1949eceac4de83cafe82d"></a><br/></td></tr>
<tr class="separator:ga822044193bb1949eceac4de83cafe82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0d09ed69482da66b5b3c5be7685918"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6f0d09ed69482da66b5b3c5be7685918">XsDevice_setXdaFilterProfile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int profileType)</td></tr>
<tr class="memdesc:ga6f0d09ed69482da66b5b3c5be7685918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the host PC.   <a href="#ga6f0d09ed69482da66b5b3c5be7685918"></a><br/></td></tr>
<tr class="separator:ga6f0d09ed69482da66b5b3c5be7685918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6595dd547b4e4a1ca4d0a0231b74110b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6595dd547b4e4a1ca4d0a0231b74110b">XsDevice_onboardFilterProfile</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *)</td></tr>
<tr class="memdesc:ga6595dd547b4e4a1ca4d0a0231b74110b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use by the device for computing orientations.   <a href="#ga6595dd547b4e4a1ca4d0a0231b74110b"></a><br/></td></tr>
<tr class="separator:ga6595dd547b4e4a1ca4d0a0231b74110b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6293cd64825503e7872e19872cbe0c25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6293cd64825503e7872e19872cbe0c25">XsDevice_setOnboardFilterProfile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int profileType)</td></tr>
<tr class="memdesc:ga6293cd64825503e7872e19872cbe0c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the device.   <a href="#ga6293cd64825503e7872e19872cbe0c25"></a><br/></td></tr>
<tr class="separator:ga6293cd64825503e7872e19872cbe0c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493527794566c1a5cac963e0cf2f489d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga493527794566c1a5cac963e0cf2f489d">XsDevice_replaceFilterProfile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *profileCurrent, const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *profileNew)</td></tr>
<tr class="memdesc:ga493527794566c1a5cac963e0cf2f489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces profileCurrent by profileNew in the device.   <a href="#ga493527794566c1a5cac963e0cf2f489d"></a><br/></td></tr>
<tr class="separator:ga493527794566c1a5cac963e0cf2f489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24806c3bcac93002f07429c069d0a637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga24806c3bcac93002f07429c069d0a637">XsDevice_availableOnboardFilterProfiles</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> *)</td></tr>
<tr class="memdesc:ga24806c3bcac93002f07429c069d0a637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the device.   <a href="#ga24806c3bcac93002f07429c069d0a637"></a><br/></td></tr>
<tr class="separator:ga24806c3bcac93002f07429c069d0a637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9adf31f2e5c951d165f09e0645485e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9adf31f2e5c951d165f09e0645485e22">XsDevice_availableXdaFilterProfiles</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> *)</td></tr>
<tr class="memdesc:ga9adf31f2e5c951d165f09e0645485e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the host PC.   <a href="#ga9adf31f2e5c951d165f09e0645485e22"></a><br/></td></tr>
<tr class="separator:ga9adf31f2e5c951d165f09e0645485e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac426a9a6668327c75735bd044cb5cb02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac426a9a6668327c75735bd044cb5cb02">XsDevice_accelerometerRange</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gac426a9a6668327c75735bd044cb5cb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the accelerometers in the device.   <a href="#gac426a9a6668327c75735bd044cb5cb02"></a><br/></td></tr>
<tr class="separator:gac426a9a6668327c75735bd044cb5cb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c6a1f52f9176d0f3805bc5411477ea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga46c6a1f52f9176d0f3805bc5411477ea">XsDevice_gyroscopeRange</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga46c6a1f52f9176d0f3805bc5411477ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the gyroscopes in the device.   <a href="#ga46c6a1f52f9176d0f3805bc5411477ea"></a><br/></td></tr>
<tr class="separator:ga46c6a1f52f9176d0f3805bc5411477ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92891e663023f1f4c353eb198f338ac0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga92891e663023f1f4c353eb198f338ac0">XsDevice_setNoRotation</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, uint16_t duration)</td></tr>
<tr class="memdesc:ga92891e663023f1f4c353eb198f338ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the no rotation period to <em>duration</em>.   <a href="#ga92891e663023f1f4c353eb198f338ac0"></a><br/></td></tr>
<tr class="separator:ga92891e663023f1f4c353eb198f338ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8885efce73c436193cca9324ba9645"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8d8885efce73c436193cca9324ba9645">XsDevice_rs485TransmissionDelay</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga8d8885efce73c436193cca9324ba9645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transmission delay used for RS485 transmissions.   <a href="#ga8d8885efce73c436193cca9324ba9645"></a><br/></td></tr>
<tr class="separator:ga8d8885efce73c436193cca9324ba9645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05057b7b04ff7097fb1bf82d7d3a1ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab05057b7b04ff7097fb1bf82d7d3a1ad">XsDevice_setRs485TransmissionDelay</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, uint16_t delay)</td></tr>
<tr class="memdesc:gab05057b7b04ff7097fb1bf82d7d3a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transmission delay used for RS485 transmissions.   <a href="#gab05057b7b04ff7097fb1bf82d7d3a1ad"></a><br/></td></tr>
<tr class="separator:gab05057b7b04ff7097fb1bf82d7d3a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc089b48704b61b33c33d4bb96c9255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1dc089b48704b61b33c33d4bb96c9255">XsDevice_runSelfTest</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a> *)</td></tr>
<tr class="memdesc:ga1dc089b48704b61b33c33d4bb96c9255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the self test for the device.   <a href="#ga1dc089b48704b61b33c33d4bb96c9255"></a><br/></td></tr>
<tr class="separator:ga1dc089b48704b61b33c33d4bb96c9255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62fc9374c41bcd69a4944248af4849ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga62fc9374c41bcd69a4944248af4849ae">XsDevice_requestData</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga62fc9374c41bcd69a4944248af4849ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request data when configured in legacy mode with infinite skip factor.   <a href="#ga62fc9374c41bcd69a4944248af4849ae"></a><br/></td></tr>
<tr class="separator:ga62fc9374c41bcd69a4944248af4849ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0ef2795b731c8965890dd54abf9357e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac0ef2795b731c8965890dd54abf9357e">XsDevice_storeFilterState</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:gac0ef2795b731c8965890dd54abf9357e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store orientation filter state in the device.   <a href="#gac0ef2795b731c8965890dd54abf9357e"></a><br/></td></tr>
<tr class="separator:gac0ef2795b731c8965890dd54abf9357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30b0eb860ad3a229132acfff784eb9a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga30b0eb860ad3a229132acfff784eb9a1">XsDevice_isInitialBiasUpdateEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga30b0eb860ad3a229132acfff784eb9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device does gyroscope bias estimation when switching to measurement mode.   <a href="#ga30b0eb860ad3a229132acfff784eb9a1"></a><br/></td></tr>
<tr class="separator:ga30b0eb860ad3a229132acfff784eb9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de2b22639ce8ad7a5d6081fe4ac3649"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3de2b22639ce8ad7a5d6081fe4ac3649">XsDevice_setInitialBiasUpdateEnabled</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int enable)</td></tr>
<tr class="memdesc:ga3de2b22639ce8ad7a5d6081fe4ac3649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if the device does gyroscope bias estimation when switching to measurement mode.   <a href="#ga3de2b22639ce8ad7a5d6081fe4ac3649"></a><br/></td></tr>
<tr class="separator:ga3de2b22639ce8ad7a5d6081fe4ac3649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2758964cce8ae31eab1fd6690de71b4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2758964cce8ae31eab1fd6690de71b4b">XsDevice_isFixedGravityEnabled</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *)</td></tr>
<tr class="memdesc:ga2758964cce8ae31eab1fd6690de71b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the fixed gravity value should be used or if it should be computed from the LatLonAlt value.   <a href="#ga2758964cce8ae31eab1fd6690de71b4b"></a><br/></td></tr>
<tr class="separator:ga2758964cce8ae31eab1fd6690de71b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdf2adfeb1c4914559adf051b691e95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaabdf2adfeb1c4914559adf051b691e95">XsDevice_setFixedGravityEnabled</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, int enable)</td></tr>
<tr class="memdesc:gaabdf2adfeb1c4914559adf051b691e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the fixed gravity value should be used or if it should be computed from the LatLonAlt value.   <a href="#gaabdf2adfeb1c4914559adf051b691e95"></a><br/></td></tr>
<tr class="separator:gaabdf2adfeb1c4914559adf051b691e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6b43b41aa8668e46f826981c61c58d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9f6b43b41aa8668e46f826981c61c58d">XsDevice_createConfigFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *filename)</td></tr>
<tr class="memdesc:ga9f6b43b41aa8668e46f826981c61c58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the current device configuration in a config file(.xsa)   <a href="#ga9f6b43b41aa8668e46f826981c61c58d"></a><br/></td></tr>
<tr class="separator:ga9f6b43b41aa8668e46f826981c61c58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ebafa4863ae3d8f9eff16b5de656d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0ebafa4863ae3d8f9eff16b5de656d05">XsDevice_applyConfigFile</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, const <a class="el" href="struct_xs_string.html">XsString</a> *filename)</td></tr>
<tr class="memdesc:ga0ebafa4863ae3d8f9eff16b5de656d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a config file(.xsa) and configures the device accordingly.   <a href="#ga0ebafa4863ae3d8f9eff16b5de656d05"></a><br/></td></tr>
<tr class="separator:ga0ebafa4863ae3d8f9eff16b5de656d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5860923160341562c43ea3f5da351bfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5860923160341562c43ea3f5da351bfb">XsDevice_setAlignmentRotationMatrix</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *matrix)</td></tr>
<tr class="memdesc:ga5860923160341562c43ea3f5da351bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the chosen frame S   <a href="#ga5860923160341562c43ea3f5da351bfb"></a><br/></td></tr>
<tr class="separator:ga5860923160341562c43ea3f5da351bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901bae80b41eec83f3f8969bbc08395a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga901bae80b41eec83f3f8969bbc08395a">XsDevice_alignmentRotationMatrix</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, <a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame)</td></tr>
<tr class="memdesc:ga901bae80b41eec83f3f8969bbc08395a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation matrix to rotate S to the chosen frame S   <a href="#ga901bae80b41eec83f3f8969bbc08395a"></a><br/></td></tr>
<tr class="separator:ga901bae80b41eec83f3f8969bbc08395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63113b75edf8d7f16f701a182c8b5a5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga63113b75edf8d7f16f701a182c8b5a5e">XsDevice_setAlignmentRotationQuaternion</a> (struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:ga63113b75edf8d7f16f701a182c8b5a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to the chosen frame S   <a href="#ga63113b75edf8d7f16f701a182c8b5a5e"></a><br/></td></tr>
<tr class="separator:ga63113b75edf8d7f16f701a182c8b5a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82176e614b78e8a05f326e1893de24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab82176e614b78e8a05f326e1893de24b">XsDevice_alignmentRotationQuaternion</a> (const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, <a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame)</td></tr>
<tr class="memdesc:gab82176e614b78e8a05f326e1893de24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation quaternion.   <a href="#gab82176e614b78e8a05f326e1893de24b"></a><br/></td></tr>
<tr class="separator:gab82176e614b78e8a05f326e1893de24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga704fac796d6899e53094d97403927442"><td class="memItemLeft" align="right" valign="top">XsBaudRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga704fac796d6899e53094d97403927442">XsBaud_codeToRate</a> (XsBaudCode baudcode)</td></tr>
<tr class="memdesc:ga704fac796d6899e53094d97403927442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Xsens baud code to XsBaudRate.  <a href="#ga704fac796d6899e53094d97403927442"></a><br/></td></tr>
<tr class="separator:ga704fac796d6899e53094d97403927442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa587d7e451a00e7a3c2c4432c346cf9b"><td class="memItemLeft" align="right" valign="top">XsBaudCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa587d7e451a00e7a3c2c4432c346cf9b">XsBaud_rateToCode</a> (XsBaudRate baudrate)</td></tr>
<tr class="memdesc:gaa587d7e451a00e7a3c2c4432c346cf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XsBaudRate to an Xsens baud code.  <a href="#gaa587d7e451a00e7a3c2c4432c346cf9b"></a><br/></td></tr>
<tr class="separator:gaa587d7e451a00e7a3c2c4432c346cf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532744ada4da5b1e9c8a277cc98628a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga532744ada4da5b1e9c8a277cc98628a1">XsBaud_rateToNumeric</a> (XsBaudRate baudrate)</td></tr>
<tr class="memdesc:ga532744ada4da5b1e9c8a277cc98628a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a XsBaudrate to a numeric baudrate in bps.  <a href="#ga532744ada4da5b1e9c8a277cc98628a1"></a><br/></td></tr>
<tr class="separator:ga532744ada4da5b1e9c8a277cc98628a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7439bd0c058b38ce73d843d39fcef299"><td class="memItemLeft" align="right" valign="top">XsBaudRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7439bd0c058b38ce73d843d39fcef299">XsBaud_numericToRate</a> (int numeric)</td></tr>
<tr class="memdesc:ga7439bd0c058b38ce73d843d39fcef299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a numeric baudrate in bps to XsBaudrate.  <a href="#ga7439bd0c058b38ce73d843d39fcef299"></a><br/></td></tr>
<tr class="separator:ga7439bd0c058b38ce73d843d39fcef299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6a5994363a3d4d175eb5a4d42d7452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafb6a5994363a3d4d175eb5a4d42d7452">validatePacket</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gafb6a5994363a3d4d175eb5a4d42d7452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the packet is internally consistent.  <a href="#gafb6a5994363a3d4d175eb5a4d42d7452"></a><br/></td></tr>
<tr class="separator:gafb6a5994363a3d4d175eb5a4d42d7452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6333be127f949ebb5c3cc3839046a86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6333be127f949ebb5c3cc3839046a86b">XsDataPacket_originalMessage</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_message.html">XsMessage</a> *returnVal)</td></tr>
<tr class="memdesc:ga6333be127f949ebb5c3cc3839046a86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the original message of the data packet.  <a href="#ga6333be127f949ebb5c3cc3839046a86b"></a><br/></td></tr>
<tr class="separator:ga6333be127f949ebb5c3cc3839046a86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743130ab33839e30144cbe2a001153e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga743130ab33839e30144cbe2a001153e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga743130ab33839e30144cbe2a001153e6">XsDataPacket_setCalibratedGyroscopeData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *vec)</td></tr>
<tr class="memdesc:ga743130ab33839e30144cbe2a001153e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated gyroscope data for the item. <br/></td></tr>
<tr class="separator:ga743130ab33839e30144cbe2a001153e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d4ab0b8f1d7fcf2a0d37334dd9e827"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga46d4ab0b8f1d7fcf2a0d37334dd9e827"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga46d4ab0b8f1d7fcf2a0d37334dd9e827">XsDataPacket_containsRawGpsSvInfo</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga46d4ab0b8f1d7fcf2a0d37334dd9e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if data item contains RawGpsSvInfo, 0 otherwise. <br/></td></tr>
<tr class="separator:ga46d4ab0b8f1d7fcf2a0d37334dd9e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794947de84c8458cff16f5d7fdd822d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga794947de84c8458cff16f5d7fdd822d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga794947de84c8458cff16f5d7fdd822d8">XsDeviceId_swap</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *a, <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *b)</td></tr>
<tr class="memdesc:ga794947de84c8458cff16f5d7fdd822d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with those of <em>b</em>. <br/></td></tr>
<tr class="separator:ga794947de84c8458cff16f5d7fdd822d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ea691e74bd5a68076550bb0f430982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2ea691e74bd5a68076550bb0f430982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab2ea691e74bd5a68076550bb0f430982">XsGpsPvtData_destruct</a> (<a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *)</td></tr>
<tr class="memdesc:gab2ea691e74bd5a68076550bb0f430982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the XsGpsPvtData object. <br/></td></tr>
<tr class="separator:gab2ea691e74bd5a68076550bb0f430982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabab8128b0e6f7c584434fa35f9ca51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabab8128b0e6f7c584434fa35f9ca51a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaabab8128b0e6f7c584434fa35f9ca51a">XsGpsPvtData_empty</a> (const <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *)</td></tr>
<tr class="memdesc:gaabab8128b0e6f7c584434fa35f9ca51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object is empty (when it contains no valid data) <br/></td></tr>
<tr class="separator:gaabab8128b0e6f7c584434fa35f9ca51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e8d38925c77861ac921a55a4ad88db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e8d38925c77861ac921a55a4ad88db1"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3e8d38925c77861ac921a55a4ad88db1">XsMath_asinClamped</a> (XsReal x)</td></tr>
<tr class="memdesc:ga3e8d38925c77861ac921a55a4ad88db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns asin(<em>x</em>) for -1 &lt; x &lt; 1. <br/></td></tr>
<tr class="separator:ga3e8d38925c77861ac921a55a4ad88db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07528eb38651ea5364ffe8379f367d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07528eb38651ea5364ffe8379f367d24"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga07528eb38651ea5364ffe8379f367d24">XsMath_rad2deg</a> (XsReal radians)</td></tr>
<tr class="memdesc:ga07528eb38651ea5364ffe8379f367d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert radians to degrees. <br/></td></tr>
<tr class="separator:ga07528eb38651ea5364ffe8379f367d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbe79a94b1933aaf41935bc1bedaf42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7fbe79a94b1933aaf41935bc1bedaf42"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7fbe79a94b1933aaf41935bc1bedaf42">XsMath_deg2rad</a> (XsReal degrees)</td></tr>
<tr class="memdesc:ga7fbe79a94b1933aaf41935bc1bedaf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert degrees to radians. <br/></td></tr>
<tr class="separator:ga7fbe79a94b1933aaf41935bc1bedaf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8525444555a88e7edec98360b0034a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8525444555a88e7edec98360b0034a10"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8525444555a88e7edec98360b0034a10">XsMath_pow2</a> (XsReal a)</td></tr>
<tr class="memdesc:ga8525444555a88e7edec98360b0034a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>a</em> to the power of 2. <br/></td></tr>
<tr class="separator:ga8525444555a88e7edec98360b0034a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a54cd145e7cc021d5e236d4a3923a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80a54cd145e7cc021d5e236d4a3923a7"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga80a54cd145e7cc021d5e236d4a3923a7">XsMath_pow3</a> (XsReal a)</td></tr>
<tr class="memdesc:ga80a54cd145e7cc021d5e236d4a3923a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>a</em> to the power of 3. <br/></td></tr>
<tr class="separator:ga80a54cd145e7cc021d5e236d4a3923a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56aa58d530cc4f0d696a910adfaaa967"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56aa58d530cc4f0d696a910adfaaa967"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga56aa58d530cc4f0d696a910adfaaa967">XsMath_isFinite</a> (XsReal x)</td></tr>
<tr class="memdesc:ga56aa58d530cc4f0d696a910adfaaa967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if <em>x</em> is finite. <br/></td></tr>
<tr class="separator:ga56aa58d530cc4f0d696a910adfaaa967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd92ddfc40f528d4e30d01ec721b9f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd92ddfc40f528d4e30d01ec721b9f59"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacd92ddfc40f528d4e30d01ec721b9f59">XsMath_doubleToLong</a> (double d)</td></tr>
<tr class="memdesc:gacd92ddfc40f528d4e30d01ec721b9f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>d</em> integer converted from a double precision floating point value. <br/></td></tr>
<tr class="separator:gacd92ddfc40f528d4e30d01ec721b9f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519431d337ff6d61c6c1a0b404496395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga519431d337ff6d61c6c1a0b404496395"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga519431d337ff6d61c6c1a0b404496395">XsMath_doubleToInt64</a> (double d)</td></tr>
<tr class="memdesc:ga519431d337ff6d61c6c1a0b404496395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>d</em> integer converted from a double precision floating point value. <br/></td></tr>
<tr class="separator:ga519431d337ff6d61c6c1a0b404496395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1dfbf570dd9179d632bbf3fd163a483"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac1dfbf570dd9179d632bbf3fd163a483">byteSum</a> (const uint8_t *buffer, XsSize count)</td></tr>
<tr class="memdesc:gac1dfbf570dd9179d632bbf3fd163a483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the sum of the values in the buffer.  <a href="#gac1dfbf570dd9179d632bbf3fd163a483"></a><br/></td></tr>
<tr class="separator:gac1dfbf570dd9179d632bbf3fd163a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3aff1ac742c36f378747f4df0a7eb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3aff1ac742c36f378747f4df0a7eb65">XsMessage_constructSized</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize dataSize)</td></tr>
<tr class="memdesc:gaf3aff1ac742c36f378747f4df0a7eb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the XsMessage object and reserves <em>dataSize</em> bytes for data.  <a href="#gaf3aff1ac742c36f378747f4df0a7eb65"></a><br/></td></tr>
<tr class="separator:gaf3aff1ac742c36f378747f4df0a7eb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac09517b80fdf0c2195dd6c834438bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac09517b80fdf0c2195dd6c834438bb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaac09517b80fdf0c2195dd6c834438bb2">XsMessage_construct</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:gaac09517b80fdf0c2195dd6c834438bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the XsMessage object. <br/></td></tr>
<tr class="separator:gaac09517b80fdf0c2195dd6c834438bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5bfc5759c761cf73988915a1aa01ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f5bfc5759c761cf73988915a1aa01ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6f5bfc5759c761cf73988915a1aa01ba">XsMessage_copyConstruct</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, <a class="el" href="struct_xs_message.html">XsMessage</a> const *src)</td></tr>
<tr class="memdesc:ga6f5bfc5759c761cf73988915a1aa01ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> as a copy of <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> <em>src</em>. <br/></td></tr>
<tr class="separator:ga6f5bfc5759c761cf73988915a1aa01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da904b977b09ad3aaa4e32c4672cd12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9da904b977b09ad3aaa4e32c4672cd12">XsMessage_assign</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize dataSize)</td></tr>
<tr class="memdesc:ga9da904b977b09ad3aaa4e32c4672cd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reinitializes the XsMessage object and reserves <em>dataSize</em> bytes for data.  <a href="#ga9da904b977b09ad3aaa4e32c4672cd12"></a><br/></td></tr>
<tr class="separator:ga9da904b977b09ad3aaa4e32c4672cd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4dde94962cb03ca78d207d7ed7f5b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4dde94962cb03ca78d207d7ed7f5b46">XsMessage_load</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize msgSize, unsigned char const *src)</td></tr>
<tr class="memdesc:gad4dde94962cb03ca78d207d7ed7f5b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the XsMessage object and reserves <em>msgSize</em> bytes for data, it then copies in the data from <em>src</em>.  <a href="#gad4dde94962cb03ca78d207d7ed7f5b46"></a><br/></td></tr>
<tr class="separator:gad4dde94962cb03ca78d207d7ed7f5b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee251864355965b32fe3af9fa07e2419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee251864355965b32fe3af9fa07e2419">XsMessage_destruct</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:gaee251864355965b32fe3af9fa07e2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the data in the message.  <a href="#gaee251864355965b32fe3af9fa07e2419"></a><br/></td></tr>
<tr class="separator:gaee251864355965b32fe3af9fa07e2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5926dcf4e25e601ae0059b95afc5e226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5926dcf4e25e601ae0059b95afc5e226">XsMessage_copy</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *copy, <a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga5926dcf4e25e601ae0059b95afc5e226"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies from <em>thisPtr</em> to <em>copy</em>.  <a href="#ga5926dcf4e25e601ae0059b95afc5e226"></a><br/></td></tr>
<tr class="separator:ga5926dcf4e25e601ae0059b95afc5e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ca57ead95b63178f60835f2374039e"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa4ca57ead95b63178f60835f2374039e">XsMessage_dataSize</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:gaa4ca57ead95b63178f60835f2374039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the datasize of the message in <em>thisptr</em>.  <a href="#gaa4ca57ead95b63178f60835f2374039e"></a><br/></td></tr>
<tr class="separator:gaa4ca57ead95b63178f60835f2374039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02356a5cefd94aa7719c39ba9692b598"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga02356a5cefd94aa7719c39ba9692b598">XsMessage_constData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga02356a5cefd94aa7719c39ba9692b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a const pointer to the <em>offset</em> in the data of the message in <em>thisptr</em>.  <a href="#ga02356a5cefd94aa7719c39ba9692b598"></a><br/></td></tr>
<tr class="separator:ga02356a5cefd94aa7719c39ba9692b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ef5f47b2fe7bca6d550001b5b09296"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4ef5f47b2fe7bca6d550001b5b09296">XsMessage_getMessageStart</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:gad4ef5f47b2fe7bca6d550001b5b09296"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a const pointer to the header of the message in <em>thisptr</em>.  <a href="#gad4ef5f47b2fe7bca6d550001b5b09296"></a><br/></td></tr>
<tr class="separator:gad4ef5f47b2fe7bca6d550001b5b09296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd01bb00c8b697a56aafc443c1ddfd4"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5dd01bb00c8b697a56aafc443c1ddfd4">XsMessage_getTotalMessageSize</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga5dd01bb00c8b697a56aafc443c1ddfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the message buffer.  <a href="#ga5dd01bb00c8b697a56aafc443c1ddfd4"></a><br/></td></tr>
<tr class="separator:ga5dd01bb00c8b697a56aafc443c1ddfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ca4b85ce514c4688055917e7ec0591"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga91ca4b85ce514c4688055917e7ec0591">XsMessage_getDataByte</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga91ca4b85ce514c4688055917e7ec0591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte value at <em>offset</em> in the data of the message.  <a href="#ga91ca4b85ce514c4688055917e7ec0591"></a><br/></td></tr>
<tr class="separator:ga91ca4b85ce514c4688055917e7ec0591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc53fffde12da101d13f3528111e1dcf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc53fffde12da101d13f3528111e1dcf">XsMessage_getDataShort</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:gabc53fffde12da101d13f3528111e1dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the short value at <em>offset</em> in the data of the message.  <a href="#gabc53fffde12da101d13f3528111e1dcf"></a><br/></td></tr>
<tr class="separator:gabc53fffde12da101d13f3528111e1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d5a40697d57c0da08e1d21c82fb6e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga42d5a40697d57c0da08e1d21c82fb6e6">XsMessage_getDataLong</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga42d5a40697d57c0da08e1d21c82fb6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the long value at <em>offset</em> in the data of the message.  <a href="#ga42d5a40697d57c0da08e1d21c82fb6e6"></a><br/></td></tr>
<tr class="separator:ga42d5a40697d57c0da08e1d21c82fb6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd25a9320f3fbfabcd193bff5b5185c6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd25a9320f3fbfabcd193bff5b5185c6">XsMessage_getDataFloat</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:gafd25a9320f3fbfabcd193bff5b5185c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the float value at <em>offset</em> in the data of the message.  <a href="#gafd25a9320f3fbfabcd193bff5b5185c6"></a><br/></td></tr>
<tr class="separator:gafd25a9320f3fbfabcd193bff5b5185c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b548351bd3eb7e86187679ac83f572"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga73b548351bd3eb7e86187679ac83f572">XsMessage_getDataDouble</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga73b548351bd3eb7e86187679ac83f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double at <em>offset</em> in the data of the message.  <a href="#ga73b548351bd3eb7e86187679ac83f572"></a><br/></td></tr>
<tr class="separator:ga73b548351bd3eb7e86187679ac83f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf009aeda779d5955bba969390a1fe8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0cf009aeda779d5955bba969390a1fe8">XsMessage_getDataF1220</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga0cf009aeda779d5955bba969390a1fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the F12.20 value at <em>offset</em> in the data of the message.  <a href="#ga0cf009aeda779d5955bba969390a1fe8"></a><br/></td></tr>
<tr class="separator:ga0cf009aeda779d5955bba969390a1fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127c683e09b2db4ce8e161949e778bb1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga127c683e09b2db4ce8e161949e778bb1">XsMessage_getDataFP1632</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga127c683e09b2db4ce8e161949e778bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the F16.32 value at <em>offset</em> in the data of the message.  <a href="#ga127c683e09b2db4ce8e161949e778bb1"></a><br/></td></tr>
<tr class="separator:ga127c683e09b2db4ce8e161949e778bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1ab9a85f8b5c16a798d8920f1b69c8"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3e1ab9a85f8b5c16a798d8920f1b69c8">XsMessage_getDataBuffer</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, XsSize offset)</td></tr>
<tr class="memdesc:ga3e1ab9a85f8b5c16a798d8920f1b69c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data buffer of the message.  <a href="#ga3e1ab9a85f8b5c16a798d8920f1b69c8"></a><br/></td></tr>
<tr class="separator:ga3e1ab9a85f8b5c16a798d8920f1b69c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23c89aa06c089d2fec7a4d11c573fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa23c89aa06c089d2fec7a4d11c573fd5">XsMessage_setDataByte</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint8_t value, XsSize offset)</td></tr>
<tr class="memdesc:gaa23c89aa06c089d2fec7a4d11c573fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the byte at <em>offset</em> in the message to <em>value</em>.  <a href="#gaa23c89aa06c089d2fec7a4d11c573fd5"></a><br/></td></tr>
<tr class="separator:gaa23c89aa06c089d2fec7a4d11c573fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga359dc1326aa818e5168db40264d80502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga359dc1326aa818e5168db40264d80502">XsMessage_setDataShort</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint16_t value, XsSize offset)</td></tr>
<tr class="memdesc:ga359dc1326aa818e5168db40264d80502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the short at <em>offset</em> in the message to <em>value</em>.  <a href="#ga359dc1326aa818e5168db40264d80502"></a><br/></td></tr>
<tr class="separator:ga359dc1326aa818e5168db40264d80502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64de205a7a48f0b109856f2e105e7ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga64de205a7a48f0b109856f2e105e7ffa">XsMessage_setDataLong</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint32_t value, XsSize offset)</td></tr>
<tr class="memdesc:ga64de205a7a48f0b109856f2e105e7ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the long at <em>offset</em> in the message to <em>value</em>.  <a href="#ga64de205a7a48f0b109856f2e105e7ffa"></a><br/></td></tr>
<tr class="separator:ga64de205a7a48f0b109856f2e105e7ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1234b6e6d4411d8b0c702fa440841ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1234b6e6d4411d8b0c702fa440841ee9">XsMessage_setDataFloat</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, float value, XsSize offset)</td></tr>
<tr class="memdesc:ga1234b6e6d4411d8b0c702fa440841ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the float at <em>offset</em> in the message to <em>value</em>.  <a href="#ga1234b6e6d4411d8b0c702fa440841ee9"></a><br/></td></tr>
<tr class="separator:ga1234b6e6d4411d8b0c702fa440841ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga497e871bda0c859a73dfe1f1e29de6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga497e871bda0c859a73dfe1f1e29de6a1">XsMessage_setDataDouble</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, double value, XsSize offset)</td></tr>
<tr class="memdesc:ga497e871bda0c859a73dfe1f1e29de6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the double at <em>offset</em> in the message to <em>value</em>.  <a href="#ga497e871bda0c859a73dfe1f1e29de6a1"></a><br/></td></tr>
<tr class="separator:ga497e871bda0c859a73dfe1f1e29de6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366d27f459a11717add7e69ee6c85878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga366d27f459a11717add7e69ee6c85878">XsMessage_setDataF1220</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, double value, XsSize offset)</td></tr>
<tr class="memdesc:ga366d27f459a11717add7e69ee6c85878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the F12.20 at <em>offset</em> in the message to <em>value</em>.  <a href="#ga366d27f459a11717add7e69ee6c85878"></a><br/></td></tr>
<tr class="separator:ga366d27f459a11717add7e69ee6c85878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69a92d482776fa1c730e6dc1247e5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf69a92d482776fa1c730e6dc1247e5f7">XsMessage_setDataFP1632</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, double value, XsSize offset)</td></tr>
<tr class="memdesc:gaf69a92d482776fa1c730e6dc1247e5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the F16.32 at <em>offset</em> in the message to <em>value</em>.  <a href="#gaf69a92d482776fa1c730e6dc1247e5f7"></a><br/></td></tr>
<tr class="separator:gaf69a92d482776fa1c730e6dc1247e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68055a504cd3ad0108b216d7ec447fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab68055a504cd3ad0108b216d7ec447fe">XsMessage_setDataBuffer</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, const uint8_t *buffer, XsSize size, XsSize offset)</td></tr>
<tr class="memdesc:gab68055a504cd3ad0108b216d7ec447fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts <em>size</em> number of bytes from <em>buffer</em> into the message at <em>offset</em>.  <a href="#gab68055a504cd3ad0108b216d7ec447fe"></a><br/></td></tr>
<tr class="separator:gab68055a504cd3ad0108b216d7ec447fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c80c694ccbad9cc68b216a318a85463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1c80c694ccbad9cc68b216a318a85463">XsMessage_getDataFPValues</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, uint64_t outputSettings, double *dest, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:ga1c80c694ccbad9cc68b216a318a85463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current data values as a double(64 bits), after converting it from float, double, FP1632 or FP1220 depending on outputSettings.  <a href="#ga1c80c694ccbad9cc68b216a318a85463"></a><br/></td></tr>
<tr class="separator:ga1c80c694ccbad9cc68b216a318a85463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04bcae80049f7b33e84ebdffc116b321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga04bcae80049f7b33e84ebdffc116b321">XsMessage_setDataFPValues</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint64_t outputSettings, double const *data, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:ga04bcae80049f7b33e84ebdffc116b321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a floating/fixed point value into to the data buffer, conversion depends on outputSettings.  <a href="#ga04bcae80049f7b33e84ebdffc116b321"></a><br/></td></tr>
<tr class="separator:ga04bcae80049f7b33e84ebdffc116b321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0f330f1e8ff7b541f721dcf9211030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaae0f330f1e8ff7b541f721dcf9211030">XsMessage_getDataFPValuesById</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataIdentifier, double *dest, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:gaae0f330f1e8ff7b541f721dcf9211030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current data values as double, conversion depends on outputSetting.  <a href="#gaae0f330f1e8ff7b541f721dcf9211030"></a><br/></td></tr>
<tr class="separator:gaae0f330f1e8ff7b541f721dcf9211030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde1d1e334dbf921acf03ee0a25eada3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadde1d1e334dbf921acf03ee0a25eada3">XsMessage_setDataFPValuesById</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataIdentifier, double const *data, XsSize offset, XsSize numValues)</td></tr>
<tr class="memdesc:gadde1d1e334dbf921acf03ee0a25eada3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a number of floating/fixed point values into to the data buffer, conversion depends on outputSettings.  <a href="#gadde1d1e334dbf921acf03ee0a25eada3"></a><br/></td></tr>
<tr class="separator:gadde1d1e334dbf921acf03ee0a25eada3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd8840772ddc2616020b1723cf6ea01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bd8840772ddc2616020b1723cf6ea01"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8bd8840772ddc2616020b1723cf6ea01">XsMessage_computeChecksum</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga8bd8840772ddc2616020b1723cf6ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the checksum for the message. <br/></td></tr>
<tr class="separator:ga8bd8840772ddc2616020b1723cf6ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd92cdfd9e682b88fad7e05d69e937e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd92cdfd9e682b88fad7e05d69e937e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadd92cdfd9e682b88fad7e05d69e937e6">XsMessage_recomputeChecksum</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:gadd92cdfd9e682b88fad7e05d69e937e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the checksum for the message. <br/></td></tr>
<tr class="separator:gadd92cdfd9e682b88fad7e05d69e937e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7081af4eca1ef8996da037155ce72a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4f7081af4eca1ef8996da037155ce72a">XsMessage_isChecksumOk</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:ga4f7081af4eca1ef8996da037155ce72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the checksum inside the message is correct for the message, zero otherwise.  <a href="#ga4f7081af4eca1ef8996da037155ce72a"></a><br/></td></tr>
<tr class="separator:ga4f7081af4eca1ef8996da037155ce72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41551f9a7b226582620c95694009ec52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41551f9a7b226582620c95694009ec52"></a>
<a class="el" href="struct_xs_message_header.html">XsMessageHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga41551f9a7b226582620c95694009ec52">XsMessage_getHeader</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *)</td></tr>
<tr class="memdesc:ga41551f9a7b226582620c95694009ec52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the message header for this message. <br/></td></tr>
<tr class="separator:ga41551f9a7b226582620c95694009ec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06b9bc8c27a860d057a39d9c208c327"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_message_header.html">XsMessageHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac06b9bc8c27a860d057a39d9c208c327">XsMessage_getConstHeader</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="separator:gac06b9bc8c27a860d057a39d9c208c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07140d194f0089a8c40e7738d1622ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa07140d194f0089a8c40e7738d1622ff">XsMessage_empty</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *)</td></tr>
<tr class="memdesc:gaa07140d194f0089a8c40e7738d1622ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this message is empty.  <a href="#gaa07140d194f0089a8c40e7738d1622ff"></a><br/></td></tr>
<tr class="separator:gaa07140d194f0089a8c40e7738d1622ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a71f01ef77db025407f19e93dae9ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6a71f01ef77db025407f19e93dae9ac7">XsMessage_resizeData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize newSize)</td></tr>
<tr class="memdesc:ga6a71f01ef77db025407f19e93dae9ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the buffer of message to <em>newSize</em> bytes.  <a href="#ga6a71f01ef77db025407f19e93dae9ac7"></a><br/></td></tr>
<tr class="separator:ga6a71f01ef77db025407f19e93dae9ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf083ca2bf41d2efdd4fd224bc53c9fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf083ca2bf41d2efdd4fd224bc53c9fa9">XsMessage_setBusId</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, uint8_t busId)</td></tr>
<tr class="memdesc:gaf083ca2bf41d2efdd4fd224bc53c9fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bus id for this message to <em>busId</em>.  <a href="#gaf083ca2bf41d2efdd4fd224bc53c9fa9"></a><br/></td></tr>
<tr class="separator:gaf083ca2bf41d2efdd4fd224bc53c9fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235e41e089f2c0fc8860bf83df1311d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga235e41e089f2c0fc8860bf83df1311d7">XsMessage_setMessageId</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, enum <a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a> msgId)</td></tr>
<tr class="memdesc:ga235e41e089f2c0fc8860bf83df1311d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message id for this message to <em>msgId</em>.  <a href="#ga235e41e089f2c0fc8860bf83df1311d7"></a><br/></td></tr>
<tr class="separator:ga235e41e089f2c0fc8860bf83df1311d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4901534c43c5716f67f1b73ae215626e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4901534c43c5716f67f1b73ae215626e">XsMessage_insertData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize count, XsSize offset)</td></tr>
<tr class="memdesc:ga4901534c43c5716f67f1b73ae215626e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>count</em> bytes of empty space at <em>offset</em> in this message.  <a href="#ga4901534c43c5716f67f1b73ae215626e"></a><br/></td></tr>
<tr class="separator:ga4901534c43c5716f67f1b73ae215626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9212be8c3889701fad8c40da79822bac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9212be8c3889701fad8c40da79822bac">XsMessage_deleteData</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *, XsSize count, XsSize offset)</td></tr>
<tr class="memdesc:ga9212be8c3889701fad8c40da79822bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>count</em> bytes of data from the message at <em>offset</em>.  <a href="#ga9212be8c3889701fad8c40da79822bac"></a><br/></td></tr>
<tr class="separator:ga9212be8c3889701fad8c40da79822bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9e73d2db2d034d0ae1c3f95fb37cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0b9e73d2db2d034d0ae1c3f95fb37cce">XsMessage_swap</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> *a, <a class="el" href="struct_xs_message.html">XsMessage</a> *b)</td></tr>
<tr class="memdesc:ga0b9e73d2db2d034d0ae1c3f95fb37cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>.  <a href="#ga0b9e73d2db2d034d0ae1c3f95fb37cce"></a><br/></td></tr>
<tr class="separator:ga0b9e73d2db2d034d0ae1c3f95fb37cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3efc85d6f6a1062ed0bf6b07631886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d3efc85d6f6a1062ed0bf6b07631886"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7d3efc85d6f6a1062ed0bf6b07631886">XsMessage_compare</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const *a, <a class="el" href="struct_xs_message.html">XsMessage</a> const *b)</td></tr>
<tr class="memdesc:ga7d3efc85d6f6a1062ed0bf6b07631886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the contents of the messages <em>a</em> and <em>b</em>, returning non-0 if they are different. <br/></td></tr>
<tr class="separator:ga7d3efc85d6f6a1062ed0bf6b07631886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16769111ff0c7551dbad2a10c93e5f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga16769111ff0c7551dbad2a10c93e5f63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga16769111ff0c7551dbad2a10c93e5f63">XsPortInfo_swap</a> (struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *a, struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *b)</td></tr>
<tr class="memdesc:ga16769111ff0c7551dbad2a10c93e5f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with those of <em>b</em>. <br/></td></tr>
<tr class="separator:ga16769111ff0c7551dbad2a10c93e5f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245f337f50bcbfe350c38bf3f62fc3c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga245f337f50bcbfe350c38bf3f62fc3c8"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga245f337f50bcbfe350c38bf3f62fc3c8">XsResultValue_toString</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga245f337f50bcbfe350c38bf3f62fc3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a character string corresponding to the given result code. <br/></td></tr>
<tr class="separator:ga245f337f50bcbfe350c38bf3f62fc3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7edee3367aa5e0dae8e4723993e237d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab7edee3367aa5e0dae8e4723993e237d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab7edee3367aa5e0dae8e4723993e237d">XsRssi_max</a> ()</td></tr>
<tr class="memdesc:gab7edee3367aa5e0dae8e4723993e237d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum RSSI value. <br/></td></tr>
<tr class="separator:gab7edee3367aa5e0dae8e4723993e237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71878cde0d9365f603d79f773b8f9755"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71878cde0d9365f603d79f773b8f9755"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga71878cde0d9365f603d79f773b8f9755">XsRssi_unknown</a> ()</td></tr>
<tr class="memdesc:ga71878cde0d9365f603d79f773b8f9755"><td class="mdescLeft">&#160;</td><td class="mdescRight">The RSSI value that was reserved for when the RSSI is unknown. <br/></td></tr>
<tr class="separator:ga71878cde0d9365f603d79f773b8f9755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79baa392a62fc5e3ed73d351e4f2c403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga79baa392a62fc5e3ed73d351e4f2c403">XsRssi_unbiased</a> (int raw)</td></tr>
<tr class="memdesc:ga79baa392a62fc5e3ed73d351e4f2c403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw RSSI value transformed into a usable (unbiased) number.  <a href="#ga79baa392a62fc5e3ed73d351e4f2c403"></a><br/></td></tr>
<tr class="separator:ga79baa392a62fc5e3ed73d351e4f2c403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6eebe6760ce2044f7ea6f5f8939addb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6eebe6760ce2044f7ea6f5f8939addb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6eebe6760ce2044f7ea6f5f8939addb">XsSyncSetting_isInput</a> (const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *)</td></tr>
<tr class="memdesc:gae6eebe6760ce2044f7ea6f5f8939addb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the selected line is configured as an input line. <br/></td></tr>
<tr class="separator:gae6eebe6760ce2044f7ea6f5f8939addb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58c058ea42e07990af0f84da09d01b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf58c058ea42e07990af0f84da09d01b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf58c058ea42e07990af0f84da09d01b5">XsSyncSetting_isOutput</a> (const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *)</td></tr>
<tr class="memdesc:gaf58c058ea42e07990af0f84da09d01b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the selected line is configured as an output line. <br/></td></tr>
<tr class="separator:gaf58c058ea42e07990af0f84da09d01b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a9f04de91627ab245235b914c36d04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27a9f04de91627ab245235b914c36d04"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga27a9f04de91627ab245235b914c36d04">XsSyncSetting_swap</a> (<a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *a, <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> *b)</td></tr>
<tr class="memdesc:ga27a9f04de91627ab245235b914c36d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with <em>b</em>. <br/></td></tr>
<tr class="separator:ga27a9f04de91627ab245235b914c36d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54582842a30b1029a66050279844a3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac54582842a30b1029a66050279844a3b">XsTime_getTimeOfDay</a> (struct tm *date_, time_t *secs_)</td></tr>
<tr class="memdesc:gac54582842a30b1029a66050279844a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the current time of day in ms since midnight.  <a href="#gac54582842a30b1029a66050279844a3b"></a><br/></td></tr>
<tr class="separator:gac54582842a30b1029a66050279844a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae059db4e22b6f6d69ae31bb7291cd9f6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae059db4e22b6f6d69ae31bb7291cd9f6">XsTime_getDateTime</a> (struct tm *date)</td></tr>
<tr class="memdesc:gae059db4e22b6f6d69ae31bb7291cd9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the date and time (platform-independent)  <a href="#gae059db4e22b6f6d69ae31bb7291cd9f6"></a><br/></td></tr>
<tr class="separator:gae059db4e22b6f6d69ae31bb7291cd9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38505926760a0a5e7dd314e683ae546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae38505926760a0a5e7dd314e683ae546">XsTime_getDateAsString</a> (char *dest, const struct tm *date)</td></tr>
<tr class="memdesc:gae38505926760a0a5e7dd314e683ae546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the date as string representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }.  <a href="#gae38505926760a0a5e7dd314e683ae546"></a><br/></td></tr>
<tr class="separator:gae38505926760a0a5e7dd314e683ae546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb389fca2f6341c79b2262caf7a9d6d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafb389fca2f6341c79b2262caf7a9d6d7">XsTime_getTimeAsString</a> (char *dest, const struct tm *date)</td></tr>
<tr class="memdesc:gafb389fca2f6341c79b2262caf7a9d6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}.  <a href="#gafb389fca2f6341c79b2262caf7a9d6d7"></a><br/></td></tr>
<tr class="separator:gafb389fca2f6341c79b2262caf7a9d6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393705293aa555086514c8835ad019da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga393705293aa555086514c8835ad019da">XsTime_getDateAsWString</a> (wchar_t *dest, const struct tm *date)</td></tr>
<tr class="memdesc:ga393705293aa555086514c8835ad019da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the date as wstring representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }.  <a href="#ga393705293aa555086514c8835ad019da"></a><br/></td></tr>
<tr class="separator:ga393705293aa555086514c8835ad019da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga62a4f6afc1dbe845a1b6b09c9d4fbd1b">XsTime_getTimeAsWString</a> (wchar_t *dest, const struct tm *date)</td></tr>
<tr class="memdesc:ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}.  <a href="#ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"></a><br/></td></tr>
<tr class="separator:ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28efdfd01aad10c9da7baaeb6d7b8931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga28efdfd01aad10c9da7baaeb6d7b8931">XsTime_msleep</a> (uint32_t ms)</td></tr>
<tr class="memdesc:ga28efdfd01aad10c9da7baaeb6d7b8931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the current thread sleep for at least <em>ms</em> milliseconds.  <a href="#ga28efdfd01aad10c9da7baaeb6d7b8931"></a><br/></td></tr>
<tr class="separator:ga28efdfd01aad10c9da7baaeb6d7b8931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8268408ade85db6aa5f5a8bb56f00f75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8268408ade85db6aa5f5a8bb56f00f75">XsTime_udelay</a> (uint32_t us)</td></tr>
<tr class="memdesc:ga8268408ade85db6aa5f5a8bb56f00f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays the current thread for at least <em>us</em> microseconds.  <a href="#ga8268408ade85db6aa5f5a8bb56f00f75"></a><br/></td></tr>
<tr class="separator:ga8268408ade85db6aa5f5a8bb56f00f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d819f679819b2c2c6bc4f7a35f2dde"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga45d819f679819b2c2c6bc4f7a35f2dde">XsTime_timeStampNow</a> (<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *now)</td></tr>
<tr class="memdesc:ga45d819f679819b2c2c6bc4f7a35f2dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current time in ms since the epoch (Jan 1st 1970)  <a href="#ga45d819f679819b2c2c6bc4f7a35f2dde"></a><br/></td></tr>
<tr class="separator:ga45d819f679819b2c2c6bc4f7a35f2dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b31cc058a52b02959dc1b80e729fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf1b31cc058a52b02959dc1b80e729fa1">XsTime_initializeTime</a> ()</td></tr>
<tr class="memdesc:gaf1b31cc058a52b02959dc1b80e729fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stabilize the clock.  <a href="#gaf1b31cc058a52b02959dc1b80e729fa1"></a><br/></td></tr>
<tr class="separator:gaf1b31cc058a52b02959dc1b80e729fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa7a56622d27dbe74e9843a9c633217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2aa7a56622d27dbe74e9843a9c633217"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2aa7a56622d27dbe74e9843a9c633217">XsTriggerIndicationData_destruct</a> (<a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *)</td></tr>
<tr class="memdesc:ga2aa7a56622d27dbe74e9843a9c633217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the XsTriggerIndicationData object. <br/></td></tr>
<tr class="separator:ga2aa7a56622d27dbe74e9843a9c633217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9ccab13c489003637dc63769765d3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc9ccab13c489003637dc63769765d3a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc9ccab13c489003637dc63769765d3a">XsTriggerIndicationData_valid</a> (const <a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *)</td></tr>
<tr class="memdesc:gabc9ccab13c489003637dc63769765d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object is valid (line and polarity may not be 0) <br/></td></tr>
<tr class="separator:gabc9ccab13c489003637dc63769765d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f40f309a7a5e3aec100dc8414104c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa8f40f309a7a5e3aec100dc8414104c6">XsDataFlags_toString</a> (<a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a> f)</td></tr>
<tr class="memdesc:gaa8f40f309a7a5e3aec100dc8414104c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the XsDataFlags to a human readable string.  <a href="#gaa8f40f309a7a5e3aec100dc8414104c6"></a><br/></td></tr>
<tr class="separator:gaa8f40f309a7a5e3aec100dc8414104c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7db34fdc4f11bbad4aa6cc084013f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf7db34fdc4f11bbad4aa6cc084013f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaaf7db34fdc4f11bbad4aa6cc084013f0">XsDeviceConfiguration_construct</a> (<a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *)</td></tr>
<tr class="memdesc:gaaf7db34fdc4f11bbad4aa6cc084013f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the XsDeviceConfiguration object. <br/></td></tr>
<tr class="separator:gaaf7db34fdc4f11bbad4aa6cc084013f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f82f23864ce7afecff683cd244e62b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3f82f23864ce7afecff683cd244e62b1">XsDeviceConfiguration_assign</a> (<a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *, XsSize numberOfDevices, const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *src)</td></tr>
<tr class="memdesc:ga3f82f23864ce7afecff683cd244e62b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the XsDeviceConfiguration with space for <em>numberOfDevices</em> devices and copies them from <em>src</em>.  <a href="#ga3f82f23864ce7afecff683cd244e62b1"></a><br/></td></tr>
<tr class="separator:ga3f82f23864ce7afecff683cd244e62b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8512c801c9ba9226bd59379b8112a7c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8512c801c9ba9226bd59379b8112a7c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8512c801c9ba9226bd59379b8112a7c8">XsDeviceConfiguration_destruct</a> (<a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *)</td></tr>
<tr class="memdesc:ga8512c801c9ba9226bd59379b8112a7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and frees data in the XsDeviceConfiguration. <br/></td></tr>
<tr class="separator:ga8512c801c9ba9226bd59379b8112a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae75e3b6787af92d24e0661bfa60eb906"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae75e3b6787af92d24e0661bfa60eb906"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae75e3b6787af92d24e0661bfa60eb906">XsDeviceConfiguration_copy</a> (<a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *copy, <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> const *src)</td></tr>
<tr class="memdesc:gae75e3b6787af92d24e0661bfa60eb906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the XsDeviceConfiguration to <em>copy</em>. <br/></td></tr>
<tr class="separator:gae75e3b6787af92d24e0661bfa60eb906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edca1236b69b9dd0253c9ee218a0108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1edca1236b69b9dd0253c9ee218a0108">XsDeviceConfiguration_empty</a> (const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *)</td></tr>
<tr class="memdesc:ga1edca1236b69b9dd0253c9ee218a0108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> is empty.  <a href="#ga1edca1236b69b9dd0253c9ee218a0108"></a><br/></td></tr>
<tr class="separator:ga1edca1236b69b9dd0253c9ee218a0108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9938ca9ab7f27e7638e6d3b6f31821c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac9938ca9ab7f27e7638e6d3b6f31821c">XsDeviceConfiguration_readFromMessage</a> (<a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *, const <a class="el" href="struct_xs_message.html">XsMessage</a> *msg)</td></tr>
<tr class="memdesc:gac9938ca9ab7f27e7638e6d3b6f31821c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> based upon <em>msg</em>.  <a href="#gac9938ca9ab7f27e7638e6d3b6f31821c"></a><br/></td></tr>
<tr class="separator:gac9938ca9ab7f27e7638e6d3b6f31821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ced1d8bb9944a0dae2a91ab9eb8f3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4ced1d8bb9944a0dae2a91ab9eb8f3ed">XsDeviceConfiguration_writeToMessage</a> (const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *, <a class="el" href="struct_xs_message.html">XsMessage</a> *msg)</td></tr>
<tr class="memdesc:ga4ced1d8bb9944a0dae2a91ab9eb8f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a message <em>msg</em> that represents the XsDeviceConfiguration.  <a href="#ga4ced1d8bb9944a0dae2a91ab9eb8f3ed"></a><br/></td></tr>
<tr class="separator:ga4ced1d8bb9944a0dae2a91ab9eb8f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7222e508e1e5b424ba34648a4e31fd98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7222e508e1e5b424ba34648a4e31fd98">XsArray_construct</a> (void *, <a class="el" href="struct_xs_array_descriptor.html">XsArrayDescriptor</a> const *const descriptor, XsSize count, void const *src)</td></tr>
<tr class="memdesc:ga7222e508e1e5b424ba34648a4e31fd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>.  <a href="#ga7222e508e1e5b424ba34648a4e31fd98"></a><br/></td></tr>
<tr class="separator:ga7222e508e1e5b424ba34648a4e31fd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953d7cc7a9ecd8405f2d85b50edc0d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga953d7cc7a9ecd8405f2d85b50edc0d56">XsArray_copyConstruct</a> (void *, void const *src)</td></tr>
<tr class="memdesc:ga953d7cc7a9ecd8405f2d85b50edc0d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with a copy of <em>src</em>.  <a href="#ga953d7cc7a9ecd8405f2d85b50edc0d56"></a><br/></td></tr>
<tr class="separator:ga953d7cc7a9ecd8405f2d85b50edc0d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754df4d700d8f759e3dd29aca3ab629f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga754df4d700d8f759e3dd29aca3ab629f">XsArray_destruct</a> (void *)</td></tr>
<tr class="memdesc:ga754df4d700d8f759e3dd29aca3ab629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and frees memory allocated by the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a>.  <a href="#ga754df4d700d8f759e3dd29aca3ab629f"></a><br/></td></tr>
<tr class="separator:ga754df4d700d8f759e3dd29aca3ab629f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b75e01c27f76b4d91aaa135e4e1a5c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7b75e01c27f76b4d91aaa135e4e1a5c3">XsArray_assign</a> (void *, XsSize count, void const *src)</td></tr>
<tr class="memdesc:ga7b75e01c27f76b4d91aaa135e4e1a5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>.  <a href="#ga7b75e01c27f76b4d91aaa135e4e1a5c3"></a><br/></td></tr>
<tr class="separator:ga7b75e01c27f76b4d91aaa135e4e1a5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee0c5bdd163bb6ca4e295e4ae2f4d1bb">XsArray_resize</a> (void *, XsSize count)</td></tr>
<tr class="memdesc:gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the existing list to <em>count</em> items.  <a href="#gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"></a><br/></td></tr>
<tr class="separator:gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e7d83d6428ea82a43d4c44167e75c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9e7d83d6428ea82a43d4c44167e75c54">XsArray_reserve</a> (void *, XsSize count)</td></tr>
<tr class="memdesc:ga9e7d83d6428ea82a43d4c44167e75c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for <em>count</em> items.  <a href="#ga9e7d83d6428ea82a43d4c44167e75c54"></a><br/></td></tr>
<tr class="separator:ga9e7d83d6428ea82a43d4c44167e75c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913d8e0e6cd77c2384b236e634e1881e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga913d8e0e6cd77c2384b236e634e1881e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga913d8e0e6cd77c2384b236e634e1881e">XsArray_copy</a> (void *, void const *src)</td></tr>
<tr class="memdesc:ga913d8e0e6cd77c2384b236e634e1881e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <em>src</em> to thisArray. <br/></td></tr>
<tr class="separator:ga913d8e0e6cd77c2384b236e634e1881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6556d22268f56b6dbd77befdbdad0f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6556d22268f56b6dbd77befdbdad0f68">XsArray_append</a> (void *, void const *other)</td></tr>
<tr class="memdesc:ga6556d22268f56b6dbd77befdbdad0f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the <em>other</em> list to thisArray list.  <a href="#ga6556d22268f56b6dbd77befdbdad0f68"></a><br/></td></tr>
<tr class="separator:ga6556d22268f56b6dbd77befdbdad0f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1698369198b2417d5b5021a660281297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1698369198b2417d5b5021a660281297">XsArray_insert</a> (void *, XsSize index, XsSize count, void const *src)</td></tr>
<tr class="memdesc:ga1698369198b2417d5b5021a660281297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>count</em> items from <em>src</em> at <em>index</em> in the array.  <a href="#ga1698369198b2417d5b5021a660281297"></a><br/></td></tr>
<tr class="separator:ga1698369198b2417d5b5021a660281297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01697484c2c698f779345d64e199a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad01697484c2c698f779345d64e199a5f">XsArray_swap</a> (void *a, void *b)</td></tr>
<tr class="memdesc:gad01697484c2c698f779345d64e199a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> with those of <em>b</em>.  <a href="#gad01697484c2c698f779345d64e199a5f"></a><br/></td></tr>
<tr class="separator:gad01697484c2c698f779345d64e199a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24f468427e969e5a5daecb55cd36288"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf24f468427e969e5a5daecb55cd36288"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf24f468427e969e5a5daecb55cd36288">XsArray_erase</a> (void *, XsSize index, XsSize count)</td></tr>
<tr class="memdesc:gaf24f468427e969e5a5daecb55cd36288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a <em>count</em> items from the list starting at <em>index</em>. <br/></td></tr>
<tr class="separator:gaf24f468427e969e5a5daecb55cd36288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b78f3e6c2315d7e9741a9336781c49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga63b78f3e6c2315d7e9741a9336781c49">XsArray_compare</a> (void const *a, void const *b)</td></tr>
<tr class="memdesc:ga63b78f3e6c2315d7e9741a9336781c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the lists are different, 0 if they're equal.  <a href="#ga63b78f3e6c2315d7e9741a9336781c49"></a><br/></td></tr>
<tr class="separator:ga63b78f3e6c2315d7e9741a9336781c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72561edb500d3e01c3aeb40de6d6a3db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga72561edb500d3e01c3aeb40de6d6a3db">XsArray_compareSet</a> (void const *a, void const *b)</td></tr>
<tr class="memdesc:ga72561edb500d3e01c3aeb40de6d6a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns -1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal.  <a href="#ga72561edb500d3e01c3aeb40de6d6a3db"></a><br/></td></tr>
<tr class="separator:ga72561edb500d3e01c3aeb40de6d6a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6969403e331f28f7534cc2945ddcc09c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6969403e331f28f7534cc2945ddcc09c">XsArray_find</a> (void const *, void const *needle)</td></tr>
<tr class="memdesc:ga6969403e331f28f7534cc2945ddcc09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of <em>needle</em> in the list or -1 if it wasn't found.  <a href="#ga6969403e331f28f7534cc2945ddcc09c"></a><br/></td></tr>
<tr class="separator:ga6969403e331f28f7534cc2945ddcc09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de36061187ffca3834ee403bfaff57d"><td class="memItemLeft" align="right" valign="top">void const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4de36061187ffca3834ee403bfaff57d">XsArray_at</a> (void const *, XsSize index)</td></tr>
<tr class="memdesc:ga4de36061187ffca3834ee403bfaff57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds.  <a href="#ga4de36061187ffca3834ee403bfaff57d"></a><br/></td></tr>
<tr class="separator:ga4de36061187ffca3834ee403bfaff57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5004f8c9e45e57e43b09d6160648591c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5004f8c9e45e57e43b09d6160648591c">XsArray_atIndex</a> (void *, XsSize index)</td></tr>
<tr class="memdesc:ga5004f8c9e45e57e43b09d6160648591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds.  <a href="#ga5004f8c9e45e57e43b09d6160648591c"></a><br/></td></tr>
<tr class="separator:ga5004f8c9e45e57e43b09d6160648591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d1845c9e3d0e754c40807de07208d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac8d1845c9e3d0e754c40807de07208d4">XsArray_removeDuplicates</a> (void *)</td></tr>
<tr class="memdesc:gac8d1845c9e3d0e754c40807de07208d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate entries from the array, keeping only the first instance of each value.  <a href="#gac8d1845c9e3d0e754c40807de07208d4"></a><br/></td></tr>
<tr class="separator:gac8d1845c9e3d0e754c40807de07208d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f6206a9555aeb7b0531ee0a0f7f982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0f6206a9555aeb7b0531ee0a0f7f982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab0f6206a9555aeb7b0531ee0a0f7f982">XsCalibratedData_construct</a> (<a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *, const XsReal *acc, const XsReal *gyr, const XsReal *mag)</td></tr>
<tr class="memdesc:gab0f6206a9555aeb7b0531ee0a0f7f982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an XsCalibratedData object. <br/></td></tr>
<tr class="separator:gab0f6206a9555aeb7b0531ee0a0f7f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba56f16b16d32892d22e15007e4b8e5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba56f16b16d32892d22e15007e4b8e5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaba56f16b16d32892d22e15007e4b8e5d">XsCalibratedData_destruct</a> (<a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *)</td></tr>
<tr class="memdesc:gaba56f16b16d32892d22e15007e4b8e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct an XsCalibratedData object. <br/></td></tr>
<tr class="separator:gaba56f16b16d32892d22e15007e4b8e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a65a3767d1ed8441caf2006a58e71e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55a65a3767d1ed8441caf2006a58e71e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55a65a3767d1ed8441caf2006a58e71e">XsDataPacket_construct</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga55a65a3767d1ed8441caf2006a58e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits a data packet, the packet will be empty after construction. <br/></td></tr>
<tr class="separator:ga55a65a3767d1ed8441caf2006a58e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e364ab5254b2cc649d3ac8200fd729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2e364ab5254b2cc649d3ac8200fd729"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa2e364ab5254b2cc649d3ac8200fd729">XsDataPacket_destruct</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaa2e364ab5254b2cc649d3ac8200fd729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears and frees data in an <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a>. <br/></td></tr>
<tr class="separator:gaa2e364ab5254b2cc649d3ac8200fd729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7338c4a1f1b1f4ae4472e8ce30c175df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7338c4a1f1b1f4ae4472e8ce30c175df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7338c4a1f1b1f4ae4472e8ce30c175df">XsDataPacket_copy</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *copy, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *src)</td></tr>
<tr class="memdesc:ga7338c4a1f1b1f4ae4472e8ce30c175df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> to <em>copy</em>. <br/></td></tr>
<tr class="separator:ga7338c4a1f1b1f4ae4472e8ce30c175df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130c593fb6803da813074f4d63b8c044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga130c593fb6803da813074f4d63b8c044"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga130c593fb6803da813074f4d63b8c044">XsDataPacket_swap</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *a, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *b)</td></tr>
<tr class="memdesc:ga130c593fb6803da813074f4d63b8c044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the XsDataPackets in <em>a</em> and <em>b</em>. <br/></td></tr>
<tr class="separator:ga130c593fb6803da813074f4d63b8c044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad1448ea697088e9d77d1c2066309f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafad1448ea697088e9d77d1c2066309f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafad1448ea697088e9d77d1c2066309f4">XsDataPacket_empty</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gafad1448ea697088e9d77d1c2066309f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> is empty. <br/></td></tr>
<tr class="separator:gafad1448ea697088e9d77d1c2066309f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccc7556dbcc95a99751eca59d41b1001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaccc7556dbcc95a99751eca59d41b1001">XsDataPacket_itemOffsetMasked</a> (const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> mask)</td></tr>
<tr class="memdesc:gaccc7556dbcc95a99751eca59d41b1001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item offset of the supplied data identifier <em>id</em> using matching criteria specified by <em>mask</em>.  <a href="#gaccc7556dbcc95a99751eca59d41b1001"></a><br/></td></tr>
<tr class="separator:gaccc7556dbcc95a99751eca59d41b1001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9652cd8a68c2389fe27822e35d7d4fa9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9652cd8a68c2389fe27822e35d7d4fa9">XsDataPacket_itemOffsetExact</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:ga9652cd8a68c2389fe27822e35d7d4fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item offset of the supplied data identifier <em>id</em> using strict matching criteria.  <a href="#ga9652cd8a68c2389fe27822e35d7d4fa9"></a><br/></td></tr>
<tr class="separator:ga9652cd8a68c2389fe27822e35d7d4fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8965ee66cdb54fedb30532722588ba6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac8965ee66cdb54fedb30532722588ba6">XsDataPacket_itemOffsetLoose</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:gac8965ee66cdb54fedb30532722588ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the item offset of the supplied data identifier <em>id</em> using loose matching criteria.  <a href="#gac8965ee66cdb54fedb30532722588ba6"></a><br/></td></tr>
<tr class="separator:gac8965ee66cdb54fedb30532722588ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4598964d5372f185a2b67ba82846ee72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4598964d5372f185a2b67ba82846ee72">XsDataPacket_setMessage</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_message.html">XsMessage</a> *msg)</td></tr>
<tr class="memdesc:ga4598964d5372f185a2b67ba82846ee72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a message in a datapacket.  <a href="#ga4598964d5372f185a2b67ba82846ee72"></a><br/></td></tr>
<tr class="separator:ga4598964d5372f185a2b67ba82846ee72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00224a13a6b7220f43dacf6e90645298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00224a13a6b7220f43dacf6e90645298">XsDataPacket_dataFormat</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:ga00224a13a6b7220f43dacf6e90645298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dataformat of a specific data identifier in the packet.  <a href="#ga00224a13a6b7220f43dacf6e90645298"></a><br/></td></tr>
<tr class="separator:ga00224a13a6b7220f43dacf6e90645298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a782bc042f7cc6eb779d78aa5e20b0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae0a782bc042f7cc6eb779d78aa5e20b0">XsDataPacket_getFPValueSize</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> id)</td></tr>
<tr class="memdesc:gae0a782bc042f7cc6eb779d78aa5e20b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte size of <em>id</em> if the format is a floating point format.  <a href="#gae0a782bc042f7cc6eb779d78aa5e20b0"></a><br/></td></tr>
<tr class="separator:gae0a782bc042f7cc6eb779d78aa5e20b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f76199c6002f84e70d052f5734cd77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae0f76199c6002f84e70d052f5734cd77">XsDataPacket_rawAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:gae0f76199c6002f84e70d052f5734cd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw accelerometer component of a data item.  <a href="#gae0f76199c6002f84e70d052f5734cd77"></a><br/></td></tr>
<tr class="separator:gae0f76199c6002f84e70d052f5734cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cf09e402b3a79ae77f2f2b8319667f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab4cf09e402b3a79ae77f2f2b8319667f">XsDataPacket_containsRawAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gab4cf09e402b3a79ae77f2f2b8319667f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains Raw Accelerometer data.  <a href="#gab4cf09e402b3a79ae77f2f2b8319667f"></a><br/></td></tr>
<tr class="separator:gab4cf09e402b3a79ae77f2f2b8319667f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1939610911dbe628aa86fdaf60e191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c1939610911dbe628aa86fdaf60e191">XsDataPacket_setRawAcceleration</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:ga8c1939610911dbe628aa86fdaf60e191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw accelerometer data for the item.  <a href="#ga8c1939610911dbe628aa86fdaf60e191"></a><br/></td></tr>
<tr class="separator:ga8c1939610911dbe628aa86fdaf60e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5604d1a08bfcf788d9dc5cc5143f7008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5604d1a08bfcf788d9dc5cc5143f7008">XsDataPacket_rawGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga5604d1a08bfcf788d9dc5cc5143f7008"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw gyroscope component of a data item.  <a href="#ga5604d1a08bfcf788d9dc5cc5143f7008"></a><br/></td></tr>
<tr class="separator:ga5604d1a08bfcf788d9dc5cc5143f7008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41fa8c51bc0bdd7a948c26f29cb993a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf41fa8c51bc0bdd7a948c26f29cb993a">XsDataPacket_containsRawGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf41fa8c51bc0bdd7a948c26f29cb993a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw gyroscope data.  <a href="#gaf41fa8c51bc0bdd7a948c26f29cb993a"></a><br/></td></tr>
<tr class="separator:gaf41fa8c51bc0bdd7a948c26f29cb993a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c1378e3077524fc062c52fb75f6628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81c1378e3077524fc062c52fb75f6628"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga81c1378e3077524fc062c52fb75f6628">XsDataPacket_setRawGyroscopeData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:ga81c1378e3077524fc062c52fb75f6628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw gyroscope data for the item. <br/></td></tr>
<tr class="separator:ga81c1378e3077524fc062c52fb75f6628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d19682f28bbccf51ede5129a489308e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3d19682f28bbccf51ede5129a489308e">XsDataPacket_rawGyroscopeTemperatureData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga3d19682f28bbccf51ede5129a489308e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw gyroscope temperature component of a data item.  <a href="#ga3d19682f28bbccf51ede5129a489308e"></a><br/></td></tr>
<tr class="separator:ga3d19682f28bbccf51ede5129a489308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957722c94b3de10844beb19bceb9499f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga957722c94b3de10844beb19bceb9499f">XsDataPacket_containsRawGyroscopeTemperatureData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga957722c94b3de10844beb19bceb9499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw gyroscope temperature data.  <a href="#ga957722c94b3de10844beb19bceb9499f"></a><br/></td></tr>
<tr class="separator:ga957722c94b3de10844beb19bceb9499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d63654f139445c87dbfc6c861eb6d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5d63654f139445c87dbfc6c861eb6d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac5d63654f139445c87dbfc6c861eb6d7">XsDataPacket_setRawGyroscopeTemperatureData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:gac5d63654f139445c87dbfc6c861eb6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw gyroscope temperature data for the item. <br/></td></tr>
<tr class="separator:gac5d63654f139445c87dbfc6c861eb6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c11ad29680b10e01f52a0f140554be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae5c11ad29680b10e01f52a0f140554be">XsDataPacket_rawMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *returnVal)</td></tr>
<tr class="memdesc:gae5c11ad29680b10e01f52a0f140554be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw magnetometer component of a data item.  <a href="#gae5c11ad29680b10e01f52a0f140554be"></a><br/></td></tr>
<tr class="separator:gae5c11ad29680b10e01f52a0f140554be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd354b23b58b9a25af2ed141dd4ba48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabbd354b23b58b9a25af2ed141dd4ba48">XsDataPacket_containsRawMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gabbd354b23b58b9a25af2ed141dd4ba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw magnetometer data.  <a href="#gabbd354b23b58b9a25af2ed141dd4ba48"></a><br/></td></tr>
<tr class="separator:gabbd354b23b58b9a25af2ed141dd4ba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b26c0dc6409162565f02eafb2287149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b26c0dc6409162565f02eafb2287149"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9b26c0dc6409162565f02eafb2287149">XsDataPacket_setRawMagneticField</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *vec)</td></tr>
<tr class="memdesc:ga9b26c0dc6409162565f02eafb2287149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw magnetometer data for the item. <br/></td></tr>
<tr class="separator:ga9b26c0dc6409162565f02eafb2287149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb399f7bef85d6305b33a8c2a8dc9aa2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeb399f7bef85d6305b33a8c2a8dc9aa2">XsDataPacket_rawTemperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaeb399f7bef85d6305b33a8c2a8dc9aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw temperature component of a data item.  <a href="#gaeb399f7bef85d6305b33a8c2a8dc9aa2"></a><br/></td></tr>
<tr class="separator:gaeb399f7bef85d6305b33a8c2a8dc9aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33c1f5eb46f0e30ecbdb2f5f3f52680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae33c1f5eb46f0e30ecbdb2f5f3f52680">XsDataPacket_containsRawTemperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gae33c1f5eb46f0e30ecbdb2f5f3f52680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw temperature data.  <a href="#gae33c1f5eb46f0e30ecbdb2f5f3f52680"></a><br/></td></tr>
<tr class="separator:gae33c1f5eb46f0e30ecbdb2f5f3f52680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab006ecad31d746626d1c5057582b09bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab006ecad31d746626d1c5057582b09bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab006ecad31d746626d1c5057582b09bd">XsDataPacket_setRawTemperature</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint16_t temp)</td></tr>
<tr class="memdesc:gab006ecad31d746626d1c5057582b09bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw temperature data for the item. <br/></td></tr>
<tr class="separator:gab006ecad31d746626d1c5057582b09bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d926a63a4e5dae27263e34bb9cc50d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d926a63a4e5dae27263e34bb9cc50d5"></a>
<a class="el" href="struct_xs_scr_data.html">XsScrData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1d926a63a4e5dae27263e34bb9cc50d5">XsDataPacket_rawData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_scr_data.html">XsScrData</a> *returnVal)</td></tr>
<tr class="memdesc:ga1d926a63a4e5dae27263e34bb9cc50d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw data component of a data item. <br/></td></tr>
<tr class="separator:ga1d926a63a4e5dae27263e34bb9cc50d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga517f271754bceccef3989b9b9d939755"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga517f271754bceccef3989b9b9d939755">XsDataPacket_containsRawData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga517f271754bceccef3989b9b9d939755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains raw data.  <a href="#ga517f271754bceccef3989b9b9d939755"></a><br/></td></tr>
<tr class="separator:ga517f271754bceccef3989b9b9d939755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab04d9286516b3281256dd9b6d88c2031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab04d9286516b3281256dd9b6d88c2031"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab04d9286516b3281256dd9b6d88c2031">XsDataPacket_setRawData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_scr_data.html">XsScrData</a> *data)</td></tr>
<tr class="memdesc:gab04d9286516b3281256dd9b6d88c2031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update raw data for the item. <br/></td></tr>
<tr class="separator:gab04d9286516b3281256dd9b6d88c2031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fddb259bdabf11dcc062770c50f0fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5fddb259bdabf11dcc062770c50f0fb1">XsDataPacket_calibratedAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga5fddb259bdabf11dcc062770c50f0fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calibrated accelerometer component of a data item.  <a href="#ga5fddb259bdabf11dcc062770c50f0fb1"></a><br/></td></tr>
<tr class="separator:ga5fddb259bdabf11dcc062770c50f0fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97126b54948708a4fe4396ed6c1c377f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga97126b54948708a4fe4396ed6c1c377f">XsDataPacket_containsCalibratedAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga97126b54948708a4fe4396ed6c1c377f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated accelerometer data.  <a href="#ga97126b54948708a4fe4396ed6c1c377f"></a><br/></td></tr>
<tr class="separator:ga97126b54948708a4fe4396ed6c1c377f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc4c405eae162395d8b1216742bb3d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabdc4c405eae162395d8b1216742bb3d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabdc4c405eae162395d8b1216742bb3d5">XsDataPacket_setCalibratedAcceleration</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *vec)</td></tr>
<tr class="memdesc:gabdc4c405eae162395d8b1216742bb3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated accelerometer data for the item. <br/></td></tr>
<tr class="separator:gabdc4c405eae162395d8b1216742bb3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f8510e32c5ce64be24aa4e4357977c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga48f8510e32c5ce64be24aa4e4357977c">XsDataPacket_calibratedGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga48f8510e32c5ce64be24aa4e4357977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calibrated gyroscope component of a data item.  <a href="#ga48f8510e32c5ce64be24aa4e4357977c"></a><br/></td></tr>
<tr class="separator:ga48f8510e32c5ce64be24aa4e4357977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ed952bed9c7ca76e937ce062a09fe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga60ed952bed9c7ca76e937ce062a09fe9">XsDataPacket_containsCalibratedGyroscopeData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga60ed952bed9c7ca76e937ce062a09fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated gyroscope data.  <a href="#ga60ed952bed9c7ca76e937ce062a09fe9"></a><br/></td></tr>
<tr class="separator:ga60ed952bed9c7ca76e937ce062a09fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b29dfe4997c15a16cc47524353a0b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5b29dfe4997c15a16cc47524353a0b00">XsDataPacket_calibratedMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga5b29dfe4997c15a16cc47524353a0b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calibrated magnetometer component of a data item.  <a href="#ga5b29dfe4997c15a16cc47524353a0b00"></a><br/></td></tr>
<tr class="separator:ga5b29dfe4997c15a16cc47524353a0b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4578f0373d56a4f810bd2b11c75660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaef4578f0373d56a4f810bd2b11c75660">XsDataPacket_containsCalibratedMagneticField</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaef4578f0373d56a4f810bd2b11c75660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated magnetometer data.  <a href="#gaef4578f0373d56a4f810bd2b11c75660"></a><br/></td></tr>
<tr class="separator:gaef4578f0373d56a4f810bd2b11c75660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8823e4c2ac88b96fad3a51ccb728828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8823e4c2ac88b96fad3a51ccb728828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae8823e4c2ac88b96fad3a51ccb728828">XsDataPacket_setCalibratedMagneticField</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *vec)</td></tr>
<tr class="memdesc:gae8823e4c2ac88b96fad3a51ccb728828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated magnetometer data for the item. <br/></td></tr>
<tr class="separator:gae8823e4c2ac88b96fad3a51ccb728828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6048d525e0e5e7bb504d7a7c08ebb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc6048d525e0e5e7bb504d7a7c08ebb3">XsDataPacket_calibratedData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *returnVal)</td></tr>
<tr class="memdesc:gabc6048d525e0e5e7bb504d7a7c08ebb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the calibrated Data component of a data item.  <a href="#gabc6048d525e0e5e7bb504d7a7c08ebb3"></a><br/></td></tr>
<tr class="separator:gabc6048d525e0e5e7bb504d7a7c08ebb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c01a1ed158b5e3537fe702377611f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga87c01a1ed158b5e3537fe702377611f1">XsDataPacket_containsCalibratedData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga87c01a1ed158b5e3537fe702377611f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains calibrated Data.  <a href="#ga87c01a1ed158b5e3537fe702377611f1"></a><br/></td></tr>
<tr class="separator:ga87c01a1ed158b5e3537fe702377611f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7045ddceec8b9a1f687d142d498ed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee7045ddceec8b9a1f687d142d498ed1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee7045ddceec8b9a1f687d142d498ed1">XsDataPacket_setCalibratedData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *data)</td></tr>
<tr class="memdesc:gaee7045ddceec8b9a1f687d142d498ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update calibrated Data for the item. <br/></td></tr>
<tr class="separator:gaee7045ddceec8b9a1f687d142d498ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0149c98d71b9bfe8803485775d41f0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0149c98d71b9bfe8803485775d41f0ac">XsDataPacket_orientationQuaternion</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga0149c98d71b9bfe8803485775d41f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation component of a data item as a quaternion.  <a href="#ga0149c98d71b9bfe8803485775d41f0ac"></a><br/></td></tr>
<tr class="separator:ga0149c98d71b9bfe8803485775d41f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929523109044e36d1b1177d8111c0db5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga929523109044e36d1b1177d8111c0db5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga929523109044e36d1b1177d8111c0db5">XsDataPacket_setOrientationQuaternion</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga929523109044e36d1b1177d8111c0db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update quaternion orientation Data for the item. <br/></td></tr>
<tr class="separator:ga929523109044e36d1b1177d8111c0db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1605983648c9e678da6b2e04213293d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_euler.html">XsEuler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf1605983648c9e678da6b2e04213293d">XsDataPacket_orientationEuler</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_euler.html">XsEuler</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:gaf1605983648c9e678da6b2e04213293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation component of a data item as a euler angles.  <a href="#gaf1605983648c9e678da6b2e04213293d"></a><br/></td></tr>
<tr class="separator:gaf1605983648c9e678da6b2e04213293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga932baacb21362e29fe602a994b54d5f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga932baacb21362e29fe602a994b54d5f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga932baacb21362e29fe602a994b54d5f2">XsDataPacket_setOrientationEuler</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_euler.html">XsEuler</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga932baacb21362e29fe602a994b54d5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update quaternion orientation Data for the item. <br/></td></tr>
<tr class="separator:ga932baacb21362e29fe602a994b54d5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f622e95ca566c0e8627b6b5a362d9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3f622e95ca566c0e8627b6b5a362d9d8">XsDataPacket_orientationMatrix</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga3f622e95ca566c0e8627b6b5a362d9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the orientation component of a data item as a orientation matrix.  <a href="#ga3f622e95ca566c0e8627b6b5a362d9d8"></a><br/></td></tr>
<tr class="separator:ga3f622e95ca566c0e8627b6b5a362d9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afbdb8e359c44d57614bfa059b4ebdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4afbdb8e359c44d57614bfa059b4ebdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4afbdb8e359c44d57614bfa059b4ebdd">XsDataPacket_setOrientationMatrix</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:ga4afbdb8e359c44d57614bfa059b4ebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update quaternion orientation Data for the item. <br/></td></tr>
<tr class="separator:ga4afbdb8e359c44d57614bfa059b4ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7c3cdac9092bcabd206fb6a634919d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaca7c3cdac9092bcabd206fb6a634919d">XsDataPacket_containsOrientation</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaca7c3cdac9092bcabd206fb6a634919d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains orientation Data of any kind.  <a href="#gaca7c3cdac9092bcabd206fb6a634919d"></a><br/></td></tr>
<tr class="separator:gaca7c3cdac9092bcabd206fb6a634919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47cd95b1d759e97eecca58161eeee5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad47cd95b1d759e97eecca58161eeee5b">XsDataPacket_orientationIdentifier</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad47cd95b1d759e97eecca58161eeee5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data identifier of the first orientation data of any kind in the packet.  <a href="#gad47cd95b1d759e97eecca58161eeee5b"></a><br/></td></tr>
<tr class="separator:gad47cd95b1d759e97eecca58161eeee5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33cedaf486f7ea05478fc1891dbd59e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab33cedaf486f7ea05478fc1891dbd59e">XsDataPacket_coordinateSystemOrientation</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gab33cedaf486f7ea05478fc1891dbd59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate system of the first orientation data of any kind in the packet.  <a href="#gab33cedaf486f7ea05478fc1891dbd59e"></a><br/></td></tr>
<tr class="separator:gab33cedaf486f7ea05478fc1891dbd59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159f5666dafb668580256c6af709dce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga159f5666dafb668580256c6af709dce6">XsDataPacket_gpsPvtData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *returnVal)</td></tr>
<tr class="memdesc:ga159f5666dafb668580256c6af709dce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gps PVT data component of a data item.  <a href="#ga159f5666dafb668580256c6af709dce6"></a><br/></td></tr>
<tr class="separator:ga159f5666dafb668580256c6af709dce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4592f786dece1c41d0a2c480cc83338d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4592f786dece1c41d0a2c480cc83338d">XsDataPacket_containsGpsPvtData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga4592f786dece1c41d0a2c480cc83338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains gps PVT data.  <a href="#ga4592f786dece1c41d0a2c480cc83338d"></a><br/></td></tr>
<tr class="separator:ga4592f786dece1c41d0a2c480cc83338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9674a10af2e9f0f25da5afb1ea569893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9674a10af2e9f0f25da5afb1ea569893">XsDataPacket_setGpsPvtData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *data)</td></tr>
<tr class="memdesc:ga9674a10af2e9f0f25da5afb1ea569893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update gps PVT data for the item.  <a href="#ga9674a10af2e9f0f25da5afb1ea569893"></a><br/></td></tr>
<tr class="separator:ga9674a10af2e9f0f25da5afb1ea569893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47889699665bb08e201fae0f3e6eb984"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga47889699665bb08e201fae0f3e6eb984">XsDataPacket_containsPressure</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga47889699665bb08e201fae0f3e6eb984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains pressure data.  <a href="#ga47889699665bb08e201fae0f3e6eb984"></a><br/></td></tr>
<tr class="separator:ga47889699665bb08e201fae0f3e6eb984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45a927643b25f86b659ee60784590c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf45a927643b25f86b659ee60784590c3">XsDataPacket_containsPressureAge</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf45a927643b25f86b659ee60784590c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains pressure age data.  <a href="#gaf45a927643b25f86b659ee60784590c3"></a><br/></td></tr>
<tr class="separator:gaf45a927643b25f86b659ee60784590c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb5562328d6b7612efb2263f9216f444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_pressure.html">XsPressure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gacb5562328d6b7612efb2263f9216f444">XsDataPacket_pressure</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_pressure.html">XsPressure</a> *returnVal)</td></tr>
<tr class="memdesc:gacb5562328d6b7612efb2263f9216f444"><td class="mdescLeft">&#160;</td><td class="mdescRight">The air pressure component of a data item.  <a href="#gacb5562328d6b7612efb2263f9216f444"></a><br/></td></tr>
<tr class="separator:gacb5562328d6b7612efb2263f9216f444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01accfac8d7a667e248a4df83b07721f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01accfac8d7a667e248a4df83b07721f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga01accfac8d7a667e248a4df83b07721f">XsDataPacket_setPressure</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_pressure.html">XsPressure</a> *data)</td></tr>
<tr class="memdesc:ga01accfac8d7a667e248a4df83b07721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update pressure data for the item. <br/></td></tr>
<tr class="separator:ga01accfac8d7a667e248a4df83b07721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954395b7b5af631e31e9b0493acec7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga954395b7b5af631e31e9b0493acec7b2">XsDataPacket_sdiData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *returnVal)</td></tr>
<tr class="memdesc:ga954395b7b5af631e31e9b0493acec7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the strapdown integration data component of a data item.  <a href="#ga954395b7b5af631e31e9b0493acec7b2"></a><br/></td></tr>
<tr class="separator:ga954395b7b5af631e31e9b0493acec7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5ecc04a489160f62f261de66a02497"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6f5ecc04a489160f62f261de66a02497">XsDataPacket_containsSdiData</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga6f5ecc04a489160f62f261de66a02497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains strapdown integration data.  <a href="#ga6f5ecc04a489160f62f261de66a02497"></a><br/></td></tr>
<tr class="separator:ga6f5ecc04a489160f62f261de66a02497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52705223ff52de6e52f0f8746da3d2da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga52705223ff52de6e52f0f8746da3d2da">XsDataPacket_setSdiData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *data)</td></tr>
<tr class="memdesc:ga52705223ff52de6e52f0f8746da3d2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update strapdown integration data for the item.  <a href="#ga52705223ff52de6e52f0f8746da3d2da"></a><br/></td></tr>
<tr class="separator:ga52705223ff52de6e52f0f8746da3d2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d218f313dc1be12638fd38d9fe39a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac6d218f313dc1be12638fd38d9fe39a9">XsDataPacket_temperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac6d218f313dc1be12638fd38d9fe39a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The temperature component of a data item.  <a href="#gac6d218f313dc1be12638fd38d9fe39a9"></a><br/></td></tr>
<tr class="separator:gac6d218f313dc1be12638fd38d9fe39a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a768d2f6b29b740b110e869b54f682b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3a768d2f6b29b740b110e869b54f682b">XsDataPacket_containsTemperature</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga3a768d2f6b29b740b110e869b54f682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains temperature data.  <a href="#ga3a768d2f6b29b740b110e869b54f682b"></a><br/></td></tr>
<tr class="separator:ga3a768d2f6b29b740b110e869b54f682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecd3755ae9c05a6e03db67ae8fa6a178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaecd3755ae9c05a6e03db67ae8fa6a178">XsDataPacket_setTemperature</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, double temperature)</td></tr>
<tr class="memdesc:gaecd3755ae9c05a6e03db67ae8fa6a178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds or updates the temperature data in the datapacket.  <a href="#gaecd3755ae9c05a6e03db67ae8fa6a178"></a><br/></td></tr>
<tr class="separator:gaecd3755ae9c05a6e03db67ae8fa6a178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984fcbb151bb425bed68fd15f214e530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga984fcbb151bb425bed68fd15f214e530">XsDataPacket_analogIn1Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *returnVal)</td></tr>
<tr class="memdesc:ga984fcbb151bb425bed68fd15f214e530"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analog in 1 component of a data item.  <a href="#ga984fcbb151bb425bed68fd15f214e530"></a><br/></td></tr>
<tr class="separator:ga984fcbb151bb425bed68fd15f214e530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e15bfb90ba4a319b147edd5c69b093f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5e15bfb90ba4a319b147edd5c69b093f">XsDataPacket_containsAnalogIn1Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga5e15bfb90ba4a319b147edd5c69b093f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains analog in 1 data.  <a href="#ga5e15bfb90ba4a319b147edd5c69b093f"></a><br/></td></tr>
<tr class="separator:ga5e15bfb90ba4a319b147edd5c69b093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9952a87a8aa302aa872a7c88ff9186b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9952a87a8aa302aa872a7c88ff9186b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9952a87a8aa302aa872a7c88ff9186b4">XsDataPacket_setAnalogIn1Data</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *data)</td></tr>
<tr class="memdesc:ga9952a87a8aa302aa872a7c88ff9186b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update analog in 1 data for the item. <br/></td></tr>
<tr class="separator:ga9952a87a8aa302aa872a7c88ff9186b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742702ec9806c8ce2ad92d3e3bdab699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga742702ec9806c8ce2ad92d3e3bdab699">XsDataPacket_analogIn2Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *returnVal)</td></tr>
<tr class="memdesc:ga742702ec9806c8ce2ad92d3e3bdab699"><td class="mdescLeft">&#160;</td><td class="mdescRight">The analog in 2 component of a data item.  <a href="#ga742702ec9806c8ce2ad92d3e3bdab699"></a><br/></td></tr>
<tr class="separator:ga742702ec9806c8ce2ad92d3e3bdab699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b909a7cf3d951bd587e462167ed8943"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6b909a7cf3d951bd587e462167ed8943">XsDataPacket_containsAnalogIn2Data</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga6b909a7cf3d951bd587e462167ed8943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains analog in 2 data.  <a href="#ga6b909a7cf3d951bd587e462167ed8943"></a><br/></td></tr>
<tr class="separator:ga6b909a7cf3d951bd587e462167ed8943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61d05432a6a3d927280be031911fbed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab61d05432a6a3d927280be031911fbed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab61d05432a6a3d927280be031911fbed">XsDataPacket_setAnalogIn2Data</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *data)</td></tr>
<tr class="memdesc:gab61d05432a6a3d927280be031911fbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update analog in 2 data for the item. <br/></td></tr>
<tr class="separator:gab61d05432a6a3d927280be031911fbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45af0d8bfc4107fb0c09640cbda1f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa45af0d8bfc4107fb0c09640cbda1f09">XsDataPacket_positionLLA</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:gaa45af0d8bfc4107fb0c09640cbda1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position lat lon alt component of a data item.  <a href="#gaa45af0d8bfc4107fb0c09640cbda1f09"></a><br/></td></tr>
<tr class="separator:gaa45af0d8bfc4107fb0c09640cbda1f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3fd8178e684cfe66bb696540bab029d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3fd8178e684cfe66bb696540bab029d">XsDataPacket_containsPositionLLA</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf3fd8178e684cfe66bb696540bab029d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains position lat lon alt data.  <a href="#gaf3fd8178e684cfe66bb696540bab029d"></a><br/></td></tr>
<tr class="separator:gaf3fd8178e684cfe66bb696540bab029d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20fd010f517f69c99199f28a43474a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga20fd010f517f69c99199f28a43474a3c">XsDataPacket_setPositionLLA</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *data)</td></tr>
<tr class="memdesc:ga20fd010f517f69c99199f28a43474a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update position lat lon alt data for the item.  <a href="#ga20fd010f517f69c99199f28a43474a3c"></a><br/></td></tr>
<tr class="separator:ga20fd010f517f69c99199f28a43474a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74073fd7f88c1d458c6fbb4314d041b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga74073fd7f88c1d458c6fbb4314d041b9">XsDataPacket_latitudeLongitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga74073fd7f88c1d458c6fbb4314d041b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position latitude longitude component of a data item.  <a href="#ga74073fd7f88c1d458c6fbb4314d041b9"></a><br/></td></tr>
<tr class="separator:ga74073fd7f88c1d458c6fbb4314d041b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84873964429e40c3dec1ad5f5cbff300"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga84873964429e40c3dec1ad5f5cbff300">XsDataPacket_containsLatitudeLongitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga84873964429e40c3dec1ad5f5cbff300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains position latitude longitude data.  <a href="#ga84873964429e40c3dec1ad5f5cbff300"></a><br/></td></tr>
<tr class="separator:ga84873964429e40c3dec1ad5f5cbff300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99054a34e98f315e4fd31b6be56a97a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga99054a34e98f315e4fd31b6be56a97a9">XsDataPacket_setLatitudeLongitude</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *data)</td></tr>
<tr class="memdesc:ga99054a34e98f315e4fd31b6be56a97a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update position latitude longitude data for the item.  <a href="#ga99054a34e98f315e4fd31b6be56a97a9"></a><br/></td></tr>
<tr class="separator:ga99054a34e98f315e4fd31b6be56a97a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bb2c43334630ab37781b05d5a0a076"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf1bb2c43334630ab37781b05d5a0a076">XsDataPacket_altitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf1bb2c43334630ab37781b05d5a0a076"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position altitude component of a data item.  <a href="#gaf1bb2c43334630ab37781b05d5a0a076"></a><br/></td></tr>
<tr class="separator:gaf1bb2c43334630ab37781b05d5a0a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17e37b4198366ef799fac69e4301ee9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf17e37b4198366ef799fac69e4301ee9">XsDataPacket_containsAltitude</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaf17e37b4198366ef799fac69e4301ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains position altitude data.  <a href="#gaf17e37b4198366ef799fac69e4301ee9"></a><br/></td></tr>
<tr class="separator:gaf17e37b4198366ef799fac69e4301ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeffa2fd1c18474fe885b643abb25399f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaeffa2fd1c18474fe885b643abb25399f">XsDataPacket_setAltitude</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, double data)</td></tr>
<tr class="memdesc:gaeffa2fd1c18474fe885b643abb25399f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update altitude data for the item.  <a href="#gaeffa2fd1c18474fe885b643abb25399f"></a><br/></td></tr>
<tr class="separator:gaeffa2fd1c18474fe885b643abb25399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11d6d994aa40c6f8277081ecadb9216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa11d6d994aa40c6f8277081ecadb9216">XsDataPacket_velocity</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:gaa11d6d994aa40c6f8277081ecadb9216"><td class="mdescLeft">&#160;</td><td class="mdescRight">The velocity NWU component of a data item.  <a href="#gaa11d6d994aa40c6f8277081ecadb9216"></a><br/></td></tr>
<tr class="separator:gaa11d6d994aa40c6f8277081ecadb9216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075b55f7591d36c2eb93bf4b5e6690fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga075b55f7591d36c2eb93bf4b5e6690fe">XsDataPacket_containsVelocity</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga075b55f7591d36c2eb93bf4b5e6690fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains velocity NED data.  <a href="#ga075b55f7591d36c2eb93bf4b5e6690fe"></a><br/></td></tr>
<tr class="separator:ga075b55f7591d36c2eb93bf4b5e6690fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa48af71aaba108c0b6bde089d74fc2b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa48af71aaba108c0b6bde089d74fc2b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa48af71aaba108c0b6bde089d74fc2b0">XsDataPacket_setVelocity</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *data, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> coordinateSystem)</td></tr>
<tr class="memdesc:gaa48af71aaba108c0b6bde089d74fc2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update velocity NED data for the item. <br/></td></tr>
<tr class="separator:gaa48af71aaba108c0b6bde089d74fc2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b78a321c23bc634ccfe41730e748824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1b78a321c23bc634ccfe41730e748824">XsDataPacket_velocityIdentifier</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga1b78a321c23bc634ccfe41730e748824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data identifier of the first velocity data of any kind in the packet.  <a href="#ga1b78a321c23bc634ccfe41730e748824"></a><br/></td></tr>
<tr class="separator:ga1b78a321c23bc634ccfe41730e748824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb8f791a622d1594b2985a89101e975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0bb8f791a622d1594b2985a89101e975">XsDataPacket_coordinateSystemVelocity</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga0bb8f791a622d1594b2985a89101e975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate system of the first velocity data of any kind in the packet.  <a href="#ga0bb8f791a622d1594b2985a89101e975"></a><br/></td></tr>
<tr class="separator:ga0bb8f791a622d1594b2985a89101e975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8aad732d8ba37df041168b8aa256a49"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad8aad732d8ba37df041168b8aa256a49">XsDataPacket_status</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad8aad732d8ba37df041168b8aa256a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status component of a data item.  <a href="#gad8aad732d8ba37df041168b8aa256a49"></a><br/></td></tr>
<tr class="separator:gad8aad732d8ba37df041168b8aa256a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb321aba93424a38c986c10972bb4b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabdb321aba93424a38c986c10972bb4b5">XsDataPacket_containsStatusByte</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gabdb321aba93424a38c986c10972bb4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns wether the XsDataPacket contains a statusbyte.  <a href="#gabdb321aba93424a38c986c10972bb4b5"></a><br/></td></tr>
<tr class="separator:gabdb321aba93424a38c986c10972bb4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1713a40540a9d9e74feddde498b429b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad1713a40540a9d9e74feddde498b429b">XsDataPacket_containsStatus</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad1713a40540a9d9e74feddde498b429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains legacy status data.  <a href="#gad1713a40540a9d9e74feddde498b429b"></a><br/></td></tr>
<tr class="separator:gad1713a40540a9d9e74feddde498b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ac53ce205dd1188f542d68cfe4489d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga74ac53ce205dd1188f542d68cfe4489d">XsDataPacket_containsDetailedStatus</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga74ac53ce205dd1188f542d68cfe4489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains detailed status data.  <a href="#ga74ac53ce205dd1188f542d68cfe4489d"></a><br/></td></tr>
<tr class="separator:ga74ac53ce205dd1188f542d68cfe4489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e5d2cf3dba73410249b687560fcff4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95e5d2cf3dba73410249b687560fcff4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga95e5d2cf3dba73410249b687560fcff4">XsDataPacket_setStatusByte</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint8_t data)</td></tr>
<tr class="memdesc:ga95e5d2cf3dba73410249b687560fcff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update status data for the item. <br/></td></tr>
<tr class="separator:ga95e5d2cf3dba73410249b687560fcff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45e4088b88602b52e2c6c75ac311850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa45e4088b88602b52e2c6c75ac311850"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa45e4088b88602b52e2c6c75ac311850">XsDataPacket_setStatus</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t data)</td></tr>
<tr class="memdesc:gaa45e4088b88602b52e2c6c75ac311850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update status data for the item. <br/></td></tr>
<tr class="separator:gaa45e4088b88602b52e2c6c75ac311850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e80aaced3a3102ad4b6e4cc732eb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad4e80aaced3a3102ad4b6e4cc732eb77">XsDataPacket_setTriggerIndication</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> triggerId, <a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> const *triggerIndicationData)</td></tr>
<tr class="memdesc:gad4e80aaced3a3102ad4b6e4cc732eb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update trigger indication data for the item.  <a href="#gad4e80aaced3a3102ad4b6e4cc732eb77"></a><br/></td></tr>
<tr class="separator:gad4e80aaced3a3102ad4b6e4cc732eb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b22f2e3d9ed049488d6797fb279370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad2b22f2e3d9ed049488d6797fb279370">XsDataPacket_triggerIndication</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> triggerId, <a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *returnVal)</td></tr>
<tr class="memdesc:gad2b22f2e3d9ed049488d6797fb279370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trigger indication data of a packet If the packet does not contain the requested data, the return val struct will be set to all zeroes.  <a href="#gad2b22f2e3d9ed049488d6797fb279370"></a><br/></td></tr>
<tr class="separator:gad2b22f2e3d9ed049488d6797fb279370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45de3d34c2383f51ff85c41d042da13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga45de3d34c2383f51ff85c41d042da13f">XsDataPacket_containsTriggerIndication</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *, <a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> triggerId)</td></tr>
<tr class="memdesc:ga45de3d34c2383f51ff85c41d042da13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains trigger indication data.  <a href="#ga45de3d34c2383f51ff85c41d042da13f"></a><br/></td></tr>
<tr class="separator:ga45de3d34c2383f51ff85c41d042da13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33cb466ebe40612bd66801cb3bf65d2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac33cb466ebe40612bd66801cb3bf65d2">XsDataPacket_packetCounter8</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac33cb466ebe40612bd66801cb3bf65d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 8 bit packet counter of a packet.  <a href="#gac33cb466ebe40612bd66801cb3bf65d2"></a><br/></td></tr>
<tr class="separator:gac33cb466ebe40612bd66801cb3bf65d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72422178927a7ce88254b0b9e37076da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga72422178927a7ce88254b0b9e37076da">XsDataPacket_containsPacketCounter8</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga72422178927a7ce88254b0b9e37076da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains an 8 bit packet counter.  <a href="#ga72422178927a7ce88254b0b9e37076da"></a><br/></td></tr>
<tr class="separator:ga72422178927a7ce88254b0b9e37076da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81fa16e65f4f1198bbccf10c58d6960e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81fa16e65f4f1198bbccf10c58d6960e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga81fa16e65f4f1198bbccf10c58d6960e">XsDataPacket_setPacketCounter8</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint8_t counter)</td></tr>
<tr class="memdesc:ga81fa16e65f4f1198bbccf10c58d6960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update 8 bit packet counter data for the item. <br/></td></tr>
<tr class="separator:ga81fa16e65f4f1198bbccf10c58d6960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac897f266dc357670ff551f82edbf7bae"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac897f266dc357670ff551f82edbf7bae">XsDataPacket_packetCounter</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac897f266dc357670ff551f82edbf7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet/frame counter of a packet.  <a href="#gac897f266dc357670ff551f82edbf7bae"></a><br/></td></tr>
<tr class="separator:gac897f266dc357670ff551f82edbf7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa1b7a6f13ea2bdd22ce75332601b34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8aa1b7a6f13ea2bdd22ce75332601b34">XsDataPacket_containsPacketCounter</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga8aa1b7a6f13ea2bdd22ce75332601b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains a packet counter.  <a href="#ga8aa1b7a6f13ea2bdd22ce75332601b34"></a><br/></td></tr>
<tr class="separator:ga8aa1b7a6f13ea2bdd22ce75332601b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf5eb91a1a96ef3dd19ada5ff633d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2cf5eb91a1a96ef3dd19ada5ff633d11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2cf5eb91a1a96ef3dd19ada5ff633d11">XsDataPacket_setPacketCounter</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint16_t counter)</td></tr>
<tr class="memdesc:ga2cf5eb91a1a96ef3dd19ada5ff633d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update packet counter data for the item. <br/></td></tr>
<tr class="separator:ga2cf5eb91a1a96ef3dd19ada5ff633d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3aabf7c48a5972924c6274ca8d28e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaba3aabf7c48a5972924c6274ca8d28e8">XsDataPacket_sampleTimeFine</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gaba3aabf7c48a5972924c6274ca8d28e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fine sample time of a packet.  <a href="#gaba3aabf7c48a5972924c6274ca8d28e8"></a><br/></td></tr>
<tr class="separator:gaba3aabf7c48a5972924c6274ca8d28e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00be954b34a7a3697229bfd6f04dccaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00be954b34a7a3697229bfd6f04dccaa">XsDataPacket_containsSampleTimeFine</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga00be954b34a7a3697229bfd6f04dccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item XsDataPacket_contains a sample time fine.  <a href="#ga00be954b34a7a3697229bfd6f04dccaa"></a><br/></td></tr>
<tr class="separator:ga00be954b34a7a3697229bfd6f04dccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb1187b7cd2a11b1ff3443ecf3aa095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1bb1187b7cd2a11b1ff3443ecf3aa095"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1bb1187b7cd2a11b1ff3443ecf3aa095">XsDataPacket_setSampleTimeFine</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t counter)</td></tr>
<tr class="memdesc:ga1bb1187b7cd2a11b1ff3443ecf3aa095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update sample tine fine data for the item. <br/></td></tr>
<tr class="separator:ga1bb1187b7cd2a11b1ff3443ecf3aa095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659cc64f5f3fbc6d7efcee002474b992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga659cc64f5f3fbc6d7efcee002474b992"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga659cc64f5f3fbc6d7efcee002474b992">XsDataPacket_sampleTimeCoarse</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga659cc64f5f3fbc6d7efcee002474b992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coarse sample time of a packet. <br/></td></tr>
<tr class="separator:ga659cc64f5f3fbc6d7efcee002474b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd77491910c63fabf11167c66f5dc3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7bd77491910c63fabf11167c66f5dc3c">XsDataPacket_containsSampleTimeCoarse</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga7bd77491910c63fabf11167c66f5dc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item XsDataPacket_contains a sample time coarse.  <a href="#ga7bd77491910c63fabf11167c66f5dc3c"></a><br/></td></tr>
<tr class="separator:ga7bd77491910c63fabf11167c66f5dc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d34b33022671972cedefd72bacec6a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d34b33022671972cedefd72bacec6a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1d34b33022671972cedefd72bacec6a2">XsDataPacket_setSampleTimeCoarse</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint32_t counter)</td></tr>
<tr class="memdesc:ga1d34b33022671972cedefd72bacec6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update sample tine coarse data for the item. <br/></td></tr>
<tr class="separator:ga1d34b33022671972cedefd72bacec6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b8e417b166d90a0687a2b7758f6ae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71b8e417b166d90a0687a2b7758f6ae0"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga71b8e417b166d90a0687a2b7758f6ae0">XsDataPacket_sampleTime64</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga71b8e417b166d90a0687a2b7758f6ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full 64-bit sample time of a packet, combined from the fine and coarse sample times. <br/></td></tr>
<tr class="separator:ga71b8e417b166d90a0687a2b7758f6ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69c00776dc3a25fa9a0bf6d178d6e29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab69c00776dc3a25fa9a0bf6d178d6e29">XsDataPacket_containsSampleTime64</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gab69c00776dc3a25fa9a0bf6d178d6e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> contains a full 64-bit sample time.  <a href="#gab69c00776dc3a25fa9a0bf6d178d6e29"></a><br/></td></tr>
<tr class="separator:gab69c00776dc3a25fa9a0bf6d178d6e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8473f03a8b763be77e44bc0d28aa0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c8473f03a8b763be77e44bc0d28aa0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c8473f03a8b763be77e44bc0d28aa0e">XsDataPacket_setSampleTime64</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, uint64_t counter)</td></tr>
<tr class="memdesc:ga6c8473f03a8b763be77e44bc0d28aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update sample tine coarse data for the item. <br/></td></tr>
<tr class="separator:ga6c8473f03a8b763be77e44bc0d28aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d14dd8d8800650f30c10b8592bcf7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0d14dd8d8800650f30c10b8592bcf7c1">XsDataPacket_utcTime</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *returnVal)</td></tr>
<tr class="memdesc:ga0d14dd8d8800650f30c10b8592bcf7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The utc time component of a data item.  <a href="#ga0d14dd8d8800650f30c10b8592bcf7c1"></a><br/></td></tr>
<tr class="separator:ga0d14dd8d8800650f30c10b8592bcf7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fddd1161e2606088e18804c47edc0d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2fddd1161e2606088e18804c47edc0d0">XsDataPacket_containsUtcTime</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga2fddd1161e2606088e18804c47edc0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains utc time data.  <a href="#ga2fddd1161e2606088e18804c47edc0d0"></a><br/></td></tr>
<tr class="separator:ga2fddd1161e2606088e18804c47edc0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94fddaf42bacfc69f0ea367e04ade0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae94fddaf42bacfc69f0ea367e04ade0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae94fddaf42bacfc69f0ea367e04ade0a">XsDataPacket_setUtcTime</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *data)</td></tr>
<tr class="memdesc:gae94fddaf42bacfc69f0ea367e04ade0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update utc time data for the item. <br/></td></tr>
<tr class="separator:gae94fddaf42bacfc69f0ea367e04ade0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e1ec4bf4fde8f406bc8743eb5eeeb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga67e1ec4bf4fde8f406bc8743eb5eeeb7">XsDataPacket_freeAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_vector.html">XsVector</a> *returnVal)</td></tr>
<tr class="memdesc:ga67e1ec4bf4fde8f406bc8743eb5eeeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The free acceleration component of a data item.  <a href="#ga67e1ec4bf4fde8f406bc8743eb5eeeb7"></a><br/></td></tr>
<tr class="separator:ga67e1ec4bf4fde8f406bc8743eb5eeeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1307b6dfe823a65ae9e035295e485f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae1307b6dfe823a65ae9e035295e485f7">XsDataPacket_containsFreeAcceleration</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gae1307b6dfe823a65ae9e035295e485f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if data item contains free acceleration.  <a href="#gae1307b6dfe823a65ae9e035295e485f7"></a><br/></td></tr>
<tr class="separator:gae1307b6dfe823a65ae9e035295e485f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ebbb512b59c7748a45fa70f3da5c667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8ebbb512b59c7748a45fa70f3da5c667">XsDataPacket_setFreeAcceleration</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_vector.html">XsVector</a> *g)</td></tr>
<tr class="memdesc:ga8ebbb512b59c7748a45fa70f3da5c667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update free acceleration data for the item.  <a href="#ga8ebbb512b59c7748a45fa70f3da5c667"></a><br/></td></tr>
<tr class="separator:ga8ebbb512b59c7748a45fa70f3da5c667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9a426ac35cf230d4d6016ebee6d6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafa9a426ac35cf230d4d6016ebee6d6c9">XsDataPacket_frameRange</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_range.html">XsRange</a> *returnVal)</td></tr>
<tr class="memdesc:gafa9a426ac35cf230d4d6016ebee6d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frame range contained in the datapacket.  <a href="#gafa9a426ac35cf230d4d6016ebee6d6c9"></a><br/></td></tr>
<tr class="separator:gafa9a426ac35cf230d4d6016ebee6d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58130ed5eb306a370faf88dd3b5dc83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad58130ed5eb306a370faf88dd3b5dc83">XsDataPacket_containsFrameRange</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gad58130ed5eb306a370faf88dd3b5dc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the datapacket contains a framerange.  <a href="#gad58130ed5eb306a370faf88dd3b5dc83"></a><br/></td></tr>
<tr class="separator:gad58130ed5eb306a370faf88dd3b5dc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d69b7bbbd2c6393c908f511085f31d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga48d69b7bbbd2c6393c908f511085f31d">XsDataPacket_setFrameRange</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_range.html">XsRange</a> *r)</td></tr>
<tr class="memdesc:ga48d69b7bbbd2c6393c908f511085f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or updates the frame range in the datapacket.  <a href="#ga48d69b7bbbd2c6393c908f511085f31d"></a><br/></td></tr>
<tr class="separator:ga48d69b7bbbd2c6393c908f511085f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30697102dfb8de08d4b8f4b3e5362834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga30697102dfb8de08d4b8f4b3e5362834">XsDataPacket_rssi</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga30697102dfb8de08d4b8f4b3e5362834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rssi value contained in the datapacket.  <a href="#ga30697102dfb8de08d4b8f4b3e5362834"></a><br/></td></tr>
<tr class="separator:ga30697102dfb8de08d4b8f4b3e5362834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f360268043a4fc135884256f00e34e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7f360268043a4fc135884256f00e34e1">XsDataPacket_containsRssi</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga7f360268043a4fc135884256f00e34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the datapacket contains an rssi value.  <a href="#ga7f360268043a4fc135884256f00e34e1"></a><br/></td></tr>
<tr class="separator:ga7f360268043a4fc135884256f00e34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee18c6de4dd432a2361dd981f9c4e7d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee18c6de4dd432a2361dd981f9c4e7d9">XsDataPacket_setRssi</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, int r)</td></tr>
<tr class="memdesc:gaee18c6de4dd432a2361dd981f9c4e7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or updates the rssi value in the datapacket.  <a href="#gaee18c6de4dd432a2361dd981f9c4e7d9"></a><br/></td></tr>
<tr class="separator:gaee18c6de4dd432a2361dd981f9c4e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc084c075cde16cb8a91b1e38f8cd05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fc084c075cde16cb8a91b1e38f8cd05"></a>
<a class="el" href="struct_xs_raw_gps_dop.html">XsRawGpsDop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5fc084c075cde16cb8a91b1e38f8cd05">XsDataPacket_rawGpsDop</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_dop.html">XsRawGpsDop</a> *returnVal)</td></tr>
<tr class="memdesc:ga5fc084c075cde16cb8a91b1e38f8cd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with <a class="el" href="struct_xs_raw_gps_dop.html" title="A container for NAV-DOP data.">XsRawGpsDop</a> data. <br/></td></tr>
<tr class="separator:ga5fc084c075cde16cb8a91b1e38f8cd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53edb71aeb307e9125ce630eaee90ca4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga53edb71aeb307e9125ce630eaee90ca4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga53edb71aeb307e9125ce630eaee90ca4">XsDataPacket_containsRawGpsDop</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga53edb71aeb307e9125ce630eaee90ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if data item contains RawGpsDop, 0 otherwise. <br/></td></tr>
<tr class="separator:ga53edb71aeb307e9125ce630eaee90ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfbfb7c6bc844380868feb62f91af63a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfbfb7c6bc844380868feb62f91af63a"></a>
<a class="el" href="struct_xs_raw_gps_sol.html">XsRawGpsSol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadfbfb7c6bc844380868feb62f91af63a">XsDataPacket_rawGpsSol</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_sol.html">XsRawGpsSol</a> *returnVal)</td></tr>
<tr class="memdesc:gadfbfb7c6bc844380868feb62f91af63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with RawGpsSol data. <br/></td></tr>
<tr class="separator:gadfbfb7c6bc844380868feb62f91af63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a02ac1c0ef73d9610a85129ed1672a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0a02ac1c0ef73d9610a85129ed1672a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0a02ac1c0ef73d9610a85129ed1672a2">XsDataPacket_containsRawGpsSol</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:ga0a02ac1c0ef73d9610a85129ed1672a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if data item contains RawGpsSol, 0 otherwise. <br/></td></tr>
<tr class="separator:ga0a02ac1c0ef73d9610a85129ed1672a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49edf68109e853cc027d4ff11c909b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada49edf68109e853cc027d4ff11c909b"></a>
<a class="el" href="struct_xs_raw_gps_time_utc.html">XsRawGpsTimeUtc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gada49edf68109e853cc027d4ff11c909b">XsDataPacket_rawGpsTimeUtc</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_time_utc.html">XsRawGpsTimeUtc</a> *returnVal)</td></tr>
<tr class="memdesc:gada49edf68109e853cc027d4ff11c909b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with RawGpsTimeUtc data. <br/></td></tr>
<tr class="separator:gada49edf68109e853cc027d4ff11c909b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24dcfb986bd6fa58b0bd099adfeb1d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac24dcfb986bd6fa58b0bd099adfeb1d0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac24dcfb986bd6fa58b0bd099adfeb1d0">XsDataPacket_containsRawGpsTimeUtc</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)</td></tr>
<tr class="memdesc:gac24dcfb986bd6fa58b0bd099adfeb1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if data item contains RawGpsTimeUtc, 0 otherwise. <br/></td></tr>
<tr class="separator:gac24dcfb986bd6fa58b0bd099adfeb1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ef62360dfb7431256bf679b42f4a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3ef62360dfb7431256bf679b42f4a23"></a>
<a class="el" href="struct_xs_raw_gps_sv_info.html">XsRawGpsSvInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad3ef62360dfb7431256bf679b42f4a23">XsDataPacket_rawGpsSvInfo</a> (const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, <a class="el" href="struct_xs_raw_gps_sv_info.html">XsRawGpsSvInfo</a> *returnVal)</td></tr>
<tr class="memdesc:gad3ef62360dfb7431256bf679b42f4a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a struct with RawGpsClock data. <br/></td></tr>
<tr class="separator:gad3ef62360dfb7431256bf679b42f4a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec420bb6de5d632e4fa3f5e4751ef3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaec420bb6de5d632e4fa3f5e4751ef3f7">XsDataPacket_append</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *other)</td></tr>
<tr class="memdesc:gaec420bb6de5d632e4fa3f5e4751ef3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the data items from <em>other</em> to the packet.  <a href="#gaec420bb6de5d632e4fa3f5e4751ef3f7"></a><br/></td></tr>
<tr class="separator:gaec420bb6de5d632e4fa3f5e4751ef3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4916426e8dd9d71641e33633a9e12e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b4916426e8dd9d71641e33633a9e12e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5b4916426e8dd9d71641e33633a9e12e">XsDeviceId_broadcast</a> (void)</td></tr>
<tr class="memdesc:ga5b4916426e8dd9d71641e33633a9e12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a broadcast deviceID. <br/></td></tr>
<tr class="separator:ga5b4916426e8dd9d71641e33633a9e12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099ea30bbea00971b41bf16781cf6a83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga099ea30bbea00971b41bf16781cf6a83"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga099ea30bbea00971b41bf16781cf6a83">XsDeviceId_isValid</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga099ea30bbea00971b41bf16781cf6a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the device ID is a valid id (not 0). <br/></td></tr>
<tr class="separator:ga099ea30bbea00971b41bf16781cf6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99df42d3a051bd603c8bf5c8d3c3a5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae99df42d3a051bd603c8bf5c8d3c3a5b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae99df42d3a051bd603c8bf5c8d3c3a5b">XsDeviceId_isXbusMaster</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae99df42d3a051bd603c8bf5c8d3c3a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Xbus Master. <br/></td></tr>
<tr class="separator:gae99df42d3a051bd603c8bf5c8d3c3a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37cbd55b17b3a877042112a59e904cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae37cbd55b17b3a877042112a59e904cc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae37cbd55b17b3a877042112a59e904cc">XsDeviceId_isWirelessMaster</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae37cbd55b17b3a877042112a59e904cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents a Wireless Master device (Awinda Station, Awinda Dongle, Awinda OEM). <br/></td></tr>
<tr class="separator:gae37cbd55b17b3a877042112a59e904cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac407762b4a1b5ca50d99aadc2c516883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac407762b4a1b5ca50d99aadc2c516883"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac407762b4a1b5ca50d99aadc2c516883">XsDeviceId_isAwindaStation</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gac407762b4a1b5ca50d99aadc2c516883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Awinda Station. <br/></td></tr>
<tr class="separator:gac407762b4a1b5ca50d99aadc2c516883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27ce112c3bd3fa3ed63170f4115b442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa27ce112c3bd3fa3ed63170f4115b442"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa27ce112c3bd3fa3ed63170f4115b442">XsDeviceId_isAwindaDongle</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaa27ce112c3bd3fa3ed63170f4115b442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Awinda Dongle. <br/></td></tr>
<tr class="separator:gaa27ce112c3bd3fa3ed63170f4115b442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbaf3008b1d5d9db37704923a3b233d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbaf3008b1d5d9db37704923a3b233d7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabbaf3008b1d5d9db37704923a3b233d7">XsDeviceId_isAwindaOem</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gabbaf3008b1d5d9db37704923a3b233d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Awinda OEM board. <br/></td></tr>
<tr class="separator:gabbaf3008b1d5d9db37704923a3b233d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5279f17952a3e1f6c1f05a3bfb812fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5279f17952a3e1f6c1f05a3bfb812fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab5279f17952a3e1f6c1f05a3bfb812fe">XsDeviceId_isMtw</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gab5279f17952a3e1f6c1f05a3bfb812fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTw. <br/></td></tr>
<tr class="separator:gab5279f17952a3e1f6c1f05a3bfb812fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c084f04c30b7370dc36692ed193d1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08c084f04c30b7370dc36692ed193d1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga08c084f04c30b7370dc36692ed193d1b">XsDeviceId_isXbusMasterMotionTracker</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga08c084f04c30b7370dc36692ed193d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an Xbus Master Motion Tracker. <br/></td></tr>
<tr class="separator:ga08c084f04c30b7370dc36692ed193d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ed456340bb66c2da02b1aedd55ac1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga33ed456340bb66c2da02b1aedd55ac1a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga33ed456340bb66c2da02b1aedd55ac1a">XsDeviceId_isMtix</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga33ed456340bb66c2da02b1aedd55ac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTi or an MTx. <br/></td></tr>
<tr class="separator:ga33ed456340bb66c2da02b1aedd55ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7f3448fc6bbe05fb55373bc6c72be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e7f3448fc6bbe05fb55373bc6c72be8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3e7f3448fc6bbe05fb55373bc6c72be8">XsDeviceId_isLegacyMtig</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga3e7f3448fc6bbe05fb55373bc6c72be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents a legacy MTi-G. <br/></td></tr>
<tr class="separator:ga3e7f3448fc6bbe05fb55373bc6c72be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec57002bd1fdc7c371b9207899ca3bb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec57002bd1fdc7c371b9207899ca3bb9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaec57002bd1fdc7c371b9207899ca3bb9">XsDeviceId_isMtig</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaec57002bd1fdc7c371b9207899ca3bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTi-G. <br/></td></tr>
<tr class="separator:gaec57002bd1fdc7c371b9207899ca3bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a52a7ef11195a72bb3712f965852fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1a52a7ef11195a72bb3712f965852fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae1a52a7ef11195a72bb3712f965852fe">XsDeviceId_isMtMk4</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae1a52a7ef11195a72bb3712f965852fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4. <br/></td></tr>
<tr class="separator:gae1a52a7ef11195a72bb3712f965852fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c192ef55e4f81743a9bfdae27396e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05c192ef55e4f81743a9bfdae27396e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga05c192ef55e4f81743a9bfdae27396e0">XsDeviceId_isMtMk4_X0</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga05c192ef55e4f81743a9bfdae27396e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 10 series. <br/></td></tr>
<tr class="separator:ga05c192ef55e4f81743a9bfdae27396e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da662ba7f747bb2318b2d15fac1935c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0da662ba7f747bb2318b2d15fac1935c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0da662ba7f747bb2318b2d15fac1935c">XsDeviceId_isMtMk4_10</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga0da662ba7f747bb2318b2d15fac1935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 10. <br/></td></tr>
<tr class="separator:ga0da662ba7f747bb2318b2d15fac1935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55491981ff828d44fcf93e1c02d6a9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55491981ff828d44fcf93e1c02d6a9e5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55491981ff828d44fcf93e1c02d6a9e5">XsDeviceId_isMtMk4_20</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga55491981ff828d44fcf93e1c02d6a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 20. <br/></td></tr>
<tr class="separator:ga55491981ff828d44fcf93e1c02d6a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9d17f3d9226bf0177a76171aa2f188"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab9d17f3d9226bf0177a76171aa2f188"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaab9d17f3d9226bf0177a76171aa2f188">XsDeviceId_isMtMk4_30</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gaab9d17f3d9226bf0177a76171aa2f188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 30. <br/></td></tr>
<tr class="separator:gaab9d17f3d9226bf0177a76171aa2f188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cd8b78662d0970bdf15e0a0713c2b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27cd8b78662d0970bdf15e0a0713c2b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga27cd8b78662d0970bdf15e0a0713c2b2">XsDeviceId_isMtMk4_X00</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga27cd8b78662d0970bdf15e0a0713c2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 100 series. <br/></td></tr>
<tr class="separator:ga27cd8b78662d0970bdf15e0a0713c2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29cb199d8cbbd28aa43bf4ee542e0898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29cb199d8cbbd28aa43bf4ee542e0898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga29cb199d8cbbd28aa43bf4ee542e0898">XsDeviceId_isMtMk4_100</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga29cb199d8cbbd28aa43bf4ee542e0898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 100. <br/></td></tr>
<tr class="separator:ga29cb199d8cbbd28aa43bf4ee542e0898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c60991d86c6136d323e9344eec4d5c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c60991d86c6136d323e9344eec4d5c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6c60991d86c6136d323e9344eec4d5c3">XsDeviceId_isMtMk4_200</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga6c60991d86c6136d323e9344eec4d5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 200. <br/></td></tr>
<tr class="separator:ga6c60991d86c6136d323e9344eec4d5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c8c4a97533d7a67a1aae56b2a8ad10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3c8c4a97533d7a67a1aae56b2a8ad10"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad3c8c4a97533d7a67a1aae56b2a8ad10">XsDeviceId_isMtMk4_300</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gad3c8c4a97533d7a67a1aae56b2a8ad10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 300. <br/></td></tr>
<tr class="separator:gad3c8c4a97533d7a67a1aae56b2a8ad10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1c3377e2e191de766abd34ec859f80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a1c3377e2e191de766abd34ec859f80"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4a1c3377e2e191de766abd34ec859f80">XsDeviceId_isMtMk4_700</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga4a1c3377e2e191de766abd34ec859f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTMk4 700. <br/></td></tr>
<tr class="separator:ga4a1c3377e2e191de766abd34ec859f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55623db59b144d6874d42fdc113adc31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55623db59b144d6874d42fdc113adc31"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga55623db59b144d6874d42fdc113adc31">XsDeviceId_isMtw2</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga55623db59b144d6874d42fdc113adc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTw2. <br/></td></tr>
<tr class="separator:ga55623db59b144d6874d42fdc113adc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1e5fd0df1373b4857b47e874a3be6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d1e5fd0df1373b4857b47e874a3be6d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4d1e5fd0df1373b4857b47e874a3be6d">XsDeviceId_isMtx2</a> (const struct <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga4d1e5fd0df1373b4857b47e874a3be6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID represents an MTx2. <br/></td></tr>
<tr class="separator:ga4d1e5fd0df1373b4857b47e874a3be6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dd4d5d3ca5ae5079fabbfc657c278f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6dd4d5d3ca5ae5079fabbfc657c278f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6dd4d5d3ca5ae5079fabbfc657c278f">XsDeviceId_containsBroadcast</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:gae6dd4d5d3ca5ae5079fabbfc657c278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the device ID has the broadcast bit set. <br/></td></tr>
<tr class="separator:gae6dd4d5d3ca5ae5079fabbfc657c278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223b3bbf099718160b2958a8663de2da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga223b3bbf099718160b2958a8663de2da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga223b3bbf099718160b2958a8663de2da">XsDeviceId_isBroadcast</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *)</td></tr>
<tr class="memdesc:ga223b3bbf099718160b2958a8663de2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this device ID <em>is</em> <em>the</em> broadcast id. <br/></td></tr>
<tr class="separator:ga223b3bbf099718160b2958a8663de2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9d23d23f25cc104ce77ea1dc9a2f3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f9d23d23f25cc104ce77ea1dc9a2f3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8f9d23d23f25cc104ce77ea1dc9a2f3c">XsDeviceId_toString</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *str)</td></tr>
<tr class="memdesc:ga8f9d23d23f25cc104ce77ea1dc9a2f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with a readable representation of this device ID. <br/></td></tr>
<tr class="separator:ga8f9d23d23f25cc104ce77ea1dc9a2f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2c532c3468ad0e5bf869888cb169e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c2c532c3468ad0e5bf869888cb169e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c2c532c3468ad0e5bf869888cb169e8">XsEuler_destruct</a> (<a class="el" href="struct_xs_euler.html">XsEuler</a> *)</td></tr>
<tr class="memdesc:ga8c2c532c3468ad0e5bf869888cb169e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all angles in the <a class="el" href="struct_xs_euler.html" title="Contains Euler Angle data and conversion from Quaternion.">XsEuler</a> object by setting them to 0. <br/></td></tr>
<tr class="separator:ga8c2c532c3468ad0e5bf869888cb169e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2386ad4f8114a365b6cd43274e7dfefd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2386ad4f8114a365b6cd43274e7dfefd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2386ad4f8114a365b6cd43274e7dfefd">XsEuler_empty</a> (const <a class="el" href="struct_xs_euler.html">XsEuler</a> *)</td></tr>
<tr class="memdesc:ga2386ad4f8114a365b6cd43274e7dfefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all angles in this object are zero. <br/></td></tr>
<tr class="separator:ga2386ad4f8114a365b6cd43274e7dfefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a0f25e115a3798583d767c869600c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5a0f25e115a3798583d767c869600c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa5a0f25e115a3798583d767c869600c0">XsEuler_fromQuaternion</a> (<a class="el" href="struct_xs_euler.html">XsEuler</a> *, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:gaa5a0f25e115a3798583d767c869600c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an euler angle representation of the quaternion. <br/></td></tr>
<tr class="separator:gaa5a0f25e115a3798583d767c869600c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf527c091a1c75bba161ea8620442bf1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf527c091a1c75bba161ea8620442bf1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf527c091a1c75bba161ea8620442bf1d">XsMatrix_ref</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize cols, XsSize stride, XsReal *buffer, <a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a> flags)</td></tr>
<tr class="memdesc:gaf527c091a1c75bba161ea8620442bf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the XsMatrix as a reference to data in <em>buffer</em>. <br/></td></tr>
<tr class="separator:gaf527c091a1c75bba161ea8620442bf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aecaec6a03d98ca29d1f0245d52d1be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5aecaec6a03d98ca29d1f0245d52d1be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5aecaec6a03d98ca29d1f0245d52d1be">XsMatrix_construct</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize cols, XsSize stride, const XsReal *src, XsSize srcStride)</td></tr>
<tr class="memdesc:ga5aecaec6a03d98ca29d1f0245d52d1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix and copy the data from <em>src</em> into the matrix if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:ga5aecaec6a03d98ca29d1f0245d52d1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1694795a244793ab61ccdee5ffb44feb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1694795a244793ab61ccdee5ffb44feb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1694795a244793ab61ccdee5ffb44feb">XsMatrix_assign</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize cols, XsSize stride, const XsReal *src, XsSize srcStride)</td></tr>
<tr class="memdesc:ga1694795a244793ab61ccdee5ffb44feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix and copy the data from <em>src</em> into the matrix if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:ga1694795a244793ab61ccdee5ffb44feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9532727d4c5dc4b1ff11286bb249b7da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9532727d4c5dc4b1ff11286bb249b7da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9532727d4c5dc4b1ff11286bb249b7da">XsMatrix_destruct</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:ga9532727d4c5dc4b1ff11286bb249b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> and release allocated resources. <br/></td></tr>
<tr class="separator:ga9532727d4c5dc4b1ff11286bb249b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e74b6a3842014c47fda04fe9c4f4fd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e74b6a3842014c47fda04fe9c4f4fd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7e74b6a3842014c47fda04fe9c4f4fd4">XsMatrix_copy</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *copy, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> const *src)</td></tr>
<tr class="memdesc:ga7e74b6a3842014c47fda04fe9c4f4fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of <em>copy</em> to the XsMatrix. <br/></td></tr>
<tr class="separator:ga7e74b6a3842014c47fda04fe9c4f4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb837448577820b2e4d81ad6b0fece5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9bb837448577820b2e4d81ad6b0fece5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9bb837448577820b2e4d81ad6b0fece5">XsMatrix_setZero</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:ga9bb837448577820b2e4d81ad6b0fece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the values in the matrix to zero. <br/></td></tr>
<tr class="separator:ga9bb837448577820b2e4d81ad6b0fece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae713d0404dfa67fedb05659f54d6449e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae713d0404dfa67fedb05659f54d6449e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae713d0404dfa67fedb05659f54d6449e">XsMatrix_empty</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *)</td></tr>
<tr class="memdesc:gae713d0404dfa67fedb05659f54d6449e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns not zero if the matrix contains no values. <br/></td></tr>
<tr class="separator:gae713d0404dfa67fedb05659f54d6449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3aa84511f07c5b343ee77112361dfaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3aa84511f07c5b343ee77112361dfaf">XsMatrix_multiplyScalar</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsReal scalar, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *dest)</td></tr>
<tr class="memdesc:gaf3aa84511f07c5b343ee77112361dfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all values in this <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> by <em>scalar</em>.  <a href="#gaf3aa84511f07c5b343ee77112361dfaf"></a><br/></td></tr>
<tr class="separator:gaf3aa84511f07c5b343ee77112361dfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84490340feeeb8c23327124019db1dde"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga84490340feeeb8c23327124019db1dde">XsMatrix_offset</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize row, XsSize column)</td></tr>
<tr class="memdesc:ga84490340feeeb8c23327124019db1dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset in the data for accessing the value at <em>row</em> and <em>column</em>.  <a href="#ga84490340feeeb8c23327124019db1dde"></a><br/></td></tr>
<tr class="separator:ga84490340feeeb8c23327124019db1dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a90bfd79321cad5e715dba52de1e6ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a90bfd79321cad5e715dba52de1e6ea"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9a90bfd79321cad5e715dba52de1e6ea">XsMatrix_value</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize row, XsSize column)</td></tr>
<tr class="memdesc:ga9a90bfd79321cad5e715dba52de1e6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data value at <em>row</em> and <em>column</em>. <br/></td></tr>
<tr class="separator:ga9a90bfd79321cad5e715dba52de1e6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0084bdd99540d1133f4cf6998e78527"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0084bdd99540d1133f4cf6998e78527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab0084bdd99540d1133f4cf6998e78527">XsMatrix_setValue</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize row, XsSize column, XsReal value)</td></tr>
<tr class="memdesc:gab0084bdd99540d1133f4cf6998e78527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data <em>value</em> at <em>row</em> and <em>column</em>. <br/></td></tr>
<tr class="separator:gab0084bdd99540d1133f4cf6998e78527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5882a97fbee0de45eeb4431d9e640093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5882a97fbee0de45eeb4431d9e640093"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5882a97fbee0de45eeb4431d9e640093">XsMatrix_dimensionsMatch</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, XsSize rows, XsSize columns)</td></tr>
<tr class="memdesc:ga5882a97fbee0de45eeb4431d9e640093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns not zero if the dimensions of the XsMatrix are equal to <em>rows</em> and <em>columns</em>. <br/></td></tr>
<tr class="separator:ga5882a97fbee0de45eeb4431d9e640093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671caacd145c6ba203d621c65c49b649"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga671caacd145c6ba203d621c65c49b649"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga671caacd145c6ba203d621c65c49b649">XsMatrix_fromQuaternion</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:ga671caacd145c6ba203d621c65c49b649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an orientation matrix representation of the quaternion. <br/></td></tr>
<tr class="separator:ga671caacd145c6ba203d621c65c49b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4218a181d23c28cf3e927b7504a9069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab4218a181d23c28cf3e927b7504a9069">XsMatrix_swap</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *a, <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *b)</td></tr>
<tr class="memdesc:gab4218a181d23c28cf3e927b7504a9069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>.  <a href="#gab4218a181d23c28cf3e927b7504a9069"></a><br/></td></tr>
<tr class="separator:gab4218a181d23c28cf3e927b7504a9069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098d9712b3e0710bbe9470f8587ea834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga098d9712b3e0710bbe9470f8587ea834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga098d9712b3e0710bbe9470f8587ea834">XsMatrix3x3_construct</a> (<a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> *)</td></tr>
<tr class="memdesc:ga098d9712b3e0710bbe9470f8587ea834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix3x3. <br/></td></tr>
<tr class="separator:ga098d9712b3e0710bbe9470f8587ea834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33b2122d974535e39388dfdea6344dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab33b2122d974535e39388dfdea6344dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab33b2122d974535e39388dfdea6344dd">XsMatrix3x3_assign</a> (<a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> *, const XsReal *src, XsSize srcStride)</td></tr>
<tr class="memdesc:gab33b2122d974535e39388dfdea6344dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsMatrix3x3 and copy the data from <em>src</em> into the matrix if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:gab33b2122d974535e39388dfdea6344dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06191d9047075d30941028a1ff760b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06191d9047075d30941028a1ff760b71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga06191d9047075d30941028a1ff760b71">XsMatrix3x3_destruct</a> (<a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> *)</td></tr>
<tr class="memdesc:ga06191d9047075d30941028a1ff760b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the Matrix3x3. <br/></td></tr>
<tr class="separator:ga06191d9047075d30941028a1ff760b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de6b5eb3961a00bb3822bd31928f63e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2de6b5eb3961a00bb3822bd31928f63e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2de6b5eb3961a00bb3822bd31928f63e">XsMatrix3x3_copy</a> (<a class="el" href="struct_xs_matrix.html">XsMatrix</a> *copy, <a class="el" href="struct_xs_matrix3x3.html">XsMatrix3x3</a> const *src)</td></tr>
<tr class="memdesc:ga2de6b5eb3961a00bb3822bd31928f63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsMatrix3x3 to <em>copy</em>. <br/></td></tr>
<tr class="separator:ga2de6b5eb3961a00bb3822bd31928f63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a897853544927b983109bc082a2047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10a897853544927b983109bc082a2047"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga10a897853544927b983109bc082a2047">XsPortInfo_clear</a> (<a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga10a897853544927b983109bc082a2047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object to the empty state. <br/></td></tr>
<tr class="separator:ga10a897853544927b983109bc082a2047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e303f48cc6379d465407af794f8ebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97e303f48cc6379d465407af794f8ebe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga97e303f48cc6379d465407af794f8ebe">XsPortInfo_empty</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga97e303f48cc6379d465407af794f8ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="struct_xs_port_info.html" title="Contains a descriptor for opening a communication port to an Xsens device.">XsPortInfo</a> object is empty. <br/></td></tr>
<tr class="separator:ga97e303f48cc6379d465407af794f8ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32b87ad68904738bb4ad9e64758f05a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa32b87ad68904738bb4ad9e64758f05a">XsPortInfo_portNumber</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:gaa32b87ad68904738bb4ad9e64758f05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port number.  <a href="#gaa32b87ad68904738bb4ad9e64758f05a"></a><br/></td></tr>
<tr class="separator:gaa32b87ad68904738bb4ad9e64758f05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b8b2bbdc065321e22e7bc0e0edc3eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3b8b2bbdc065321e22e7bc0e0edc3eb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf3b8b2bbdc065321e22e7bc0e0edc3eb">XsPortInfo_isUsb</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:gaf3b8b2bbdc065321e22e7bc0e0edc3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this port info object contains a USB device. <br/></td></tr>
<tr class="separator:gaf3b8b2bbdc065321e22e7bc0e0edc3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a9ed806c36fb0f13e476ad29ff6876"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga07a9ed806c36fb0f13e476ad29ff6876">XsPortInfo_usbBus</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga07a9ed806c36fb0f13e476ad29ff6876"><td class="mdescLeft">&#160;</td><td class="mdescRight">The usb bus.  <a href="#ga07a9ed806c36fb0f13e476ad29ff6876"></a><br/></td></tr>
<tr class="separator:ga07a9ed806c36fb0f13e476ad29ff6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f7a31f4a8a7aaf3a18c9152d9e993ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9f7a31f4a8a7aaf3a18c9152d9e993ff">XsPortInfo_usbAddress</a> (const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *)</td></tr>
<tr class="memdesc:ga9f7a31f4a8a7aaf3a18c9152d9e993ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The usb address.  <a href="#ga9f7a31f4a8a7aaf3a18c9152d9e993ff"></a><br/></td></tr>
<tr class="separator:ga9f7a31f4a8a7aaf3a18c9152d9e993ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1b3ad304657c3af6a6023bbf01c30e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f1b3ad304657c3af6a6023bbf01c30e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1f1b3ad304657c3af6a6023bbf01c30e">XsQuaternion_destruct</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga1f1b3ad304657c3af6a6023bbf01c30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the quaternion by setting all values to 0. <br/></td></tr>
<tr class="separator:ga1f1b3ad304657c3af6a6023bbf01c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d14c31ff258dab9129d882b02103f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97d14c31ff258dab9129d882b02103f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga97d14c31ff258dab9129d882b02103f4">XsQuaternion_empty</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga97d14c31ff258dab9129d882b02103f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this is a null object. <br/></td></tr>
<tr class="separator:ga97d14c31ff258dab9129d882b02103f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217fd03f808db0b06765e3bbb85fc9cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga217fd03f808db0b06765e3bbb85fc9cb">XsQuaternion_invert</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga217fd03f808db0b06765e3bbb85fc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert this quaternion.  <a href="#ga217fd03f808db0b06765e3bbb85fc9cb"></a><br/></td></tr>
<tr class="separator:ga217fd03f808db0b06765e3bbb85fc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7269b337234843b87fd7df7f68efa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6b7269b337234843b87fd7df7f68efa2">XsQuaternion_inverse</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *dest)</td></tr>
<tr class="memdesc:ga6b7269b337234843b87fd7df7f68efa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse/conjugate of this quaternion.  <a href="#ga6b7269b337234843b87fd7df7f68efa2"></a><br/></td></tr>
<tr class="separator:ga6b7269b337234843b87fd7df7f68efa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c462b4e47fccbf9c363016cf634082"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00c462b4e47fccbf9c363016cf634082"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga00c462b4e47fccbf9c363016cf634082">XsQuaternion_normalized</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *dest)</td></tr>
<tr class="memdesc:ga00c462b4e47fccbf9c363016cf634082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a normalized version of this quaternion. <br/></td></tr>
<tr class="separator:ga00c462b4e47fccbf9c363016cf634082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ebe154b533b0a06c7f13f6a1a467d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43ebe154b533b0a06c7f13f6a1a467d7"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga43ebe154b533b0a06c7f13f6a1a467d7">XsQuaternion_normalize</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *)</td></tr>
<tr class="memdesc:ga43ebe154b533b0a06c7f13f6a1a467d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize this quaternion. <br/></td></tr>
<tr class="separator:ga43ebe154b533b0a06c7f13f6a1a467d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83391ceba3832268f3c65985d12d041b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83391ceba3832268f3c65985d12d041b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga83391ceba3832268f3c65985d12d041b">XsQuaternion_fromEulerAngles</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, const <a class="el" href="struct_xs_euler.html">XsEuler</a> *src)</td></tr>
<tr class="memdesc:ga83391ceba3832268f3c65985d12d041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a quaternion representation from <em>euler</em> angles. <br/></td></tr>
<tr class="separator:ga83391ceba3832268f3c65985d12d041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5021de7e1f89887d357b80e69c15d5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5021de7e1f89887d357b80e69c15d5ba">XsQuaternion_fromRotationMatrix</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *ori)</td></tr>
<tr class="memdesc:ga5021de7e1f89887d357b80e69c15d5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a quaternion representation of orientation matrix <em>ori</em>.  <a href="#ga5021de7e1f89887d357b80e69c15d5ba"></a><br/></td></tr>
<tr class="separator:ga5021de7e1f89887d357b80e69c15d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593ee51ef335cbc420bb7ea13c453156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga593ee51ef335cbc420bb7ea13c453156"></a>
const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga593ee51ef335cbc420bb7ea13c453156">XsQuaternion_identity</a> (void)</td></tr>
<tr class="memdesc:ga593ee51ef335cbc420bb7ea13c453156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_xs_quaternion.html" title="A class that implements a quaternion.">XsQuaternion</a> that represents the identity quaternion. <br/></td></tr>
<tr class="separator:ga593ee51ef335cbc420bb7ea13c453156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0440c029b3ede9752761cffc902151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a0440c029b3ede9752761cffc902151"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga3a0440c029b3ede9752761cffc902151">XsQuaternion_multiply</a> (const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *left, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *right, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *dest)</td></tr>
<tr class="memdesc:ga3a0440c029b3ede9752761cffc902151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply <em>left</em> quaternion with <em>right</em> quaternion and put the result in <em>dest</em>. The parameters may point to the same XsQuaternion(s). <br/></td></tr>
<tr class="separator:ga3a0440c029b3ede9752761cffc902151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ddb691c1f925c8ead506706bda469d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ddb691c1f925c8ead506706bda469d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga91ddb691c1f925c8ead506706bda469d">XsQuaternion_swap</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *a, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *b)</td></tr>
<tr class="memdesc:ga91ddb691c1f925c8ead506706bda469d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>. <br/></td></tr>
<tr class="separator:ga91ddb691c1f925c8ead506706bda469d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51869125847cbfb122309dba983f2162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga51869125847cbfb122309dba983f2162"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga51869125847cbfb122309dba983f2162">XsQuaternion_copy</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *copy, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> const *src)</td></tr>
<tr class="memdesc:ga51869125847cbfb122309dba983f2162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of <em>thisPtr</em> into <em>copy</em>. <br/></td></tr>
<tr class="separator:ga51869125847cbfb122309dba983f2162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga066fd219bed3ec664d2e37fda22f664f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga066fd219bed3ec664d2e37fda22f664f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga066fd219bed3ec664d2e37fda22f664f">XsQuaternion_equal</a> (<a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> const *a, <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> const *b)</td></tr>
<tr class="memdesc:ga066fd219bed3ec664d2e37fda22f664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns non-zero if <em>a</em> and <em>b</em> are numerically equal <br/></td></tr>
<tr class="separator:ga066fd219bed3ec664d2e37fda22f664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13553237cb71fff5792dda83f4fa0126"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga13553237cb71fff5792dda83f4fa0126">XsRange_count</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *)</td></tr>
<tr class="memdesc:ga13553237cb71fff5792dda83f4fa0126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of values in the range.  <a href="#ga13553237cb71fff5792dda83f4fa0126"></a><br/></td></tr>
<tr class="separator:ga13553237cb71fff5792dda83f4fa0126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5d89008b194a4404db1c8f0cdf35b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabc5d89008b194a4404db1c8f0cdf35b2">XsRange_interval</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *)</td></tr>
<tr class="memdesc:gabc5d89008b194a4404db1c8f0cdf35b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of values in the range.  <a href="#gabc5d89008b194a4404db1c8f0cdf35b2"></a><br/></td></tr>
<tr class="separator:gabc5d89008b194a4404db1c8f0cdf35b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1cd63243ef6c97d8dc74100b696ae33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1cd63243ef6c97d8dc74100b696ae33"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaa1cd63243ef6c97d8dc74100b696ae33">XsRange_contains</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *, int i)</td></tr>
<tr class="memdesc:gaa1cd63243ef6c97d8dc74100b696ae33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the range contains the given value <em>i</em>. <br/></td></tr>
<tr class="separator:gaa1cd63243ef6c97d8dc74100b696ae33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced1498a56faedf260bace911f210d46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaced1498a56faedf260bace911f210d46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaced1498a56faedf260bace911f210d46">XsRange_setRange</a> (<a class="el" href="struct_xs_range.html">XsRange</a> *, int f, int l)</td></tr>
<tr class="memdesc:gaced1498a56faedf260bace911f210d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new range. <br/></td></tr>
<tr class="separator:gaced1498a56faedf260bace911f210d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de65698e6d8914121c8fde5832fd5cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6de65698e6d8914121c8fde5832fd5cb">XsRange_empty</a> (const <a class="el" href="struct_xs_range.html">XsRange</a> *)</td></tr>
<tr class="memdesc:ga6de65698e6d8914121c8fde5832fd5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the range is empty.  <a href="#ga6de65698e6d8914121c8fde5832fd5cb"></a><br/></td></tr>
<tr class="separator:ga6de65698e6d8914121c8fde5832fd5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade542196fc0232e0801ff67f5ae19abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gade542196fc0232e0801ff67f5ae19abc">XsSdiData_construct</a> (<a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *, const XsReal *orientationIncrement, const XsReal *velocityIncrement)</td></tr>
<tr class="memdesc:gade542196fc0232e0801ff67f5ae19abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an XsSdiData object with the optional arguments.  <a href="#gade542196fc0232e0801ff67f5ae19abc"></a><br/></td></tr>
<tr class="separator:gade542196fc0232e0801ff67f5ae19abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb5973e5a32cfdb3d6490ea651554c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fb5973e5a32cfdb3d6490ea651554c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0fb5973e5a32cfdb3d6490ea651554c7">XsSdiData_destruct</a> (<a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *)</td></tr>
<tr class="memdesc:ga0fb5973e5a32cfdb3d6490ea651554c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the object, makes the fields invalid. <br/></td></tr>
<tr class="separator:ga0fb5973e5a32cfdb3d6490ea651554c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc206cd38f905d821555bb9a322ac7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6cc206cd38f905d821555bb9a322ac7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6cc206cd38f905d821555bb9a322ac7e">XsTimeStamp_setMilliSecondTime</a> (<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *, int64_t t)</td></tr>
<tr class="memdesc:ga6cc206cd38f905d821555bb9a322ac7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stored time to <em>miliseconds</em>. <br/></td></tr>
<tr class="separator:ga6cc206cd38f905d821555bb9a322ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd4c01e2cac9765f62585aa1a8e1ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaccd4c01e2cac9765f62585aa1a8e1ba1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaccd4c01e2cac9765f62585aa1a8e1ba1">XsTimeStamp_timeOfDay</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:gaccd4c01e2cac9765f62585aa1a8e1ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time of day component of the stored timestamp in seconds as a double precision value. <br/></td></tr>
<tr class="separator:gaccd4c01e2cac9765f62585aa1a8e1ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0753ab6a21c625d468886b2e03150841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0753ab6a21c625d468886b2e03150841"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0753ab6a21c625d468886b2e03150841">XsTimeStamp_secondTime</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga0753ab6a21c625d468886b2e03150841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of seconds elapsed since the epoch as stored in the <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps.">XsTimeStamp</a>. <br/></td></tr>
<tr class="separator:ga0753ab6a21c625d468886b2e03150841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a15a3de652a757c85b6be392200d65d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a15a3de652a757c85b6be392200d65d"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga6a15a3de652a757c85b6be392200d65d">XsTimeStamp_milliSecondPart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga6a15a3de652a757c85b6be392200d65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the millisecond part of the time (in the range 0-999) <br/></td></tr>
<tr class="separator:ga6a15a3de652a757c85b6be392200d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73cf9b62e56dc2bd2f4572479f8df07b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73cf9b62e56dc2bd2f4572479f8df07b"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga73cf9b62e56dc2bd2f4572479f8df07b">XsTimeStamp_secondPart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga73cf9b62e56dc2bd2f4572479f8df07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the seconds part of the time (in the range 0-59) <br/></td></tr>
<tr class="separator:ga73cf9b62e56dc2bd2f4572479f8df07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d5e50f0cfb94cee77e3875d7791246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66d5e50f0cfb94cee77e3875d7791246"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga66d5e50f0cfb94cee77e3875d7791246">XsTimeStamp_minutePart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:ga66d5e50f0cfb94cee77e3875d7791246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minutes part of the time (in the range 0-59) <br/></td></tr>
<tr class="separator:ga66d5e50f0cfb94cee77e3875d7791246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ecd56cfb6fad328170a98a0e0b3d5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9ecd56cfb6fad328170a98a0e0b3d5e"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab9ecd56cfb6fad328170a98a0e0b3d5e">XsTimeStamp_hourPart</a> (const <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *)</td></tr>
<tr class="memdesc:gab9ecd56cfb6fad328170a98a0e0b3d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hours part of the time (in the range 0-23) <br/></td></tr>
<tr class="separator:gab9ecd56cfb6fad328170a98a0e0b3d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471299f2a92ca43888c34e0088f8808d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga471299f2a92ca43888c34e0088f8808d">XsTimeStamp_now</a> (<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *dest)</td></tr>
<tr class="memdesc:ga471299f2a92ca43888c34e0088f8808d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current time in ms since the epoch (Jan 1st 1970)  <a href="#ga471299f2a92ca43888c34e0088f8808d"></a><br/></td></tr>
<tr class="separator:ga471299f2a92ca43888c34e0088f8808d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0466f8867b763d7e97c9191f5c3e5d32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0466f8867b763d7e97c9191f5c3e5d32"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga0466f8867b763d7e97c9191f5c3e5d32">XsTimeStamp_maxValue</a> ()</td></tr>
<tr class="memdesc:ga0466f8867b763d7e97c9191f5c3e5d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of an XsTimeStamp. <br/></td></tr>
<tr class="separator:ga0466f8867b763d7e97c9191f5c3e5d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fc3ee8f0b8597295311adb4ff8c78a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga96fc3ee8f0b8597295311adb4ff8c78a">XsTimeStamp_fromUtcTime</a> (struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *, const struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *utc)</td></tr>
<tr class="memdesc:ga96fc3ee8f0b8597295311adb4ff8c78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps.">XsTimeStamp</a> from an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object.  <a href="#ga96fc3ee8f0b8597295311adb4ff8c78a"></a><br/></td></tr>
<tr class="separator:ga96fc3ee8f0b8597295311adb4ff8c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2760d12880e4b6dcd77dac1be3d1068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad2760d12880e4b6dcd77dac1be3d1068">XsTimeStamp_toUtcTime</a> (struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *, struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *utc)</td></tr>
<tr class="memdesc:gad2760d12880e4b6dcd77dac1be3d1068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the timestamp into an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object.  <a href="#gad2760d12880e4b6dcd77dac1be3d1068"></a><br/></td></tr>
<tr class="separator:gad2760d12880e4b6dcd77dac1be3d1068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga028d330e7bb01b01b7ac831c4fe47b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga028d330e7bb01b01b7ac831c4fe47b71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga028d330e7bb01b01b7ac831c4fe47b71">XsVector_ref</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsSize sz, XsReal *buffer, <a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a> flags)</td></tr>
<tr class="memdesc:ga028d330e7bb01b01b7ac831c4fe47b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the XsVector to refer to the supplied buffer. <br/></td></tr>
<tr class="separator:ga028d330e7bb01b01b7ac831c4fe47b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0f6ef88463c27c0ebd5a16eea4d3b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc0f6ef88463c27c0ebd5a16eea4d3b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafc0f6ef88463c27c0ebd5a16eea4d3b6">XsVector_construct</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsSize sz, const XsReal *src)</td></tr>
<tr class="memdesc:gafc0f6ef88463c27c0ebd5a16eea4d3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the XsVector using <em>sz</em> number of items from <em>src</em>. <br/></td></tr>
<tr class="separator:gafc0f6ef88463c27c0ebd5a16eea4d3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd92f0315fa77840940cd63b25612f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gafd92f0315fa77840940cd63b25612f52">XsVector_assign</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsSize sz, const XsReal *src)</td></tr>
<tr class="memdesc:gafd92f0315fa77840940cd63b25612f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> using <em>sz</em> number of items from <em>src</em>.  <a href="#gafd92f0315fa77840940cd63b25612f52"></a><br/></td></tr>
<tr class="separator:gafd92f0315fa77840940cd63b25612f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82281540cbb4bf44e38d8c9dd455f9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf82281540cbb4bf44e38d8c9dd455f9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf82281540cbb4bf44e38d8c9dd455f9e">XsVector_destruct</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:gaf82281540cbb4bf44e38d8c9dd455f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release and clear the contents of the vector. <br/></td></tr>
<tr class="separator:gaf82281540cbb4bf44e38d8c9dd455f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d7d3e5a0ba913181464ffda5cdda6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5d7d3e5a0ba913181464ffda5cdda6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gad5d7d3e5a0ba913181464ffda5cdda6c">XsVector_copy</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *copy, <a class="el" href="struct_xs_vector.html">XsVector</a> const *src)</td></tr>
<tr class="memdesc:gad5d7d3e5a0ba913181464ffda5cdda6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsVector to <em>copy</em>. <br/></td></tr>
<tr class="separator:gad5d7d3e5a0ba913181464ffda5cdda6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732086e0854c6c1218ca3d1fddc7722c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga732086e0854c6c1218ca3d1fddc7722c"></a>
XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga732086e0854c6c1218ca3d1fddc7722c">XsVector_dotProduct</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *a, const <a class="el" href="struct_xs_vector.html">XsVector</a> *b)</td></tr>
<tr class="memdesc:ga732086e0854c6c1218ca3d1fddc7722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the dot product of XsVectors <em>a</em> and <em>b</em>. <br/></td></tr>
<tr class="separator:ga732086e0854c6c1218ca3d1fddc7722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217ff6e4b3e3624cd6d93e7c4e7b61a3"><td class="memItemLeft" align="right" valign="top">XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga217ff6e4b3e3624cd6d93e7c4e7b61a3">XsVector_cartesianLength</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga217ff6e4b3e3624cd6d93e7c4e7b61a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the cartesian length.  <a href="#ga217ff6e4b3e3624cd6d93e7c4e7b61a3"></a><br/></td></tr>
<tr class="separator:ga217ff6e4b3e3624cd6d93e7c4e7b61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c124e7419bf63e2d3e1682504ca8ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c124e7419bf63e2d3e1682504ca8ff7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c124e7419bf63e2d3e1682504ca8ff7">XsVector_setZero</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga8c124e7419bf63e2d3e1682504ca8ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of the XsVector to 0. <br/></td></tr>
<tr class="separator:ga8c124e7419bf63e2d3e1682504ca8ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c1f360ee7560c392a7b3d09ba3d5d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54c1f360ee7560c392a7b3d09ba3d5d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga54c1f360ee7560c392a7b3d09ba3d5d4">XsVector_fill</a> (struct <a class="el" href="struct_xs_vector.html">XsVector</a> *, XsReal value)</td></tr>
<tr class="memdesc:ga54c1f360ee7560c392a7b3d09ba3d5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements of the XsVector to <em>value</em>. <br/></td></tr>
<tr class="separator:ga54c1f360ee7560c392a7b3d09ba3d5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa653c9dadd824d94c9a5ba32ce6b15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9aa653c9dadd824d94c9a5ba32ce6b15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga9aa653c9dadd824d94c9a5ba32ce6b15">XsVector_empty</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *)</td></tr>
<tr class="memdesc:ga9aa653c9dadd824d94c9a5ba32ce6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-zero value if the <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> does not contain any values. <br/></td></tr>
<tr class="separator:ga9aa653c9dadd824d94c9a5ba32ce6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf11db4e898c308aee2929a1f63582c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf11db4e898c308aee2929a1f63582c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadf11db4e898c308aee2929a1f63582c4">XsVector_multiplyScalar</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> *, XsReal scalar, <a class="el" href="struct_xs_vector.html">XsVector</a> *dest)</td></tr>
<tr class="memdesc:gadf11db4e898c308aee2929a1f63582c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all values in this <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> by <em>scalar</em> and puts the result in <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> <em>dest</em>. <br/></td></tr>
<tr class="separator:gadf11db4e898c308aee2929a1f63582c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6ac21c4bbc663e10723e982150e1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8c6ac21c4bbc663e10723e982150e1b7">XsVector_angularVelocityFromQuaternion</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *, XsReal deltaT, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *quat)</td></tr>
<tr class="memdesc:ga8c6ac21c4bbc663e10723e982150e1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an effective angular velocity from the quaternion, which must represent a delta angle.  <a href="#ga8c6ac21c4bbc663e10723e982150e1b7"></a><br/></td></tr>
<tr class="separator:ga8c6ac21c4bbc663e10723e982150e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7097bb62e03b0dd0bf57efcb2fa54e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga7097bb62e03b0dd0bf57efcb2fa54e7e">XsVector_swap</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *a, <a class="el" href="struct_xs_vector.html">XsVector</a> *b)</td></tr>
<tr class="memdesc:ga7097bb62e03b0dd0bf57efcb2fa54e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of <em>a</em> and <em>b</em>.  <a href="#ga7097bb62e03b0dd0bf57efcb2fa54e7e"></a><br/></td></tr>
<tr class="separator:ga7097bb62e03b0dd0bf57efcb2fa54e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff1df86948c024ea56939838641a05e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5ff1df86948c024ea56939838641a05e">XsVector_equal</a> (const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *a, const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *b)</td></tr>
<tr class="memdesc:ga5ff1df86948c024ea56939838641a05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero when the two vectors are identical.  <a href="#ga5ff1df86948c024ea56939838641a05e"></a><br/></td></tr>
<tr class="separator:ga5ff1df86948c024ea56939838641a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ac3a135a32e7a8656b8e79970029b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5ac3a135a32e7a8656b8e79970029b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gac5ac3a135a32e7a8656b8e79970029b3">XsVector3_construct</a> (<a class="el" href="struct_xs_vector3.html">XsVector3</a> *, const XsReal *src)</td></tr>
<tr class="memdesc:gac5ac3a135a32e7a8656b8e79970029b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsVector3 and copy the data from <em>src</em> into the vector if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:gac5ac3a135a32e7a8656b8e79970029b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fee30a3f5faf7de7db788a4dc6c3ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fee30a3f5faf7de7db788a4dc6c3ba7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5fee30a3f5faf7de7db788a4dc6c3ba7">XsVector3_assign</a> (<a class="el" href="struct_xs_vector3.html">XsVector3</a> *, const XsReal *src)</td></tr>
<tr class="memdesc:ga5fee30a3f5faf7de7db788a4dc6c3ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the XsVector3 and copy the data from <em>src</em> into the vector if <em>src</em> is not null. <br/></td></tr>
<tr class="separator:ga5fee30a3f5faf7de7db788a4dc6c3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e212d7063c29d64cb51f783350bf4e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e212d7063c29d64cb51f783350bf4e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8e212d7063c29d64cb51f783350bf4e3">XsVector3_destruct</a> (<a class="el" href="struct_xs_vector3.html">XsVector3</a> *)</td></tr>
<tr class="memdesc:ga8e212d7063c29d64cb51f783350bf4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the <a class="el" href="struct_xs_vector3.html" title="A class that represents a fixed size (3) vector.">XsVector3</a>. <br/></td></tr>
<tr class="separator:ga8e212d7063c29d64cb51f783350bf4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf489613264450e41927680abe4006b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf489613264450e41927680abe4006b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf489613264450e41927680abe4006b8b">XsVector3_copy</a> (<a class="el" href="struct_xs_vector.html">XsVector</a> *copy, <a class="el" href="struct_xs_vector3.html">XsVector3</a> const *src)</td></tr>
<tr class="memdesc:gaf489613264450e41927680abe4006b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the XsVector3 to <em>copy</em>. <br/></td></tr>
<tr class="separator:gaf489613264450e41927680abe4006b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d30e420e615cf22083a28da03d0e10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78d30e420e615cf22083a28da03d0e10"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga78d30e420e615cf22083a28da03d0e10">XsVersion_empty</a> (const <a class="el" href="struct_xs_version.html">XsVersion</a> *)</td></tr>
<tr class="memdesc:ga78d30e420e615cf22083a28da03d0e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this is a null-version. <br/></td></tr>
<tr class="separator:ga78d30e420e615cf22083a28da03d0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b32669f83122d1211b3b0c31612ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6b32669f83122d1211b3b0c31612ed9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae6b32669f83122d1211b3b0c31612ed9">XsVersion_toString</a> (const <a class="el" href="struct_xs_version.html">XsVersion</a> *, <a class="el" href="struct_xs_string.html">XsString</a> *version)</td></tr>
<tr class="memdesc:gae6b32669f83122d1211b3b0c31612ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the version expressed in a readable format. <br/></td></tr>
<tr class="separator:gae6b32669f83122d1211b3b0c31612ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab97601f7315ae3199adc282b831db7e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab97601f7315ae3199adc282b831db7e7"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab97601f7315ae3199adc282b831db7e7">XsMath_e</a> = 2.7182818284590452353602874713527</td></tr>
<tr class="memdesc:gab97601f7315ae3199adc282b831db7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value e. <br/></td></tr>
<tr class="separator:gab97601f7315ae3199adc282b831db7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6e3d3d1839bb65757ad40636b171d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c6e3d3d1839bb65757ad40636b171d2"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4c6e3d3d1839bb65757ad40636b171d2">XsMath_pi</a> = 3.1415926535897932384626433832795</td></tr>
<tr class="memdesc:ga4c6e3d3d1839bb65757ad40636b171d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value pi. <br/></td></tr>
<tr class="separator:ga4c6e3d3d1839bb65757ad40636b171d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf554bfa4e69e3b27c5f87258b01833de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf554bfa4e69e3b27c5f87258b01833de"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaf554bfa4e69e3b27c5f87258b01833de">XsMath_tinyValue</a> = 1.0e-16</td></tr>
<tr class="memdesc:gaf554bfa4e69e3b27c5f87258b01833de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A really small value. <br/></td></tr>
<tr class="separator:gaf554bfa4e69e3b27c5f87258b01833de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3b28041b0bd6247b2081fffbfc3727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee3b28041b0bd6247b2081fffbfc3727"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gaee3b28041b0bd6247b2081fffbfc3727">XsMath_hugeValue</a> = 1.0e+16</td></tr>
<tr class="memdesc:gaee3b28041b0bd6247b2081fffbfc3727"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convincingly large number. <br/></td></tr>
<tr class="separator:gaee3b28041b0bd6247b2081fffbfc3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efefc2a45e911cd0f39d7912393a189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2efefc2a45e911cd0f39d7912393a189"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2efefc2a45e911cd0f39d7912393a189">XsMath_epsilon</a> = 2.2204460492503131e-016</td></tr>
<tr class="memdesc:ga2efefc2a45e911cd0f39d7912393a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value related to the precisson of floating point arithmetic (2.2204460492503131e-016) <br/></td></tr>
<tr class="separator:ga2efefc2a45e911cd0f39d7912393a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8730deb54c00eeaffccc0cd89f751ef1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8730deb54c00eeaffccc0cd89f751ef1"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8730deb54c00eeaffccc0cd89f751ef1">XsMath_sqrtEpsilon</a> = 1.4901161193847656e-008</td></tr>
<tr class="memdesc:ga8730deb54c00eeaffccc0cd89f751ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of XsMath_epsilon. <br/></td></tr>
<tr class="separator:ga8730deb54c00eeaffccc0cd89f751ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef8e06324e3369662e0a70d1b86d1ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ef8e06324e3369662e0a70d1b86d1ed"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga2ef8e06324e3369662e0a70d1b86d1ed">XsMath_denormalized</a> = 1e-307</td></tr>
<tr class="memdesc:ga2ef8e06324e3369662e0a70d1b86d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value that represents the subnormal number in floating point wizardry. <br/></td></tr>
<tr class="separator:ga2ef8e06324e3369662e0a70d1b86d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5002d16ca92da32aedeb28b4a0c265b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5002d16ca92da32aedeb28b4a0c265b"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gae5002d16ca92da32aedeb28b4a0c265b">XsMath_sqrtDenormalized</a> = 3.1622776601683793319988935444327e-154</td></tr>
<tr class="memdesc:gae5002d16ca92da32aedeb28b4a0c265b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of XsMath_denormalized. <br/></td></tr>
<tr class="separator:gae5002d16ca92da32aedeb28b4a0c265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ed1429bd5b6c6e1c23526af0969bf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga67ed1429bd5b6c6e1c23526af0969bf1"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga67ed1429bd5b6c6e1c23526af0969bf1">XsMath_rad2degValue</a> = 57.295779513082320876798154814105</td></tr>
<tr class="memdesc:ga67ed1429bd5b6c6e1c23526af0969bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to convert radians to degrees by multiplication. <br/></td></tr>
<tr class="separator:ga67ed1429bd5b6c6e1c23526af0969bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ea89ab3df5b3ef0ec5151dba3fb97b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99ea89ab3df5b3ef0ec5151dba3fb97b"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga99ea89ab3df5b3ef0ec5151dba3fb97b">XsMath_deg2radValue</a> = 0.017453292519943295769236907684886</td></tr>
<tr class="memdesc:ga99ea89ab3df5b3ef0ec5151dba3fb97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to convert degrees to radians by multiplication. <br/></td></tr>
<tr class="separator:ga99ea89ab3df5b3ef0ec5151dba3fb97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2a42313dfb3c1b1fb4068e85bd2092"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f2a42313dfb3c1b1fb4068e85bd2092"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga1f2a42313dfb3c1b1fb4068e85bd2092">XsMath_zero</a> = 0.0</td></tr>
<tr class="memdesc:ga1f2a42313dfb3c1b1fb4068e85bd2092"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 <br/></td></tr>
<tr class="separator:ga1f2a42313dfb3c1b1fb4068e85bd2092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c4eab8d61589ad6c75798a479f74ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2c4eab8d61589ad6c75798a479f74ea"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab2c4eab8d61589ad6c75798a479f74ea">XsMath_pt25</a> = 0.25</td></tr>
<tr class="memdesc:gab2c4eab8d61589ad6c75798a479f74ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">0.25 <br/></td></tr>
<tr class="separator:gab2c4eab8d61589ad6c75798a479f74ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bc8cad523dc271cbbb4a7fe8819d242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bc8cad523dc271cbbb4a7fe8819d242"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8bc8cad523dc271cbbb4a7fe8819d242">XsMath_pt5</a> = 0.5</td></tr>
<tr class="memdesc:ga8bc8cad523dc271cbbb4a7fe8819d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">0.5 <br/></td></tr>
<tr class="separator:ga8bc8cad523dc271cbbb4a7fe8819d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac7deb2c99feb885697688f44f275aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabac7deb2c99feb885697688f44f275aa"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabac7deb2c99feb885697688f44f275aa">XsMath_minusPt5</a> = -0.5</td></tr>
<tr class="memdesc:gabac7deb2c99feb885697688f44f275aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">-0.5 <br/></td></tr>
<tr class="separator:gabac7deb2c99feb885697688f44f275aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8bcb595cebc269662be8fbb178cd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a8bcb595cebc269662be8fbb178cd4c"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga5a8bcb595cebc269662be8fbb178cd4c">XsMath_one</a> = 1.0</td></tr>
<tr class="memdesc:ga5a8bcb595cebc269662be8fbb178cd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0 <br/></td></tr>
<tr class="separator:ga5a8bcb595cebc269662be8fbb178cd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1d592f937af3f06b8839a0415f0dbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf1d592f937af3f06b8839a0415f0dbd"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabf1d592f937af3f06b8839a0415f0dbd">XsMath_minusOne</a> = -1.0</td></tr>
<tr class="memdesc:gabf1d592f937af3f06b8839a0415f0dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">-1.0 <br/></td></tr>
<tr class="separator:gabf1d592f937af3f06b8839a0415f0dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a45ccb8ca11408266e4ce06e5d04c80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4a45ccb8ca11408266e4ce06e5d04c80"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga4a45ccb8ca11408266e4ce06e5d04c80">XsMath_two</a> = 2.0</td></tr>
<tr class="memdesc:ga4a45ccb8ca11408266e4ce06e5d04c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 <br/></td></tr>
<tr class="separator:ga4a45ccb8ca11408266e4ce06e5d04c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcca87b18866b7ed7c435da6c7a17484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabcca87b18866b7ed7c435da6c7a17484"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gabcca87b18866b7ed7c435da6c7a17484">XsMath_four</a> = 4.0</td></tr>
<tr class="memdesc:gabcca87b18866b7ed7c435da6c7a17484"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 <br/></td></tr>
<tr class="separator:gabcca87b18866b7ed7c435da6c7a17484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab984b7c0fc78b6252046a91aa874b5d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab984b7c0fc78b6252046a91aa874b5d8"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gab984b7c0fc78b6252046a91aa874b5d8">XsMath_minusTwo</a> = -2.0</td></tr>
<tr class="memdesc:gab984b7c0fc78b6252046a91aa874b5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">-2 <br/></td></tr>
<tr class="separator:gab984b7c0fc78b6252046a91aa874b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3a4325d0e3428720084c3ca05555de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a3a4325d0e3428720084c3ca05555de"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga8a3a4325d0e3428720084c3ca05555de">XsMath_minusHalfPi</a> = -1.570796326794897</td></tr>
<tr class="memdesc:ga8a3a4325d0e3428720084c3ca05555de"><td class="mdescLeft">&#160;</td><td class="mdescRight">-pi/2 <br/></td></tr>
<tr class="separator:ga8a3a4325d0e3428720084c3ca05555de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd74b3381c1548825092aad63a4c1dfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd74b3381c1548825092aad63a4c1dfa"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#gadd74b3381c1548825092aad63a4c1dfa">XsMath_halfPi</a> = +1.570796326794897</td></tr>
<tr class="memdesc:gadd74b3381c1548825092aad63a4c1dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">pi/2 <br/></td></tr>
<tr class="separator:gadd74b3381c1548825092aad63a4c1dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78efef0592e979f9cee61a9aa3c1b92b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78efef0592e979f9cee61a9aa3c1b92b"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga78efef0592e979f9cee61a9aa3c1b92b">XsMath_sqrt2</a> = 1.4142135623730950488016887242097</td></tr>
<tr class="memdesc:ga78efef0592e979f9cee61a9aa3c1b92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sqrt(2) <br/></td></tr>
<tr class="separator:ga78efef0592e979f9cee61a9aa3c1b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723b566b6a4e00659e47aee982f56ada"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga723b566b6a4e00659e47aee982f56ada"></a>
const XsReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cinterface.html#ga723b566b6a4e00659e47aee982f56ada">XsMath_infinity</a> = DBL_MAX</td></tr>
<tr class="memdesc:ga723b566b6a4e00659e47aee982f56ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity value <br/></td></tr>
<tr class="separator:ga723b566b6a4e00659e47aee982f56ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5c9e4b694fa198168f177ddb6f749f54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On Windows: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a>;</div>
</div><!-- fragment --><p>On non-windows: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac1dfbf570dd9179d632bbf3fd163a483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t byteSum </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the sum of the values in the buffer. </p>
<p>This function calculates the sum of the byte values for the first <em>count</em> bytes in the <em>buffer</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>An array of (unsigned) bytes </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes in the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unsigned sum of the byte values in the buffer modulo 256 </dd></dl>

</div>
</div>
<a class="anchor" id="gafb6a5994363a3d4d175eb5a4d42d7452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void validatePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the packet is internally consistent. </p>
<p>This function will throw an exception if there are inconsistencies in the size of the message buffers and the size as reported by the header. </p>

</div>
</div>
<a class="anchor" id="ga6556d22268f56b6dbd77befdbdad0f68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_append </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the <em>other</em> list to thisArray list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The list to append to thisArray list. <em>other</em> may point to thisArray list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7b75e01c27f76b4d91aaa135e4e1a5c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_assign </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>. </p>
<p>This function reinitializes the object reserving space for at least <em>count</em> items in the buffer. <em>count</em> may be 0. If <em>src</em> is not 0, <em>count</em> items will be copied from <em>src</em>. Previous data will be cleared automatically, but the reserved space will not be reduced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of items in src </td></tr>
    <tr><td class="paramname">src</td><td>a pointer to an array of output configuration objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9e7d83d6428ea82a43d4c44167e75c54" title="Reserves space for count items.">XsArray_reserve</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4de36061187ffca3834ee403bfaff57d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void const * XsArray_at </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the item to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the item or NULL if <em>index</em> is out of bounds </dd></dl>

</div>
</div>
<a class="anchor" id="ga5004f8c9e45e57e43b09d6160648591c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * XsArray_atIndex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the item at the supplied <em>index</em> or a null pointer if it is out of bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the item to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the item or NULL if <em>index</em> is out of bounds </dd></dl>

</div>
</div>
<a class="anchor" id="ga63b78f3e6c2315d7e9741a9336781c49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsArray_compare </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero if the lists are different, 0 if they're equal. </p>
<p>This function compares the two lists in-order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The left hand side of the comparison </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal. Please note that not all lists have items that can be accurately tested for less than or greater than, but can be tested for (in-)equality. So the sign of the return value should be treated with knowledge of the data type in mind. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga72561edb500d3e01c3aeb40de6d6a3db" title="Returns -1 if a is smaller in some way than b, 1 if it is larger in some way and 0 if both lists are ...">XsArray_compareSet</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga72561edb500d3e01c3aeb40de6d6a3db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsArray_compareSet </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns -1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal. </p>
<p>This function compares the two lists out-of-order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The left hand side of the comparison </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side of the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <em>a</em> is smaller in some way than <em>b</em>, 1 if it is larger in some way and 0 if both lists are equal. Please note that not all lists have items that can be accurately tested for less than or greater than, but can be tested for (in-)equality. So the sign of the return value should be treated with knowledge of the data type in mind. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga63b78f3e6c2315d7e9741a9336781c49" title="Returns non-zero if the lists are different, 0 if they&#39;re equal.">XsArray_compare</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7222e508e1e5b424ba34648a4e31fd98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_construct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_array_descriptor.html">XsArrayDescriptor</a> const *const&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with space for <em>count</em> items and copies them from <em>src</em>. </p>
<p>This function initializes the object reserving <em>count</em> items in the buffer. <em>count</em> may be 0. If <em>src</em> is not 0, <em>count</em> items from <em>src</em> will be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor</td><td>The descriptor of the data in the list </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to reserve space for. When <em>src</em> is not NULL, thisArray is also the number of items copied from <em>src</em> </td></tr>
    <tr><td class="paramname">src</td><td>A pointer to an array of objects to copy, may be NULL, ignored when <em>count</em> is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga953d7cc7a9ecd8405f2d85b50edc0d56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_copyConstruct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a> with a copy of <em>src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the objects to copy. The object may be empty, but src may not be 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga754df4d700d8f759e3dd29aca3ab629f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_destruct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears and frees memory allocated by the <a class="el" href="struct_xs_array.html" title="Provides generic storage for data in an array and manipulation operations on that data...">XsArray</a>. </p>
<dl class="section note"><dt>Note</dt><dd>After XsArray_destruct is called, the object is empty but valid, ie. it can be used as if XsArray_construct has been called on it. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6969403e331f28f7534cc2945ddcc09c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsArray_find </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of <em>needle</em> in the list or -1 if it wasn't found. </p>
<p>The search does not assume any kind of ordering of the items so in a worst-case scenario it will go through the entire list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>A pointer to the value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of where <em>needle</em> was found or -1 if it wasn't found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1698369198b2417d5b5021a660281297"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_insert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>count</em> items from <em>src</em> at <em>index</em> in the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to use for inserting. Anything beyond the end of the array (ie. -1) will append to the actual end of the array. </td></tr>
    <tr><td class="paramname">count</td><td>The number of items to insert </td></tr>
    <tr><td class="paramname">src</td><td>The items to insert, may not be 0 unless count is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8d1845c9e3d0e754c40807de07208d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_removeDuplicates </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes duplicate entries from the array, keeping only the first instance of each value. </p>

</div>
</div>
<a class="anchor" id="ga9e7d83d6428ea82a43d4c44167e75c54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_reserve </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for <em>count</em> items. </p>
<p>This function reserves space for exactly <em>count</em> items unless <em>count</em> is less than the current list size. The function will retain the current data in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of items to reserve space for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga7b75e01c27f76b4d91aaa135e4e1a5c3" title="Reinitializes the XsArray with space for count items and copies them from src.">XsArray_assign</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee0c5bdd163bb6ca4e295e4ae2f4d1bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_resize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the existing list to <em>count</em> items. </p>
<p>This function will keep the data of the remaining items intact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of items the list should have </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9e7d83d6428ea82a43d4c44167e75c54" title="Reserves space for count items.">XsArray_reserve</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga7b75e01c27f76b4d91aaa135e4e1a5c3" title="Reinitializes the XsArray with space for count items and copies them from src.">XsArray_assign</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad01697484c2c698f779345d64e199a5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsArray_swap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> with those of <em>b</em>. </p>
<p>Where possible, the pointers and administrative values are swapped. If for some reason thisArray is not possible, the lists are swapped one element at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The list to swap with <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>The list to swap with <em>a</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga704fac796d6899e53094d97403927442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate XsBaud_codeToRate </td>
          <td>(</td>
          <td class="paramtype">XsBaudCode&#160;</td>
          <td class="paramname"><em>baudcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Xsens baud code to XsBaudRate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudcode</td><td>: The code to convert to an XsBaudRate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An XsBaudrate </dd></dl>

</div>
</div>
<a class="anchor" id="ga7439bd0c058b38ce73d843d39fcef299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate XsBaud_numericToRate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numeric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a numeric baudrate in bps to XsBaudrate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numeric</td><td>: The numeric baudrate to convert to XsBaudRate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A XsBaudrate </dd></dl>

</div>
</div>
<a class="anchor" id="gaa587d7e451a00e7a3c2c4432c346cf9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudCode XsBaud_rateToCode </td>
          <td>(</td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a XsBaudRate to an Xsens baud code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>: The code to convert to an XsBaudCode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An XsBaudCode </dd></dl>

</div>
</div>
<a class="anchor" id="ga532744ada4da5b1e9c8a277cc98628a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsBaud_rateToNumeric </td>
          <td>(</td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a XsBaudrate to a numeric baudrate in bps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>: The XsBaudRate to convert to a numeric baudrate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A baudrate in bps </dd></dl>

</div>
</div>
<a class="anchor" id="gad1e96881405fc87c270bfbfa2711c792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback handler to the list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab7fab73e2eae146da77c45a460724665"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a>* XsControl_broadcast </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the broadcast device.  </p>
<p>The broadcast device can be used to apply an operation to all connected devices at once (if they support it) </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer representing the broadcast device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga1a57b82050cc78d2bc5db3e4a45274a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the callback handler list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all connected devices as well (true, default) or just the callback handlers of the XsControl object (false) </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="gabb06e76b5652fa33fcc228272bda3cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close all ports and files.  </p>
<p>All devices are put in config mode before the serial port is closed.  </p>

</div>
</div>
<a class="anchor" id="gac5a39a0608c4e7ab990c20175a251e90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_closePort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>portname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portname</em>.  </p>
<p>All connected devices are put in config mode before the port is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portname</td><td>the name of the port to close (e.g. COM1 on Windows, /dev/ttyUSB0 on Linux) </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8246b014d3a477396c9dd512d97f3f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_closePort_1 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the port that is used for communication with the given <em>deviceId</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The device ID to clos eth port for. When 0, the first available port is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the port hosts multiple devices, this function will make all devices connected to the port invalid. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga874056753461eefd2ddd27573ff13627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_closePort_2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"><em>portinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the serial port that matches <em>portinfo</em>.  </p>
<p>All connected devices are put in config mode before the port is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>A port information structure that contains the name of the port to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79" title="Close the serial port with the given portname.">closePort(const XsString&amp;)</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga58e3e638e8535296d9ed8477eb0061fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_closePort_3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portNr</em>.  </p>
<p>All connected devices are put in config mode before the port is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portNr</td><td>The COM port number of the port that should be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only available on Windows systems </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0f37496127474291e93fe41ed74f6f90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_xs_control.html">XsControl</a>* XsControl_construct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562" title="Construct a new XsControl* object. Clean it up with the destruct() function.">construct()</a> function instead.  </p>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed object </dd></dl>
</p>
<p>Construct a new Xsens Device API control object.  </p>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed object </dd></dl>

</div>
</div>
<a class="anchor" id="gaa82cab815f07878eea0ee015ab3cfc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_destruct </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor, calls <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function to clean up object.  </p>
<p>Destroy this XsensDeviceAPI object.All connected devices are put in config mode. All serial ports and files are subsequently closed. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3" title="Close all ports and files.">close()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaec511d6fa250e76c13a531fc338f0caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a>* XsControl_device </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface object associated with the supplied <em>deviceId</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The ID of the device to return, 0 to return the first available main device or XS_DID_BROADCAST to return the broadcast device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> attached to the <em>deviceId</em> or 0 if the device was not found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a90e5245b55d5423b0cb42f5dc37e8afd" title="Returns the broadcast device.">broadcast()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac78e04c47668197a0b72509fc2a1489b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_deviceCount </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of connected devices.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The number of connected devices </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga273d552a680f46e47601aa42f8450a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>* XsControl_deviceIds </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device IDs of all the connected devices.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>Vector containing the device IDs of all the connected devices. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6c2b4d9be6860077f2d86248b0e656ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>* XsControl_dockDeviceId </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device ID of the dock device for the given <em>deviceId</em>.  </p>
<p>This function returns the ID of the docking station that deviceId is plugged into. If the docking station itself is not an open port in this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> or the device is not plugged into a docking station, the function will return a 0 id.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to find the dock parent for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the device that has <em>deviceId</em> docked</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>mainDevice(), isMTwDocked() </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3c530bdcde7bb04b51582adf32f83041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_flushInputBuffers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the inbound data buffers of all devices.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">complete</td><td>When false, only the processed data queue is cleared. When true, the unprocessed data queue is also cleared. </td></tr>
  </table>
  </dd>
</dl>
  </p>

</div>
</div>
<a class="anchor" id="ga8bf16d3145d1c12f52ad8f57b32bc09f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>* XsControl_getDeviceIdFromLocationId </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>locationId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device ID of the device on the given <em>locationId</em>.  </p>
<p>If the location ID is not found, the lastResult value is set and the function returns an null <a class="el" href="struct_xs_device_id.html" title="Contains an Xsens device ID and provides operations for determining the type of device.">XsDeviceId</a>.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationId</td><td>the location ID of the device we're looking for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the device for <em>locationId</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac8e578eff35444c48a8917f849ad109e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_isDeviceDocked </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is an MTw and whether it is docked (or USB connected).  </p>
<p>The function checks if the master device ID is the same as the device ID. If the device ID is not found, the function returns false and the lastResult value is set.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is docked, false otherwise </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga931f28451900dcf98c9fab8e2737140a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_isDeviceWireless </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected.  </p>
<p>If the device ID is not found, the function returns false and the lastResult value is set.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is wirelessly connected, false otherwise </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gafa16988955f61cb3034eef77395633ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_isOptionEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether an option is persistently enabled or not.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled peristently in the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object. This does not mean it is enabled in all connected devices, since it may have been disabled in specific devices by the user. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a0cc1b909edb8a34b0935efbb31d8e841" title="Peristently enable or disable an option.">setOptionEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8dc73a16aa0c92698429b0631a8eb88a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl_lastResult </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result value of the last operation.  </p>
<p>The result values are codes that describe a failure in more detail. </p>
<dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec" title="Get the text for the value returned by lastResult()">lastResultText()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga86a19c01f2f544d49e68b42fcc762a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a>* XsControl_lastResultText </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the text for the value returned by <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a>  </p>
<p>This is a convenience function for </p>
<div class="fragment"><div class="line"><a class="code" href="struct_xs_string.html" title="A 0-terminated managed string of characters.">XsString</a> <a class="code" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec" title="Get the text for the value returned by lastResult()">lastResultText</a> = <a class="code" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">XsControl::resultText</a>(xscontrol-&gt;lastResult());</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga46c18a03a34542a1dbaad6b1f7b742cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a>* XsControl_libraryPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the physical path of the XDA dll.  </p>
<p>This only works on Windows platforms. </p>
<dl class="section return"><dt>Returns</dt><dd>The path where the XDA dll is located. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga96a0a258612316c96df5796ef8f8f4d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_loadFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load filter profile definitions from a settings file with the given <em>filename</em>.  </p>
<p>To use the filtering properly, XDA requires filter settings usually stored in a scenarios.xsb file. XSB is the Xsens Settings Binary format. This function allows you to specify the full path + filename to use instead of the default filter profiles embedded in the dll.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full path+filename to use for loading the parameters. When empty, the default filter profiles are loaded. On Linux this is "./scenarios.xsb", on Windows it is read from the dll resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae1436bec551ee6c4da1f6aedf878cc60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_mainDeviceCount </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of main devices.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>the number of main devices </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a8fecb52cb85a7150ab3b5895f823e374" title="Get the device IDs of the available main devices.">mainDeviceIds()</a>, mainDeviceId(const XsDeviceId&amp;) </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga714d1eb9ee25fc259089a6ed46c223a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>* XsControl_mainDeviceIds </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device IDs of the available main devices.  </p>
<p>Main devices are the devices communicating with the serial port, typically Xbus Masters, AwindA Stations and stand-alone MTis or MTxs. </p>
<dl class="section return"><dt>Returns</dt><dd>a std::vector with the device IDs. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6d9ce27149a78fffa7c08a7a1fae28b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>* XsControl_mainDevices </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface objects.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>A list containing pointers to the main device <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> objects </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga44d8e1378c41638421fece79b8cb6fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_mtCount </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of connected MTs.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>the number of MTs, including both main and child devices.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a6b81e6e2056cbee49272335e93b3584d" title="Get the device IDs of the available MTs.">mtDeviceIds()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gadebcb70851f14af84e3e089e0bd3971d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>* XsControl_mtDeviceIds </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device IDs of the available MTs.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>A std::vector with the device IDs. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a94dae55abd64daeb1a88cbc9f8e55777" title="Get the number of connected MTs.">mtCount</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf0b69aa2989f11d785cda4c57d1db19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_openLogFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the log file with the given <em>filename</em>.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>True is the file was opened successfully. False if an error was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the file to open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a>, loadLogFile(), logFileName() </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3cb2f9f95c5afdf5475f8a95ec7e67c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_openPort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>detectRs485</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel on serial port with the given <em>portname</em>.  </p>
<p>If opening the port is successful, the connected devices are available through the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> interface.The expected value for <em>portname</em> on Microsoft Windows platforms is "COMx" where x is the port number.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portname</td><td>The name of the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#ace2f1637761664f1828e4d7895cdb453" title="Open a communication channel to the given COM portNr.">openPort(int, XsBaudRate, uint32_t, bool)</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8dbe57ee850e68adf99cb35b99642365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_openPort_1 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"><em>portinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel using the details in the supplied XsPortInfo structure.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>Contains the details of the port to open </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>openPort(const XsString &amp;, XsBaudRate, uint32_t) </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gafd07bde97cfa351d370c75e007bb2f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_openPort_2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>detectRs485</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a communication channel to the given COM <em>portNr</em>.  </p>
<p>This is a convenience overload for openPort(const XsString&amp;, XsBaudRate, bool). This function is available on Microsoft Windows only due to the ambiguous nature of port numbers on other platforms.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portNr</td><td>The port number. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port was opened successfully, false otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd" title="Open a communication channel on serial port with the given portname.">openPort(const XsString&amp;, XsBaudRate, uint32_t, bool)</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaeb5451d380cfac67e0cf16ab11105383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> XsControl_queueMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently used queue mode.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The currently selected queue mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a9720f314343d0bc679e5d19d077086d4" title="Set the queue mode to the given mode.">setQueueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a45b86ccc2b443f1c2bfd6c99fefcfe34" title="Get the currently used queue mode.">XsDevice::queueMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga91e5c759c2b7cbb45903247352df7dcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a handler from the list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4e1ba2248bf3a249efec855f347b0c0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a>* XsControl_resultText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>resultCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a descriptive text for the given <em>resultCode</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultCode</td><td>The result code to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>resultCode</em> translated into an XsString </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab148a4920630560c88437a9a4681d095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_setLatLonAlt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>lla</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current GPS position of the system.  </p>
<p>This function will update the Latitude, Longitude and Altitude of the system and all connected devices. This differs from <a class="el" href="struct_xs_control.html#a90e5245b55d5423b0cb42f5dc37e8afd" title="Returns the broadcast device.">broadcast()</a>-&gt;<a class="el" href="struct_xs_control.html#a89b1fba7b2b70c59f7fa09a27deb3815" title="Sets the current GPS position of the system.">setLatLonAlt()</a> in that the setting is persistent for the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> and will be applied to devices connected after the setting has been made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>A vector containing the desired Latitude, Longitude and Altitude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true since the function always succeeds, the boolean return value is for consistency in the interface. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">XsDevice::setLatLonAlt</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga887727f3d0444cb0a1d13fbb5ec4ef8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_setLogPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the path where the xda.log file will be written.  </p>
<p>The xda.log file contains fatal error information and may be useful to determine the cause of application crashes. By default, XDA does not create a log file until this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path where the xda.log should be written, including trailing slash (eg. "C:\\logs\\") </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga787f79e2cabf59cd1fe1ecdec7558b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_setOptionEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peristently enable or disable an option.  </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data. The default state of these options is enabled. On a system with limited resources it may be useful to limit the processing done by XDA. This function remembers the setting and applies it to new devices when they are created as well as broadcasting it to existing devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to enable or disable </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some options depend on each other and thus can cause other options to become enabled or disabled as well. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a4e8d5dcdaf496a1fadba2b6e4e3f2503" title="Returns whether an option is persistently enabled or not.">isOptionEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3445b3e8a8723b5ac00a993a35b4cece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl_setQueueMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the queue mode to the given <em>mode</em>.  </p>
<p>Indicate if a readData call for a live system should get the latest data or the next in queue data or nothing at all. The default queue mode is XQM_CallbackOnly, which means that data is not queued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the new queue mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a10af14e5ee745c50f4565078861c5d70" title="Get the currently used queue mode.">queueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac404b469ed2b928365d5a6ff63ee81ea" title="Set the queue mode to the given mode.">XsDevice::setQueueMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac515d81784d4766fae9b28408fd578da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl_setSerialKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the serial key for XDA.  </p>
<p>Without a valid key XDA will not create any devices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the serial key to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the serial key validates OK, false otherwise </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga453f95a4e626964cf7dfe07382cd999d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl_testSynchronization </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the connected main devices are hardware-synchronized.  </p>
<p>The function will check synchronization settings and initiate some measurements to determine whether the synchronization is correct. </p>
<dl class="section return"><dt>Returns</dt><dd>The function returns XRV_OK when ALL connected devices are synchronized. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should only be called in config mode and only on live devices or it will return an error value. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gadb8de07228c9e10a3d39424e0d14d46a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a>* XsControl_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_version.html">XsVersion</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the version of the XDA dll.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The version information of the XDA dll. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4f1a79f00a7df41b7afdbf35b38b0d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler_addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback handler to the list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0ff02b87fac9fb758346fb7cd84d7f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler_addDevice </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a device to expect data from.  </p>
<p>Use this function to tell the data bundler that it should include data from the supplied device in its bundled data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to add to the internal list of devices to expect data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_data_bundler.html#ae406cdc9ceac2d41d6f57560f0a19d3d" title="Remove a device to expect data from.">removeDevice</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4caf535333470f8ec444a2a6c86924e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>* XsDataBundler_at </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> at a specified index in the current full bundle for which a callback is currently called.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index of the packet in the bundle</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only valid when called from within the data callback functions. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> at a specified index </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac06e9fff4c115fbbcce75054c7d56f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler_clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the callback handler list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all child devices as well (true, default) or just the callback handlers of this XsDevice object (false) </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga2b9c166eaf7e215910c714799231c8a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a>* XsDataBundler_construct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_data_bundler.html#a3aec558cfac70dfcdf264c8b5f5136df" title="Construct a new XsDataBundler* object. Clean it up with the destruct() function.">construct()</a> function instead.  </p>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed object </dd></dl>
</p>
<p>Default constructor, initializes the object.  </p>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed object </dd></dl>

</div>
</div>
<a class="anchor" id="gafef507ea67a16b837ee41d9a94d91a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XsDataBundler_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data packets in the current full bundle for which a callback is currently called.  </p>
<p>This function is only valid when called from within the data callback functions. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of data packets in the current full bundle for which a callback is currently called </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaa07506012a5a75030035294cc5174817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler_destruct </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor, calls <a class="el" href="struct_xs_data_bundler.html#a7a67d3234d66b2e6b2bc1d157ba01830" title="Destruct a XsDataBundler object and free all memory allocated for it.">destruct()</a> function to clean up object.  </p>
<p>Destructor.The destructor unregisters the object from all <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> objects it is attached to and then cleans itself up.  </p>

</div>
</div>
<a class="anchor" id="ga2f0f211beb25ec471f3be91d44f8a9ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>* XsDataBundler_packet </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> sent by a specific device from the current full bundle for which a callback is currently called.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The id of the device that sent the packet</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only valid when called from within the data callback functions. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> send by a specific device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaca92809c6e9a88abd9ae0ed8bd74ecda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler_removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a handler from the list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga9ecb79e7d7b9d1a9b919194b4509cd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataBundler_removeDevice </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device to expect data from.  </p>
<p>Use this function to tell the data bundler that it should no longer include data from the supplied device in its bundled data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to remove from the internal list of devices to expect data from. When NULL is supplied, all devices are removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_data_bundler.html#ae656d6159ec83e47361df9ffe225b0d6" title="Add a device to expect data from.">addDevice</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad5e98663a9c12c541d1c7d8626cd6766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a>* XsDataBundler_toCallbackPlainC </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_data_bundler.html">XsDataBundler</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API.">XsCallbackPlainC</a> pointer that can be used to register the <a class="el" href="struct_xs_data_bundler.html" title="Combines data from multiple sources into one stream.">XsDataBundler</a> as a callback handler </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaa8f40f309a7a5e3aec100dc8414104c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* XsDataFlags_toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga85bc9120949890bf9df4572ee9a95be5">XsDataFlags</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the XsDataFlags to a human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The flags to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a statically allocated memory buffer. Do not free this buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is NOT reentrant, multiple simultaneous calls may cause crashes. Also, later calls will invalidate the results of earlier calls. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1bb2c43334630ab37781b05d5a0a076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDataPacket_altitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position altitude component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>The altitude stored in the packet or XsMath_infinity if no altitude is available </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gaf17e37b4198366ef799fac69e4301ee9" title="Check if data item contains position altitude data.">XsDataPacket_containsAltitude</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaa45af0d8bfc4107fb0c09640cbda1f09" title="The position lat lon alt component of a data item.">XsDataPacket_positionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga74073fd7f88c1d458c6fbb4314d041b9" title="The position latitude longitude component of a data item.">XsDataPacket_latitudeLongitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga984fcbb151bb425bed68fd15f214e530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> * XsDataPacket_analogIn1Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analog in 1 component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> object that the analog in 1 value will be assigned to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> containing the analog in 1 value </dd></dl>

</div>
</div>
<a class="anchor" id="ga742702ec9806c8ce2ad92d3e3bdab699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> * XsDataPacket_analogIn2Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_analog_in_data.html">XsAnalogInData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The analog in 2 component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> object that the analog in 2 value will be assigned to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_analog_in_data.html" title="Data from analog inputs from sensors.">XsAnalogInData</a> containing the analog in 2 value </dd></dl>

</div>
</div>
<a class="anchor" id="gaec420bb6de5d632e4fa3f5e4751ef3f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> * XsDataPacket_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the data items from <em>other</em> to the packet. </p>
<p>The data items contained in <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> <em>other</em> will be appended to this packet. Items that are already contained will not be overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>: The <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> to read the data items from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the updated data packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fddb259bdabf11dcc062770c50f0fb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_calibratedAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calibrated accelerometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> that the calibrated acceleration will be assigned to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gabc6048d525e0e5e7bb504d7a7c08ebb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> * XsDataPacket_calibratedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_calibrated_data.html">XsCalibratedData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the calibrated Data component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>Storage for the requested data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the supplied <em>returnVal</em> filled with the requested data </dd></dl>

</div>
</div>
<a class="anchor" id="ga48f8510e32c5ce64be24aa4e4357977c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_calibratedGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calibrated gyroscope component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b29dfe4997c15a16cc47524353a0b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_calibratedMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calibrated magnetometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gaf17e37b4198366ef799fac69e4301ee9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsAltitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains position altitude data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains position altitude data </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gaf3fd8178e684cfe66bb696540bab029d" title="Check if data item contains position lat lon alt data.">XsDataPacket_containsPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga84873964429e40c3dec1ad5f5cbff300" title="Check if data item contains position latitude longitude data.">XsDataPacket_containsLatitudeLongitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e15bfb90ba4a319b147edd5c69b093f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsAnalogIn1Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains analog in 1 data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains analog in 1 data </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b909a7cf3d951bd587e462167ed8943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsAnalogIn2Data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains analog in 2 data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains analog in 2 data </dd></dl>

</div>
</div>
<a class="anchor" id="ga97126b54948708a4fe4396ed6c1c377f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated accelerometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains calibrated accelerometer data </dd></dl>

</div>
</div>
<a class="anchor" id="ga87c01a1ed158b5e3537fe702377611f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated Data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the packet contains calibrated data or not </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calibrated data is only present if <em>all</em> components are present. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60ed952bed9c7ca76e937ce062a09fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated gyroscope data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains calibrated gyroscope data </dd></dl>

</div>
</div>
<a class="anchor" id="gaef4578f0373d56a4f810bd2b11c75660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsCalibratedMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains calibrated magnetometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains calibrated magnetometer data </dd></dl>

</div>
</div>
<a class="anchor" id="ga74ac53ce205dd1188f542d68cfe4489d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsDetailedStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains detailed status data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains detailed status data </dd></dl>

</div>
</div>
<a class="anchor" id="gad58130ed5eb306a370faf88dd3b5dc83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsFrameRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the datapacket contains a framerange. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the datapacket contains a framerange </dd></dl>

</div>
</div>
<a class="anchor" id="gae1307b6dfe823a65ae9e035295e485f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsFreeAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains free acceleration. </p>
<p>Free acceleration is the acceleration with the local gravity vector subtracted. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains free acceleration </dd></dl>

</div>
</div>
<a class="anchor" id="ga4592f786dece1c41d0a2c480cc83338d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsGpsPvtData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains gps PVT data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains gps PVT data </dd></dl>

</div>
</div>
<a class="anchor" id="ga84873964429e40c3dec1ad5f5cbff300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsLatitudeLongitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains position latitude longitude data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains position latitude longitude data </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gaf3fd8178e684cfe66bb696540bab029d" title="Check if data item contains position lat lon alt data.">XsDataPacket_containsPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaf17e37b4198366ef799fac69e4301ee9" title="Check if data item contains position altitude data.">XsDataPacket_containsAltitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca7c3cdac9092bcabd206fb6a634919d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains orientation Data of any kind. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="ga8aa1b7a6f13ea2bdd22ce75332601b34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPacketCounter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains a packet counter. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains a packet counter </dd></dl>

</div>
</div>
<a class="anchor" id="ga72422178927a7ce88254b0b9e37076da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPacketCounter8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains an 8 bit packet counter. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains an 8 bit packet counter </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3fd8178e684cfe66bb696540bab029d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPositionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains position lat lon alt data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains position lat lon alt data </dd></dl>

</div>
</div>
<a class="anchor" id="ga47889699665bb08e201fae0f3e6eb984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPressure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains pressure data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains pressure data </dd></dl>

</div>
</div>
<a class="anchor" id="gaf45a927643b25f86b659ee60784590c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsPressureAge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains pressure age data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains pressure age data </dd></dl>

</div>
</div>
<a class="anchor" id="gab4cf09e402b3a79ae77f2f2b8319667f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains Raw Accelerometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw acceleration data </dd></dl>

</div>
</div>
<a class="anchor" id="ga517f271754bceccef3989b9b9d939755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw data </dd></dl>

</div>
</div>
<a class="anchor" id="gaf41fa8c51bc0bdd7a948c26f29cb993a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw gyroscope data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw gyroscope data </dd></dl>

</div>
</div>
<a class="anchor" id="ga957722c94b3de10844beb19bceb9499f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawGyroscopeTemperatureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw gyroscope temperature data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw gyroscope temperature data </dd></dl>

</div>
</div>
<a class="anchor" id="gabbd354b23b58b9a25af2ed141dd4ba48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw magnetometer data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw magnetometer data </dd></dl>

</div>
</div>
<a class="anchor" id="gae33c1f5eb46f0e30ecbdb2f5f3f52680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRawTemperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains raw temperature data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains raw temperature data </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f360268043a4fc135884256f00e34e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsRssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the datapacket contains an rssi value. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the datapacket contains an rssi value </dd></dl>

</div>
</div>
<a class="anchor" id="gab69c00776dc3a25fa9a0bf6d178d6e29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSampleTime64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> contains a full 64-bit sample time. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> contains both a fine and coarse sample time </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bd77491910c63fabf11167c66f5dc3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSampleTimeCoarse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item XsDataPacket_contains a sample time coarse. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet XsDataPacket_contains a sample time coarse </dd></dl>

</div>
</div>
<a class="anchor" id="ga00be954b34a7a3697229bfd6f04dccaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSampleTimeFine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item XsDataPacket_contains a sample time fine. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet XsDataPacket_contains a sample time fine </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f5ecc04a489160f62f261de66a02497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsSdiData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains strapdown integration data. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this packet contains sdi data </dd></dl>

</div>
</div>
<a class="anchor" id="gad1713a40540a9d9e74feddde498b429b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains legacy status data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains legacy status data </dd></dl>

</div>
</div>
<a class="anchor" id="gabdb321aba93424a38c986c10972bb4b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsStatusByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns wether the XsDataPacket contains a statusbyte. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this packet contains a statusbyte </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a768d2f6b29b740b110e869b54f682b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsTemperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains temperature data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains temperature data </dd></dl>

</div>
</div>
<a class="anchor" id="ga45de3d34c2383f51ff85c41d042da13f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsTriggerIndication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>triggerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains trigger indication data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerId</td><td>The trigger data identifier to check (e.g. XDI_TriggerIn1 or XDI_TriggerIn2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains trigger indication data </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fddd1161e2606088e18804c47edc0d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsUtcTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains utc time data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains utc time data </dd></dl>

</div>
</div>
<a class="anchor" id="ga075b55f7591d36c2eb93bf4b5e6690fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_containsVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if data item contains velocity NED data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this packet contains velocity NED data </dd></dl>

</div>
</div>
<a class="anchor" id="gab33cedaf486f7ea05478fc1891dbd59e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_coordinateSystemOrientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate system of the first orientation data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the coordinate system of the first orientation data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bb8f791a622d1594b2985a89101e975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_coordinateSystemVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate system of the first velocity data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the coordinate system of the first velocity data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga00224a13a6b7220f43dacf6e90645298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_dataFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dataformat of a specific data identifier in the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: The XsDataIdentifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns XDI_None if the packet does not contain the dataidentifier, the data format otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252" title="Defines the data identifiers.">XsDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa9a426ac35cf230d4d6016ebee6d6c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_range.html">XsRange</a> * XsDataPacket_frameRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the frame range contained in the datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_range.html" title="A class whose objects can be used to store a range. It provides method to check whether a value is in...">XsRange</a> object that will get the range from the packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an <a class="el" href="struct_xs_range.html" title="A class whose objects can be used to store a range. It provides method to check whether a value is in...">XsRange</a> object with the range from the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga67e1ec4bf4fde8f406bc8743eb5eeeb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_freeAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The free acceleration component of a data item. </p>
<p>Free acceleration is the acceleration with the local gravity vector subtracted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the gravity acceleration </dd></dl>

</div>
</div>
<a class="anchor" id="gae0a782bc042f7cc6eb779d78aa5e20b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsDataPacket_getFPValueSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the byte size of <em>id</em> if the format is a floating point format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: The XsDataIdentifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte size of XsDataIdentifier <em>id</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ga159f5666dafb668580256c6af709dce6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> * XsDataPacket_gpsPvtData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The gps PVT data component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_gps_pvt_data.html" title="Data from the GPS unit of a legacy MTi-G.">XsGpsPvtData</a> object to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_gps_pvt_data.html" title="Data from the GPS unit of a legacy MTi-G.">XsGpsPvtData</a> containing the gps PVT data </dd></dl>

</div>
</div>
<a class="anchor" id="ga9652cd8a68c2389fe27822e35d7d4fa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_itemOffsetExact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item offset of the supplied data identifier <em>id</em> using strict matching criteria. </p>
<p>This function will search for an exact match of <em>id</em>, including the subformat. Equivalent to XsDataPacket_itemOffsetMasked(thisPtr, id, XDI_FullMask); </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The data identifier to return the offset off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in the message where the data of this identifier can be found or -1 if it could not be found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#gac8965ee66cdb54fedb30532722588ba6" title="Return the item offset of the supplied data identifier id using loose matching criteria.">XsDataPacket_itemOffsetLoose</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaccc7556dbcc95a99751eca59d41b1001" title="Return the item offset of the supplied data identifier id using matching criteria specified by mask...">XsDataPacket_itemOffsetMasked</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac8965ee66cdb54fedb30532722588ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_itemOffsetLoose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item offset of the supplied data identifier <em>id</em> using loose matching criteria. </p>
<p>This function will ignore the subformat of the data when searching for <em>id</em>. Equivalent to XsDataPacket_itemOffsetMasked(thisPtr, id, ~XDI_SubFormatMask); </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The data identifier to return the offset off </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in the message where the data of this identifier can be found or -1 if it could not be found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9652cd8a68c2389fe27822e35d7d4fa9" title="Return the item offset of the supplied data identifier id using strict matching criteria.">XsDataPacket_itemOffsetExact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaccc7556dbcc95a99751eca59d41b1001"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_itemOffsetMasked </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the item offset of the supplied data identifier <em>id</em> using matching criteria specified by <em>mask</em>. </p>
<p>This function will ignore the bits not in the mask when searching for <em>id</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The data identifier to return the offset off </td></tr>
    <tr><td class="paramname">mask</td><td>The bits to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset in the message where the data of this identifier can be found or -1 if it could not be found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga9652cd8a68c2389fe27822e35d7d4fa9" title="Return the item offset of the supplied data identifier id using strict matching criteria.">XsDataPacket_itemOffsetExact</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gac8965ee66cdb54fedb30532722588ba6" title="Return the item offset of the supplied data identifier id using loose matching criteria.">XsDataPacket_itemOffsetLoose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga74073fd7f88c1d458c6fbb4314d041b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_latitudeLongitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position latitude longitude component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to return the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the latitude and longitude values in that order </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga84873964429e40c3dec1ad5f5cbff300" title="Check if data item contains position latitude longitude data.">XsDataPacket_containsLatitudeLongitude</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaa45af0d8bfc4107fb0c09640cbda1f09" title="The position lat lon alt component of a data item.">XsDataPacket_positionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaf1bb2c43334630ab37781b05d5a0a076" title="The position altitude component of a data item.">XsDataPacket_altitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1605983648c9e678da6b2e04213293d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_euler.html">XsEuler</a> * XsDataPacket_orientationEuler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_euler.html">XsEuler</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the orientation component of a data item as a euler angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>An XsEuler to put the requested orientation in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested orientation. If this does not match the stored coordinate system, it will be transformed to the requested orientation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A XsEuler containing the orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="gad47cd95b1d759e97eecca58161eeee5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_orientationIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data identifier of the first orientation data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the first orientation data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f622e95ca566c0e8627b6b5a362d9d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> * XsDataPacket_orientationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the orientation component of a data item as a orientation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>An XsMatrix to put the requested orientation in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested orientation. If this does not match the stored coordinate system, it will be transformed to the requested orientation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An XsMatrix containing the orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="ga0149c98d71b9bfe8803485775d41f0ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> * XsDataPacket_orientationQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the orientation component of a data item as a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>An XsQuaternion to put the requested orientation in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested orientation. If this does not match the stored coordinate system, it will be transformed to the requested orientation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_quaternion.html" title="A class that implements a quaternion.">XsQuaternion</a> containing the orientation data </dd></dl>

</div>
</div>
<a class="anchor" id="ga6333be127f949ebb5c3cc3839046a86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a>* XsDataPacket_originalMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the original message of the data packet. </p>
<p>This returns the original message that was last set with setMessage, or in the constructor. When the packet was constructed from a legacy message, the legacy message will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>The XsMessage that the message of the packet is copied to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returnVal </dd></dl>

</div>
</div>
<a class="anchor" id="gac897f266dc357670ff551f82edbf7bae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDataPacket_packetCounter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet/frame counter of a packet. </p>
<p>For strapdown integration data, this function will return the m_wlastFrameNumber For other data, this function will return the m_sc</p>
<p>This way there is a function that will always return the counter of a packet</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the packet/frame counter of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="gac33cb466ebe40612bd66801cb3bf65d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsDataPacket_packetCounter8 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 8 bit packet counter of a packet. </p>
<p>This function returns an 8 bit packet counter as used by some third party devices</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the 8 bit packet counter of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="gaa45af0d8bfc4107fb0c09640cbda1f09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_positionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position lat lon alt component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to return the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the latitude, longitude and altitude values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gacb5562328d6b7612efb2263f9216f444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_pressure.html">XsPressure</a> * XsDataPacket_pressure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_pressure.html">XsPressure</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The air pressure component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_pressure.html" title="Pressure data.">XsPressure</a> object to put the requested in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_pressure.html" title="Pressure data.">XsPressure</a> object containing the pressure and if available the pressure age </dd></dl>

</div>
</div>
<a class="anchor" id="gae0f76199c6002f84e70d052f5734cd77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw accelerometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga5604d1a08bfcf788d9dc5cc5143f7008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawGyroscopeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw gyroscope component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d19682f28bbccf51ede5129a489308e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawGyroscopeTemperatureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw gyroscope temperature component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gae5c11ad29680b10e01f52a0f140554be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> * XsDataPacket_rawMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw magnetometer component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: An <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> to put the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_u_short_vector.html" title="A vector containing 3 short values.">XsUShortVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb399f7bef85d6305b33a8c2a8dc9aa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDataPacket_rawTemperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw temperature component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>An uint16_t containing the raw temperature value </dd></dl>

</div>
</div>
<a class="anchor" id="ga30697102dfb8de08d4b8f4b3e5362834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDataPacket_rssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rssi value contained in the datapacket. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the rssi value contained in the datapacket </dd></dl>

</div>
</div>
<a class="anchor" id="gaba3aabf7c48a5972924c6274ca8d28e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDataPacket_sampleTimeFine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fine sample time of a packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the fine sample time of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga954395b7b5af631e31e9b0493acec7b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> * XsDataPacket_sdiData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the strapdown integration data component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>Storage for the requested data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the supplied <em>returnVal</em> filled with the requested data </dd></dl>

</div>
</div>
<a class="anchor" id="gaeffa2fd1c18474fe885b643abb25399f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setAltitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update altitude data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The altitude data to store in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga20fd010f517f69c99199f28a43474a3c" title="Add/update position lat lon alt data for the item.">XsDataPacket_setPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#ga99054a34e98f315e4fd31b6be56a97a9" title="Add/update position latitude longitude data for the item.">XsDataPacket_setLatitudeLongitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga48d69b7bbbd2c6393c908f511085f31d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setFrameRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets or updates the frame range in the datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>: The <a class="el" href="struct_xs_range.html" title="A class whose objects can be used to store a range. It provides method to check whether a value is in...">XsRange</a> object that should be added to the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ebbb512b59c7748a45fa70f3da5c667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setFreeAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update free acceleration data for the item. </p>
<p>Free acceleration is the acceleration with the local gravity vector subtracted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A 3-component vector containing the new free acceleration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9674a10af2e9f0f25da5afb1ea569893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setGpsPvtData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_gps_pvt_data.html">XsGpsPvtData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update gps PVT data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The data to update the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga99054a34e98f315e4fd31b6be56a97a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setLatitudeLongitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update position latitude longitude data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> that contains the latitude longitude data to store in the packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga20fd010f517f69c99199f28a43474a3c" title="Add/update position lat lon alt data for the item.">XsDataPacket_setPositionLLA</a> </dd>
<dd>
<a class="el" href="group__cinterface.html#gaeffa2fd1c18474fe885b643abb25399f" title="Add/update altitude data for the item.">XsDataPacket_setAltitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4598964d5372f185a2b67ba82846ee72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a message in a datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20fd010f517f69c99199f28a43474a3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setPositionLLA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update position lat lon alt data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> that conrtains the Lat/Long/Alt data to store in the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c1939610911dbe628aa86fdaf60e191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setRawAcceleration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_u_short_vector.html">XsUShortVector</a> *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update raw accelerometer data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>: The data to update the <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> with</td></tr>
  </table>
  </dd>
</dl>
<p>This will add the raw acceleration from <em>vec</em> to the data packet. If the packet already contains raw acceleration, it will be replaced. </p>

</div>
</div>
<a class="anchor" id="gaee18c6de4dd432a2361dd981f9c4e7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setRssi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets or updates the rssi value in the datapacket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>: The rssi value that should be added to the packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52705223ff52de6e52f0f8746da3d2da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setSdiData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update strapdown integration data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The updated data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaecd3755ae9c05a6e03db67ae8fa6a178"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setTemperature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>temperature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds or updates the temperature data in the datapacket. </p>
<p>The <em>temp</em> is added to the datapacket. If the packet already contains temperature it is replaced with the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temperature</td><td>: The temperature to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4e80aaced3a3102ad4b6e4cc732eb77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDataPacket_setTriggerIndication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>triggerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> const *&#160;</td>
          <td class="paramname"><em>triggerIndicationData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add/update trigger indication data for the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerId</td><td>The trigger data identifier to add data for (e.g. XDI_TriggerIn1 or XDI_TriggerIn2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerIndicationData</td><td>pointer the a <a class="el" href="struct_xs_trigger_indication_data.html" title="Data for a trigger indication message.">XsTriggerIndicationData</a> buffer containing the data to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8aad732d8ba37df041168b8aa256a49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDataPacket_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The status component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>An uint32_t containing the status value </dd></dl>

</div>
</div>
<a class="anchor" id="gac6d218f313dc1be12638fd38d9fe39a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDataPacket_temperature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The temperature component of a data item. </p>
<dl class="section return"><dt>Returns</dt><dd>A double containing the temperature value, -1000.0 if the packet does not contain temperature </dd></dl>

</div>
</div>
<a class="anchor" id="gad2b22f2e3d9ed049488d6797fb279370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> * XsDataPacket_triggerIndication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>triggerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_trigger_indication_data.html">XsTriggerIndicationData</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trigger indication data of a packet If the packet does not contain the requested data, the return val struct will be set to all zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triggerId</td><td>The trigger data identifier to add data for (e.g. XDI_TriggerIn1 or XDI_TriggerIn2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">returnVal</td><td>pointer to the trigger indication data of a packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returnVal should point to a buffer large enough to hold sizeof(XsTriggerIndicationData) bytes of data </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the trigger indication data of a packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d14dd8d8800650f30c10b8592bcf7c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> * XsDataPacket_utcTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The utc time component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> to return the requested data in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> containing the utc time value </dd></dl>

</div>
</div>
<a class="anchor" id="gaa11d6d994aa40c6f8277081ecadb9216"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> * XsDataPacket_velocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>returnVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>coordinateSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The velocity NWU component of a data item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnVal</td><td>: The <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> to put the data in </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system of the requested velocity. If this does not match the stored coordinate system, it will be transformed to the requested velocity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> containing the x, y and z axis values in that order </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b78a321c23bc634ccfe41730e748824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> XsDataPacket_velocityIdentifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data identifier of the first velocity data of any kind in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>The XsDataIdentifier of the first velocity data of any kind in the packet </dd></dl>

</div>
</div>
<a class="anchor" id="ga08a7239ecb03d1d0dbc2934e6239c07c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_abortFlushing </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the wireless flushing operation and finalize the recording.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if no flushing is in progress when the function exits </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga14c9a1c98604c4eef1eed69b11bd6d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_abortLoadLogFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts loading a logfile.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if loading is aborted successfully </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if no file was currently loading returns false </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac426a9a6668327c75735bd044cb5cb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice_accelerometerRange </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum official value of the accelerometers in the device.  </p>
<p>The actual official range is -accelerometerRange() .. <a class="el" href="struct_xs_device.html#a8fbeb1684b594d94b3abcb5b55f0f335" title="Returns the maximum official value of the accelerometers in the device.">accelerometerRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of the accelerometers in m/s^2 </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga28cd84992f97ea64374de890161cbac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_acceptConnection </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept connections from the device on the parent/master device.  </p>
<p>This function can be used to accept connections from a device that has been rejected. Call this function from within the onConnectivityChanged callback. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device will be accepted next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw rejected to Awinda Station only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7854ff15bf1a2e484a4341ba5d0b2e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback handler to the list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga425c92339b79c1426cc69f86109a209a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_addRef </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase reference count of <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer stay alive while reference counter is not zero Also increases the reference count of each child device with 1.  </p>

</div>
</div>
<a class="anchor" id="ga901bae80b41eec83f3f8969bbc08395a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a>* XsDevice_alignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation matrix to rotate S to the chosen frame S  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to ...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307" title="Retrieve the alignment rotation quaternion.">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the c...">setAlignmentRotationMatrix</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab82176e614b78e8a05f326e1893de24b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a>* XsDevice_alignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation quaternion.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to ...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the c...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S">alignmentRotationMatrix</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0ebafa4863ae3d8f9eff16b5de656d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevice_applyConfigFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a config file(.xsa) and configures the device accordingly.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga24806c3bcac93002f07429c069d0a637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>* XsDevice_availableOnboardFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce" title="Return the list of filter profiles available on the host PC.">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079" title="Gets the filter profile in use by the device for computing orientations.">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028" title="Sets the filter profile to use for computing orientations on the device.">setOnboardFilterProfile</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga9adf31f2e5c951d165f09e0645485e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>* XsDevice_availableXdaFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the host PC.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the host PC </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d" title="Return the list of filter profiles available on the device.">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716" title="Gets the filter profile in use for computing orientations on the host PC.">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c" title="Sets the filter profile to use for computing orientations on the host PC.">setXdaFilterProfile</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3d53adcaeb193459fdef6a6e7f57f19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_batteryLevel </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication.  </p>
<p>XbusMaster: The amount of time remaining for measurement given any battery level greatly depends on the type of batteries used, the number of sensors attached to the Xbus Master and the used output options. Mtw: The last known battery level for this motion tracker. First call </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae2cc7e5d0cdab1740edc9aeb5f724774" title="Request the battery level from the device.">requestBatteryLevel</a> to have a battery level available. The callback </dd>
<dd>
onInfoResponse with ID XIR_BatteryLevel will indicate when the requested battery level is available. This function is available in both config and measurement mode. For devices in wired mode this function can be called without calling </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae2cc7e5d0cdab1740edc9aeb5f724774" title="Request the battery level from the device.">requestBatteryLevel</a> first </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The battery level in the range 0-100 </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf3a5d0bb1f29b5aa3a156327afca6071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate* XsDevice_baudRate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected.  </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#a6c7748ffd37793917d6ce13e464cf2c9" title="The baud rate configured for cabled connection.">serialBaudRate()</a> function in that it will only return the baud rate of the current connection, whereas the <a class="el" href="struct_xs_device.html#a6c7748ffd37793917d6ce13e464cf2c9" title="The baud rate configured for cabled connection.">serialBaudRate()</a> function will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly). </p>
<dl class="section return"><dt>Returns</dt><dd>The baud rate of the serial connection or XBR_Invalid </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gafae6cf0ed7f8961f135405e433f24673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_busId </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bus ID for this device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The bus ID of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad725f8ef14d1bccf9d5206eab09247dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>* XsDevice_children </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the child devices of this device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The child devices of this device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8c17451847c5216daba5d4f0a8ef374f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_clear </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate all fields, possibly removing stuff like filters and calibration info.  </p>

</div>
</div>
<a class="anchor" id="gadee314655b7f989dbba833e40c34a377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_clearCache </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the caches of this device.  </p>

</div>
</div>
<a class="anchor" id="ga276ae344a1491db450443c8b54f37949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the callback handler list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all child devices as well (true, default) or just the callback handlers of this XsDevice object (false) </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf2dc8165edebc1a24a9994359b9dabb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_closeLogFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the log file.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga371831a389bc5772fa5fc399485ab394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>* XsDevice_connectivityState </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connectivity state of the device.  </p>
<p>The connectivity describes how and if the device is connected to XDA. </p>
<dl class="section return"><dt>Returns</dt><dd>The current connectivity of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c" title="XsDevice connectivity state identifiers.">XsConnectivityState</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga9f6b43b41aa8668e46f826981c61c58d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevice_createConfigFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the current device configuration in a config file(.xsa)  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga83bcbcc58ae663664a5c5f7ab8660099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevice_createLogFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a log file for logging.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The desired path and filename of the log file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae4d5420a7f104687e7b350aabf3bf098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_dataLength </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the data in the legacy MTData packets that the device will send in measurement mode.  </p>
<p>This function will only return a value when the device is configured for legacy output, otherwise it will return 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The data size of the MTData packets that will be sent by the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207" title="Sets the legacy output configuration of the device.">setDeviceMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd" title="Returns the legacy output configuration as an XsDeviceMode object.">deviceMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga104505acf91e117647ef5b3897501545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>* XsDevice_dataPacketById </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>packetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a data packet for the device with the supplied <em>packetId</em>.  </p>
<p>This function retrieves the packet with id <em>packetId</em>. Packet IDs are increasing numbers, but they are not always continuous. They are assigned to a packet by XDA based on the availability of time stamps and counters in the data.XDA will use (in this order if they are available): packet counter, sample time, order of arrival of messages. Counters that wrap around at some point are automatically extended to a 64-bit packet ID.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetId</td><td>The specific packet ID to retrieve data for. If a 0 is supplied, the first available item is returned to provide a start-point for further dataPacketById calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packet with the supplied <em>packetId</em> or an empty XsDataPacket if no packet exists with the requested <em>packetId</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>lastResult() </dd>
<dd>
<a class="el" href="struct_xs_device.html#a0a2ab8100043d0622459b73ba134f8f9" title="Retrieve the index&#39;th data packet for the device.">dataPacketByIndex</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8fa8643cae1be3a80a278ca91e5650af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>* XsDevice_dataPacketByIndex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the <em>index'th</em> data packet for the device.  </p>
<p>The function returns item <em>index</em> from the cache, simply counting from 0 onward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The offset of the sample to retrieve, 0-based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packet at the supplied index or an empty XsDataPacket if <em>index</em> is too high </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>lastResult() </dd>
<dd>
<a class="el" href="struct_xs_device.html#a0149482e881275a42cb00bf62f2822ff" title="Retrieve a data packet for the device with the supplied packetId.">dataPacketById</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga892b23a533a48f8b997e91318cea31df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_device.html">XsDevice</a>* XsDevice_deviceAtBusId </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The const <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaedab581c1f3b2f91bb9943f248fd4cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a>* XsDevice_deviceAtBusId_1 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga98b4e1b34a4696a6929a48c4e45533a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a>* XsDevice_deviceConfiguration </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device configuration.  </p>
<p>The device configuration contains a summary of the devices connected to the same port. The function will always return the configuration for the port's main device. </p>
<dl class="section return"><dt>Returns</dt><dd>The device configuration of the port </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaeeaa7176a241b9c18bf9ac080a0675e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>* XsDevice_deviceId </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device ID of the device.  </p>
<p>Each Xsens device has a unique ID. The ID identifies the device as well as the product family it belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>The device ID </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad918781c339b0c3aad2de95bd4aefe48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a>* XsDevice_deviceMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the legacy output configuration as an XsDeviceMode object.  </p>
<p>This function can be used to retrieve the full output configuration of a device in legacy mode. When the device is not in legacy mode, the returned object will indicate that no data will be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>The legacy output configuration of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207" title="Sets the legacy output configuration of the device.">setDeviceMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaa59d6b0eda3ef324247fe98fece1e2cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> XsDevice_deviceState </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the state of this device.  </p>
<p>The device state indiciates whether the device is in config mode, measuring, recording, etc </p>
<dl class="section return"><dt>Returns</dt><dd>The state of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga205fbb4d9bb04ba7a201d9949f2d0fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_disableProtocol </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#ab8e5368ad9948b79ff0d45ec5068b9c6" title="Enable an additional communication protocol when reading messages.">XsDevice::enableProtocol</a>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the removal was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae8df03ab9f8fb0cf1bc733ce07769c50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_disableRadio </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the radio for this station, resetting all children to disconnected state.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae321f1876daa2d3f750252580afcd80a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_droppedPacketCount </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of packets dropped by the port.  </p>
<p>This value can only be detected when the device is configured to have a packet counter or a sample range. It indicates the number of packets that were never received. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dropped packets so far. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6b2b7ef873a12e425901544c7349092b" title="Reset the dropped packet count.">resetDroppedPacketCount</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab16025755416a93905984e5efa4e3816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_enableProtocol </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable an additional communication protocol when reading messages.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the addition was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gacd59e37cfa50acf2cf614d34779c61ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_enableRadio </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the radio channel to use for wireless communication.  </p>
<p>This function can be used to enable or disable the radio of an Awinda Station. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A valid channel number in the range [11..25] or -1 to disable the radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully reconfigured </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga17e567a1373427a84763b1bee353d881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> XsDevice_errorMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error mode of the device (Xbus Master only)  </p>
<p>The error mode tells the device what to do if a problem occurs. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured error mode of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a0de11adb871b12fc84c3a37ae3b83e6d" title="Sets the error mode of the device (Xbus Master only)">setErrorMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga9a51517b9d0dba36d079111d920bfdcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a>* XsDevice_findDevice </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the child device with <em>deviceid</em>.  </p>
<p>This function returns the child device of the current device that matches the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceid</td><td>The device ID to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found XsDevice or 0 if the device could not be found </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga752fe10bd8c2330f115bbb846b80a084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a>* XsDevice_firmwareVersion </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_version.html">XsVersion</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the firmware version.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The firmware version of the live device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The firmware version is not stored in mtb files, so when reading from file this function will return an empty XsVersion object </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaedad213da27e9dc5478be9c0b437d582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_flushInputBuffers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>complete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the inbound data buffers of the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">complete</td><td>When false, only the processed data queue is cleared. When true, the unprocessed data queue is also cleared. </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga18abf6549ee2b0aed00a9a0423090aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_gotoConfig </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device in config mode.  </p>
<p>Device settings can only be changed in config mode, since changing anything during measurement would mess up the sample timing. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in config mode or was already in config mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a4539825a286248b59c66bd89cf7c1090" title="Put this device in measurement mode.">gotoMeasurement</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6c361c712c7eed18b05ef54c3c8d2b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_gotoMeasurement </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put this device in measurement mode.  </p>
<p>Measurement mode is where the device is sampling data and producing inertial and orientation output. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in measurement mode or was already in measurement mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab2b32660f266c44ba18323d1a26b6b7e" title="Put the device in config mode.">gotoConfig</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad5f34f4d2050cdd2a573f942a24e2376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice_gravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'Gravity Magnitude' of the device.  </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'Gravity Magnitude' setting of the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae75f6730561da7c7b54fe591f1209314" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag.">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga46c6a1f52f9176d0f3805bc5411477ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice_gyroscopeRange </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum official value of the gyroscopes in the device.  </p>
<p>The actual official range is -gyroscopeRange() .. <a class="el" href="struct_xs_device.html#a26eb71371914a61505fb133895000937" title="Returns the maximum official value of the gyroscopes in the device.">gyroscopeRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of the gyroscopes in degrees/s </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gadaf36b035e5ddddb9c7f570a3cc9b348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a>* XsDevice_hardwareVersion </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_version.html">XsVersion</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the hardware version of the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The hardware version of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga32b0b026fe4120e8bb37482d940aafc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_hasDataEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac67109aa78da4effcd63ef007810f6e7" title="Returns if the currently configured output contains dataType after processing on the host...">hasProcessedDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0" title="Returns the currently configured update rate for the supplied dataType.">updateRateForDataIdentifier</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gacf588f5257803e28cd1ebe99c99f6bc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_hasProcessedDataEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em> after processing on the host.  </p>
<p>Where <a class="el" href="struct_xs_device.html#aa32dc53bf86ce26b9671d9c4180ecb3b" title="Returns if the currently configured output contains dataType.">hasDataEnabled()</a> only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa32dc53bf86ce26b9671d9c4180ecb3b" title="Returns if the currently configured output contains dataType.">hasDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ad0c9de7bd8ac2786cd7d1d3cd3f46878" title="Return the full output configuration including post processing outputs.">processedOutputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0" title="Returns the currently configured update rate for the supplied dataType.">updateRateForDataIdentifier</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga68d46f0fabd260391848e2ba5593e530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice_headingOffset </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the 'heading offset' setting of the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The currently configured heading offset in degrees </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf14503f0d88b547789f165f95ad87cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_initializeFilter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the filter used by this device.  </p>
<p>This function will restart the filter used on the PC for computing orientations </p>
<dl class="section return"><dt>Returns</dt><dd>true if the filter was successfully (re-)initialized </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga1f33a324b590970a580713b5ceb07bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the device has its BlueTooth radio enabled (Xbus Master only)  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the device has its BlueTooth radio enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae951952646d9e109e6f04b1b90b9bdee" title="Enable or disable the BlueTooth radio of the device (Xbus Master only)">setBlueToothEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac6319695dc214b742f6eb5410636e2d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the Xbus Master is powering its child devices or not.  </p>
<p>When the bus power is off, the child devices are disabled </p>
<dl class="section return"><dt>Returns</dt><dd>true If the Xbus Master is currently providing power to its child devices </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga401cf56b1145730f773e1a19ef5c15d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isDualOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the device is sending output over its BlueTooth radio and over the serial connection (Xbus Master only)  </p>
<p>When configured like this, the Xbus Master still only accepts commands on its BlueTooth connection. This is mostly useful when trying to troubleshoot wireless connectivity issues. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is configured for dual output mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#afe553d06248b87484637c090e0541108" title="Enable or disable the BlueTooth radio of the device (Xbus Master only)">setDualOutputEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga2758964cce8ae31eab1fd6690de71b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the fixed gravity value should be used or if it should be computed from the LatLonAlt value.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a33a317dc6368a72e2a5bcb8c46c3f3e5" title="Sets whether the fixed gravity value should be used or if it should be computed from the LatLonAlt va...">setFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga30b0eb860ad3a229132acfff784eb9a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the device does gyroscope bias estimation when switching to measurement mode.  </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a5a6ebbd9e51082930fdd5abcc6879a34" title="Set the no rotation period to duration.">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a38bdd87c62c9fdea175acaf98e5d0e49" title="Set if the device does gyroscope bias estimation when switching to measurement mode.">setInitialBiasUpdateEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga2888024c9ec677ddbd73e681254bc6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isInitialized </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the device is initialized.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true when the device has been initialized </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga35fea1d072eeae5938ac04023e964e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isInLegacyMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the device is outputting data in legacy mode.  </p>
<p>In legacy mode all data is sent as MTData packets at the same update rate and not all Mk4 output types are available. When not in legacy mode, data is sent as MTData2 packets and may arrive at different update rates depending on the type of data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is configured for legacy mode output. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga1cb4f5d5d1e47b12df7b1d846e00439b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isInStringOutputMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the device is outputting data in string mode.  </p>
<p>In string mode only NMEA packets are transmitted at the legacy update rate </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is configured for string mode output. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga66dd3a2f2535c3dbe9927d5b23d8e0ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isInSyncBoxMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p><dl class="section return"><dt>Returns</dt><dd>true when the device is in Sync Box mode (Awinda Station only) </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab74c67a2851082d707abc1703d3eb3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isMasterDevice </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this is the master device (not a child of another device)  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if this is the master device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0e18679976d487a4ec0bcb019cbaa67f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isMeasuring </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a measuring state.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a measuring state </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab0ce8a92edf2e45874ce642a0ec21955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isMotionTracker </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this is a motion tracker.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if this is a motion tracker or false if it is a master device such as an Awinda Station or an Xbus Master </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga1a94468f0c2531aedefaabf19232a337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isOperational </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p><dl class="section return"><dt>Returns</dt><dd>true when the device is operational </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>AwindaStationDevice::makeOperational() </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5c820010c978c684903e6a2d402eb3ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isOptionEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a processing option is enabled or not.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a59f5dfc2bd1168a70d1e7f2335cdb5a8" title="Enable or disable a processing option.">setOptionEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gadc28e9c468bd06725a327c82fca09818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isProtocolEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p><dl class="section return"><dt>Returns</dt><dd>true when a protocol with type <em>type</em> has been added </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>The protocol type to check </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="gad7a2e38147c7d707bfcdf43cb5ec0832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isRadioEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the radio is enabled.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the radio is enabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7e8a2f97ab635be446b14de3d31292eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isReadingFromFile </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the device is reading from a file.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the device is reading from a file </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7fc4626713a8d46822d1c84acd9229f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isRecording </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a recording state.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a recording state </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga70dab11f1a4389403732ea76722e9d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isSyncMaster </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether this device is in a master role regarding the device synchronization  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization master role </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gabca48050228c8e3d5815d1ed57f4b5c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_isSyncSlave </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether this device is in a slave role regarding the device synchronization  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization slave role </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae4f86796fdea4468a4f7c37b612d2b66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a>* XsDevice_labMagneticField </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'Lab Magnetic Field' of the device.  </p>
<p>The Lab Magnetic Field is the earth magnetic field where the measurements are done. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'Lab Magnetic Field' setting of the device. This is either a 3-element vector or an empty vector. When the vector is empty or all 0 values, the setting is not used by the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6a9a445b82dfb0cc5b3dce96722cc289" title="Sets the &#39;Lab Magnetic Field&#39; of the device to the given vector.">setLabMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf10b0a703c516121b81816b517854243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t XsDevice_lastKnownRssi </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last known RSSI value of the device.  </p>
<p>RSSI values are only relevant for wireless devices. Since the value is measured passively, any time an RSSI value is received by XDA, the last known value is updated. </p>
<dl class="section return"><dt>Returns</dt><dd>The last known biased RSSI value or XS_RSSI_UNKNOWN if no RSSI value is available (yet) </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6c134d84f62b87e63b8c0e7feebef66f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a>* XsDevice_latLonAlt </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the 'Latitude Longitude Altitude' setting of the device.  </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. </p>
<dl class="section return"><dt>Returns</dt><dd>lla The desired 'Latitude Longitude Altitude' setting for the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab" title="Returns the &#39;Lab Magnetic Field&#39; of the device.">labMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga64c337874d7ccc052b3867b35f5fcd31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_loadLogFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a complete logfile.  </p>
<p>Load the opened log file completely. This function loads all data from the open logfile in a separate thread, generating onProgressUpdated callbacks. This function will return true if the reading was scheduled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the threaded loading was successfully started </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>onProgressUpdated </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad5b5cd858739361e0c9e7162e4139791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_locationId </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the location ID of the device.  </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p>
<dl class="section return"><dt>Returns</dt><dd>The current location ID stord in the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a4a46ea2a77ab9a0a392ebf7b21ebd46d" title="Set the location ID of the device.">setLocationId</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac4925a997b89c889a349c9c11e310d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a>* XsDevice_logFileName </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the log file the device is reading from.  </p>
<p>Returns an empty string when not in file mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the logfile </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga45568a2353e6b07375a3f91c8805eedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevice_logFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current read position of the open log file.  </p>
<p>If the function encounters an error the function returns -1. </p>
<dl class="section return"><dt>Returns</dt><dd>The current read position (in bytes) from the start of the file or -1 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a2b20b09509ae122b7b72129a1689f081" title="Get the size of the log file the device is reading from.">logFileSize</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gabd5579af141e879efb50048942920038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevice_logFileSize </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the log file the device is reading from.  </p>
<p>If the function encounters an error the function returns 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the log file or 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af5b4bcf9503a0e531de04d40fb05dc0d" title="Get the current read position of the open log file.">logFileReadPosition</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga13d8c392a61d7163f0217b7c4cf4e039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_makeOperational </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets te Awinda station to operational state.  </p>
<p><dl class="section note"><dt>Note</dt><dd>this is considered an extension to the config state, not a new state. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when the awindastation is put in operational mode. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga115250037637279b60ec456fb7d6017f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a>* XsDevice_master </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the master device of this device.  </p>
<p>This function returns the master device of the current device. This may be the device itself </p>
<dl class="section return"><dt>Returns</dt><dd>The master device of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4d6d065d058d93d15f4dcc3fca27ead7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_maximumUpdateRate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum update rate for the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The maximum update rate of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a358a87088eeee36a8be981d95cd252f0" title="Ask the device for its supported update rates for the given dataType.">supportedUpdateRates</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4cfd3b8e038c3fe9a75c4ea73057ecd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>* XsDevice_nextAvailableDataPacket </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next data packet in the live stream.  </p>
<p>The function returns the first item in the packet queue and removes it from the queue. If there are no packets in the queue, an empty XsDataPacket is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>The requested XsDataPacket if available or an empty one if the queue is empty </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga08162bf38bbc8fbbd8638d9550a2665b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a>* XsDevice_objectAlignment </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the object alignment matrix of the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The current 'object alignment matrix' setting of the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>setObjectAlignmentMatrix() </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6595dd547b4e4a1ca4d0a0231b74110b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>* XsDevice_onboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the filter profile in use by the device for computing orientations.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028" title="Sets the filter profile to use for computing orientations on the device.">setOnboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716" title="Gets the filter profile in use for computing orientations on the host PC.">xdaFilterProfile</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga52b4da552d60f0e5ad0975065615e6eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>* XsDevice_outputConfiguration </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently configured output of the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The output configuration of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga00a778d52f507c0a9e0fcbd20cfaaeea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a> XsDevice_outputMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output mode.  </p>
<p>In legacy output mode, the output mode combined with the output settings define which data is sent by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output mode' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad411e49744b4a2fb53b59b7a4616a240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a> XsDevice_outputSettings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output settings.  </p>
<p>In legacy output mode, the output mode combined with the output settings define which data is sent by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output settings' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac4a047956060ff6d68743023b61b3292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice_outputSkipFactor </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output skip factor.  </p>
<p>In legacy output mode, the output skip factor combined with the sample period define the rate at which data is sent by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output skip factor' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga675bde3ebc205e6e5884d33eeb7f37d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a> XsDevice_peekMessageId </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a peek at the next message's message ID in the file.  </p>
<p>This function can be used to look ahead in a file without having XDA do any processing. If the device is not a main device, the corresponding main device will be queried instead. The data returned is not necessarily the data for this device when reading from a stream that contains data for multiple devices. </p>
<dl class="section return"><dt>Returns</dt><dd>The Xsens Xbus message ID of the next message or XMID_InvalidMessage if no more messages are available. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To avoid confusion it is recommended to always use the main device when calling this function. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga49d320267f604321c745822d8896e222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a>* XsDevice_portName </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The port name of the connection.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The name of the communication port or an empty string if not connected to a communication port </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5c2014d2c4c0f043a590e4a9c537c94b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_portNumber </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the port number of the connection.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The port number or 0 if no port is open that can be identified by a single number </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7ac8ddf3b5e663766f7b002c089da498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_powerDown </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the device to power down completely (Xbus Master only)  </p>
<p>This function can be used to tell the device to shut down completely, requiring a physical button press on the device to power up again. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully powered down </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac13abf7bef0fad2e4e3b2a9fa5f3828a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>* XsDevice_processedOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the full output configuration including post processing outputs.  </p>
<p>This function return the list returned by <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> and adds outputs that become available during post-processing. </p>
<dl class="section return"><dt>Returns</dt><dd>The requested output configuration list </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6353605129f7e35d1c052e182e7cc77b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a>* XsDevice_productCode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the product code of the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The product code of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae93eba46bc4d58a3d0c80d183fc2081a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_queueLength </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of items currently in the cache for the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The number of packets that are ready to be read from the live queue </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga588928e550376412fd3c5ff048734556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> XsDevice_queueMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently used queue mode.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>the currently selected queue mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ac404b469ed2b928365d5a6ff63ee81ea" title="Set the queue mode to the given mode.">setQueueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a10af14e5ee745c50f4565078861c5d70" title="Get the currently used queue mode.">XsControl::queueMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga71ba9f8c5c5a33147e4d2d2f9a404947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_radioChannel </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the radio channel used for wireless communication.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The radio channel used for wireless communication or -1 if the radio is disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga85a3729ce4e995ccc0f9ecf751cdb89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_refCounter </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current reference counter.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The current reference count </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8cdd8400ff6613e6bb721363d0441ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_reinitialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>.  </p>
<p>This function will read all configuration details freshly from the device and will reinitialize all filters. Especially when you have made changes to the device configuration outside XDA or through <a class="el" href="struct_xs_device.html#a3589494a7043c386d42fc147301748c5" title="Send a custom message messageSend to the device and possibly wait for a result.">sendCustomMessage()</a> it is advisable to call this function so XDA will show the correct state of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reinitialized </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device itself is not reset, but will be put in config mode while the settings are being updated. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga9f392866b0b0a69f6974bf961d7106c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_rejectConnection </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reject connections from the device on the parent/master device.  </p>
<p>This function can be used to reject connections from a device that has connected. This function can be called from within the onConnectivityChanged callback or at other times when a device is connected. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device will be rejected next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After the function returns, this <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> should no longer be used. </dd>
<dd>
MTw connected to Awinda Station only </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a729def5c76bfd153ae0761014f2588d0" title="Returns the reason why a device&#39;s connection was rejected.">rejectReason</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad6f365d72af98216e8631c0018fa537b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a> XsDevice_rejectReason </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reason why a device's connection was rejected.  </p>
<p>This function is typically called from within the onConnectivityChanged callback when the connectivity has changed to XCS_Rejected. </p>
<dl class="section return"><dt>Returns</dt><dd>The reason why the connection was rejected </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae5628642c3b68a4e20399da909fb0882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a handler from the list.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga237ac924a24a256b0fb54ae14286cf3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_removeRef </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1.  </p>
<p><ul>
<li>If it is a child device, it will delete itself when the reference count reaches zero. It will also remove itself from its master's child list and ask the master if it can be deleted</li>
<li>If it is a master device, it will delete itself when the reference count reaches zero and the reference count of all children is zero. </li>
</ul>
 </p>

</div>
</div>
<a class="anchor" id="ga493527794566c1a5cac963e0cf2f489d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_replaceFilterProfile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *&#160;</td>
          <td class="paramname"><em>profileCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *&#160;</td>
          <td class="paramname"><em>profileNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces profileCurrent by profileNew in the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileCurrent</td><td>The profile that should be replaced </td></tr>
    <tr><td class="paramname">profileNew</td><td>The new profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaff7a649d821feee34eb62f1773328347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_requestBatteryLevel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the battery level from the device.  </p>
<p>This is an asynchronous operation. The Awinda station or MTw sends the battery level when possible. For devices in wired mode the </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ad9a5dd4a13161a69e4927191a7295cd3" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">batteryLevel()</a> function can be called without calling this function first. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true If the battery level request was successfully sent </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga62fc9374c41bcd69a4944248af4849ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_requestData </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request data when configured in legacy mode with infinite skip factor.  </p>
<p>When configured in legacy mode and an output skip factor of 0xFFFF, the device will not send data by itself, but will instead send the latest data after receiving an explicit request. This function is that request. After the request, the normal callback mechanism will take over. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga41f9da7a2d99d151e20eb57ed426f7eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the device.  </p>
<p>This function tells the device to reboot itself. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reset </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0755cc7df836cb7d82560db0fbce8035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_resetDroppedPacketCount </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the dropped packet count.  </p>
<p><dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af46c1ca0b7962af4334aa765bfb5155a" title="Get the number of packets dropped by the port.">droppedPacketCount</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the packet count has been successfully reset to 0 </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga50da46c88502787679b6209f3000c840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_resetLogFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the read position of the open log file to the start of the file.  </p>
<p>If software filtering is enabled, the appropriate filters will be restarted as if the file was just opened. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the read position was successfully reset to the start of the file </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab043c28de7ce0a55da322b4b26354ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_resetOrientation </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a>&#160;</td>
          <td class="paramname"><em>resetmethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an orientation reset on the device using the given <em>resetMethod</em>.  </p>
<p>This function schedules an orientation reset command to be applied in the first available orientation filter update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetmethod</td><td>The requested orientation reset method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the orientation reset was successfully scheduled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>XRM_StoreAlignmentMatrix can only be used in config mode, the others only in measurement mode </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaedc88a0e3e0e90ca2b0cfc18c7593ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_restartFilter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>restart the filter used by this device  </p>

</div>
</div>
<a class="anchor" id="ga6cee7d5dd56589754ab39f143493d7b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_restoreFactoryDefaults </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the device to its factory default settings.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if the settings have been successfully restored </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8d8885efce73c436193cca9324ba9645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice_rs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transmission delay used for RS485 transmissions.  </p>
<p>See the low level documentation for more information on this function. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured RS485 transmission delay </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga1dc089b48704b61b33c33d4bb96c9255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a>* XsDevice_runSelfTest </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the self test for the device.  </p>
<p>All Xsens devices have limited self-diagnostic functionality, which can be triggered by calling this function. The device automatically does some self tests during startup, but this function returns more information. </p>
<dl class="section return"><dt>Returns</dt><dd>Results of the test </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and can take a few 100 ms </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga48b005dc85df40251142f7d33f188cb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice_samplePeriod </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sample period.  </p>
<p>In legacy output mode, the output skip factor combined with the sample period define the rate at which data is sent by the device. The sample period is set in units of 1/115200 seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'sample period' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6d3e43d391898ef292808326f2bd7cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_sendCustomMessage </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>messageSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>waitForResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>messageReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a custom message <em>messageSend</em> to the device and possibly wait for a result.  </p>
<p>If <em>waitForResult</em> is true, the function will wait for a result and put it in the given <em>messageReceive</em>. Otherwise the contents of messageReceive will not be altered. If an error message is received or the wait times out, <em>messageReceive</em> will contain an error message.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSend</td><td>The message to send to the device </td></tr>
    <tr><td class="paramname">waitForResult</td><td>true if it is required that the function waits for the appropriate reply. A valid reply always has a message ID that is one higher than the sent message ID. </td></tr>
    <tr><td class="paramname">messageReceive</td><td>When <em>waitForResult</em> is true, the reply will be put in this object. </td></tr>
    <tr><td class="paramname">timeout</td><td>Optional timeout in ms. When 0 is supplied (the default), the default timeout is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent and when <em>waitForResult</em> is true the correct reply has been received </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab5634ddaba4cc5a16f6b474885a1b3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_sendRawMessage </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message directly to the communicator.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message that will be send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga69feb6c87e988db55fe3817fe42a9db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate* XsDevice_serialBaudRate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The baud rate configured for cabled connection.  </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#a613cd4d200015a0e457c29ddcb689152" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function in that it will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly), whereas the <a class="el" href="struct_xs_device.html#a613cd4d200015a0e457c29ddcb689152" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function will return the baud rate of the current connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The configured baud rate </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5860923160341562c43ea3f5da351bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setAlignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the chosen frame S  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">matrix</td><td>The desired alignment rotation setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to ...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307" title="Retrieve the alignment rotation quaternion.">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S">alignmentRotationMatrix</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga63113b75edf8d7f16f701a182c8b5a5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setAlignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to the chosen frame S  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">quat</td><td>The desired alignment rotation setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307" title="Retrieve the alignment rotation quaternion.">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the c...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S">alignmentRotationMatrix</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga451e7c3e1f7bbca6902ac072cc2b9f8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the BlueTooth radio of the device (Xbus Master only)  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to enable the BlueTooth radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab1db7aa59f179672f34b3026941053ff" title="Returns true if the device has its BlueTooth radio enabled (Xbus Master only)">isBlueToothEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5539f6a7d8abc5fa633951b7c21c44c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the Xbus Master to provide power to its child devices or not.  </p>
<p>This function can be used to tell the Xbus Master to stop and start powering its child devices. By default when the Xbus Master starts up it will provide power to its child devices. Switching the power off can save a lot of energy, but powering the system up again will take some time, depending on the number of connected devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable bus power, false to disable the bus power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the Xbus Master's bus power state was successfully updated. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gafd0e915e3b33b2e2b587d3b27130d43c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setDeviceAccepted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accepts a device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to accept </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been succesfully accepted </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4775d23ad08d8e4b5186b48314d26043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setDeviceMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the legacy output configuration of the device.  </p>
<p>This function can be used to switch to legacy output mode and set the full output configuration of the device in legacy mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired legacy output configuration for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully configured </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd" title="Returns the legacy output configuration as an XsDeviceMode object.">deviceMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5c9ae201860023e86437e4719ae4a804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setDeviceRejected </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> *&#160;</td>
          <td class="paramname"><em>deviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rejects a device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to reject </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been succesfully rejected </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga69555474816894135e201867491beb05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setDualOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the BlueTooth radio of the device (Xbus Master only)  </p>
<p>When configured for dual output mode this, the Xbus Master still only accepts commands on its BlueTooth connection, which must be enabled for this function to work. This configuration is mostly useful when trying to troubleshoot wireless connectivity issues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to enable dual output mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab576743221b08c8e04f802e5fad8feaf" title="Returns true if the device is sending output over its BlueTooth radio and over the serial connection ...">isDualOutputEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab1db7aa59f179672f34b3026941053ff" title="Returns true if the device has its BlueTooth radio enabled (Xbus Master only)">isBlueToothEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7f8dd28c41c94af5b949b058d1ab421b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setErrorMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td>
          <td class="paramname"><em>errormode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the error mode of the device (Xbus Master only)  </p>
<p>The error mode tells the device what to do if a problem occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errormode</td><td>The desired error mode of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a57c6e0f5be723782b0ae6440be696ea9" title="Returns the error mode of the device (Xbus Master only)">errorMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaabdf2adfeb1c4914559adf051b691e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the fixed gravity value should be used or if it should be computed from the LatLonAlt value.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to use fixed gravity, false to compute from LatLonAlt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ac9dcf8b4f2aad25e547a44a4858d4a23" title="Returns if the fixed gravity value should be used or if it should be computed from the LatLonAlt valu...">isFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae75f6730561da7c7b54fe591f1209314" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag.">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga86fe597420621e768f13ca9e5a5cd001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_setGotoConfigOnClose </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gotoConfigOnClose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On closePort the device will go to config by default, with this function it is possible to prevent that.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gotoConfigOnClose</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3930a26da06230ed2429128602c360a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setGravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>.  </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mag</td><td>The desired 'Gravity Magnitude' setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Gravity Magnitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default value is usually computed from the last known Lat Lon Alt value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae466d3d3551c6892d8603f9202777b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setHeadingOffset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the 'heading offset' setting of the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The desired heading offset of the device in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3de2b22639ce8ad7a5d6081fe4ac3649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set if the device does gyroscope bias estimation when switching to measurement mode.  </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a5a6ebbd9e51082930fdd5abcc6879a34" title="Set the no rotation period to duration.">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a782d2d345c99aa2039fdc3298ae994a7" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gace30fc664530c201d05c689f5bc29212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setLabMagneticField </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>magfield</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the 'Lab Magnetic Field' of the device to the given <em>vector</em>.  </p>
<p>The Lab Magnetic Field is the earth magnetic field where the measurements are done. Setting this value allows more accurate north reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">magfield</td><td>The desired 'Lab Magnetic Field' setting of the device. This should be a 3-element vector. When the vector is empty or all 0 values, the setting is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Lab Magnetic Field was successfully written </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab" title="Returns the &#39;Lab Magnetic Field&#39; of the device.">labMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8462cf6a3d008e18eef4619ee02ecc64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setLatLonAlt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>lla</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>.  </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. The default gravity magnitude and earth magnetic field are computed form this value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>The desired 'Latitude Longitude Altitude' setting for the device. This should be a 3-element vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Latitude Longitude Altitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When GPS is available, this value is automatically updated with the last known position when the device is put in config mode after measurement. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab" title="Returns the &#39;Lab Magnetic Field&#39; of the device.">labMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga4245d6d59921f1db3b26db7974fdd6fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setLocationId </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location ID of the device.  </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The desired location ID for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Location ID was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6cd80807c1e9d0dcf3fd4b0481ef3de2" title="Get the location ID of the device.">locationId</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga92891e663023f1f4c353eb198f338ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setNoRotation </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the no rotation period to <em>duration</em>.  </p>
<p>This function can be called in both config and measurement modes. In config mode it specifies the duration that the device is considered to be stationary as soon as it enters measurement mode. In measurement mode, it specifies the duration that the device is considered to be stationary, starting immediately.During the stationary period, the gyroscope biases are measured, giving better performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The desired stationary duration in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the no rotation command was accepted by the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a782d2d345c99aa2039fdc3298ae994a7" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a38bdd87c62c9fdea175acaf98e5d0e49" title="Set if the device does gyroscope bias estimation when switching to measurement mode.">setInitialBiasUpdateEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6fba448ad00e8d6e506f9056b8568625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setObjectAlignment </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the object alignment of the device to the given <em>matrix</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The desired 'object alignment matrix' setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object alignment matrix was successfully written </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>objectAlignmentMatrix </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6293cd64825503e7872e19872cbe0c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setOnboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the device.  </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d" title="Return the list of filter profiles available on the device.">availableOnboardFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d" title="Return the list of filter profiles available on the device.">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079" title="Gets the filter profile in use by the device for computing orientations.">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c" title="Sets the filter profile to use for computing orientations on the host PC.">setXdaFilterProfile</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0d1861f21718630fc4e37f4bbbe86e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setOptionEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable a processing option.  </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data. The default state of these options is enabled. On a system with limited resources it may be useful to limit the processing done by XDA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to enable or disable </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the option was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some options depend on each other and thus can cause other options to become enabled or disabled as well. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae0da29c15d3aaf244711c98c48c128e9" title="Returns whether a processing option is enabled or not.">isOptionEnabled</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga89f9cab62ad8270a3da396432469dfa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output configuration for this device When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.  </p>
<p><em>config</em> is updated to reflect frequency mismatches in desired configuration and actually possible configuration. As input, a frequency of 65535 (0xFFFF) may be supplied to indicate 'maximum output rate', but after configuration XDA will have put the actual maximum value in <em>config</em>. Similarly, some data types may not have a real update rate (ie. packet counter) and will return an update rate of 65535 (0xFFFF) when configured at any rate other than 0.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The desired output configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output configuration was successfully updated </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga00c48b3146a7675ba240a6b0ad1b2a9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setOutputMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the outputmode for this device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired 'output mode' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6858b0e1ff701f8c8312b0085626e3f7" title="Set the output settings for this device.">setOutputSettings</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gadf24f6099e011cf5d51968ede3b5c806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setOutputSettings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a>&#160;</td>
          <td class="paramname"><em>outputsettings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output settings for this device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputsettings</td><td>The desired 'output settings' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6d63878cb644ff64a4053d82c3a2d063" title="Set the outputmode for this device.">setOutputMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf9da9741cd6278d11f2d2bedee89e45b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setOutputSkipFactor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>skipFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output skip factor for this device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipFactor</td><td>The desired 'output skip factor' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga8deac8b2a3914349f161cedf257de816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setQueueMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the queue mode to the given <em>mode</em>.  </p>
<p>Indicate if a readData call for a live system should get the latest data or the next in queue data or nothing at all. The default queue mode is XQM_CallbackOnly, which means that data is not queued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the new queue mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a45b86ccc2b443f1c2bfd6c99fefcfe34" title="Get the currently used queue mode.">queueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a9720f314343d0bc679e5d19d077086d4" title="Set the queue mode to the given mode.">XsControl::setQueueMode</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when the queue mode has been successfully set. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab05057b7b04ff7097fb1bf82d7d3a1ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setRs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the transmission delay used for RS485 transmissions.  </p>
<p>See the low level documentation for more information on this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>The desired delay </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab5f712d6dae335d193250b9a2b8422e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setSamplePeriod </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sample period for this device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The desired 'sample period' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7c96a310c0a3d2ab4df1d2983f9d2c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setSerialBaudRate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the serial baudrate to <em>baudrate</em>.  </p>
<p>This function is only useful when using a serial communication channel, such as a serial-USB converter or a direct COM port. It is advised to make the baud rate as high as your platform allows, to minimize latency and problems with bandwidth.After setting the baudrate and communicating over the same communication channel, it is required to reset the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The desired serial baudrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the baud rate was successfully updated </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac9a07fbe9718701612851375103c7eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setStringOutputType </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the string output type for this device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired stringOutputType for this device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The string output type is a bitwise or of individual types </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga8f9ea9c77823d74374700729ba69e9d9" title="NMEA string types.">XsNmeaStringType</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga893486efde59d7f237f26829e7f86521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setSyncBoxMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sync box mode of the Awinda Station device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable sync box mode, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5cad862a34f2363fbef1e0b8e751788b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setSyncSettings </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *&#160;</td>
          <td class="paramname"><em>settingList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the synchronization settings of the device.  </p>
<p>This function can be used to set all the synchronization options of the device at once. It is translated into device-specific commands by XDA, since not all devices support the same synchronization functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settingList</td><td>The list of synchronization settings to set. An empty list will clear all synchronization settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6b162561df7e93e8a3ebe35a920ba655" title="Get all the current synchronization settings of the device.">syncSettings</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaf07718994b8cd089e11c2dd43f7133c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setTransportMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>transportModeEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the transport mode for the device.  </p>
<p>The MTw has a "wake up by motion" feature that requires some power and can cause unnecessary wakeups when transporting the device. This function can be used to put the device in "transport mode", which effectively disables the motion wake up feature until the device is plugged into something or the transport mode is explicitly disabled by this function again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transportModeEnabled</td><td>true to enable transport mode (which disables the motion wakeup) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in transport mode (or taken out of it) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga770d9a6979879556c83dec1f93d899e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setUpdateRate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the legacy update rate of the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rate</td><td>The desired legacy update rate for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the update rate was successfully set </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd" title="Returns the legacy output configuration as an XsDeviceMode object.">deviceMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207" title="Sets the legacy output configuration of the device.">setDeviceMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga687f8875ca5c3c200ecf21c295c8935e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setWirelessPriority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the wireless priority of the device.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired wireless priority of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the wireless priority has been successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga6f0d09ed69482da66b5b3c5be7685918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_setXdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the host PC.  </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. By default XDA will attempt to match the software filter profile to the configured hardware filter profile when detecting a new device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce" title="Return the list of filter profiles available on the host PC.">availableXdaFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When reading from a file, make sure to call <a class="el" href="struct_xs_device.html#a41d64884658c21c321545420ab8f0aa4" title="Set the read position of the open log file to the start of the file.">resetLogFileReadPosition()</a> and possibly <a class="el" href="struct_xs_device.html#a15312f246b4a1eaace09d3f98e8f9ed7" title="Load a complete logfile.">loadLogFile()</a> after changing the filter profile to make sure all cached data is recomputed. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce" title="Return the list of filter profiles available on the host PC.">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716" title="Gets the filter profile in use for computing orientations on the host PC.">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028" title="Sets the filter profile to use for computing orientations on the device.">setOnboardFilterProfile</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gabe89a20af07aaf119268ce2a2728204f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_startRecording </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start recording incoming data.  </p>
<p>To record succesfully, a log file should be created by calling <a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185" title="Create a log file for logging.">createLogFile()</a> before this function is called. startRecording(XsString, XsDeviceId) can be used to achieve the same result. </p>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully started </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Starting recording for a single non-main device will start a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185" title="Create a log file for logging.">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a7899e535c8459b3154a6610c71b7c471" title="Stop recording incoming data.">stopRecording()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga53894ab4b85fd020e48fdfb46049f21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_stopRecording </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop recording incoming data.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if recording was successfully stopped </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stopping recording for a single non-main device will stop a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185" title="Create a log file for logging.">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab8aef28ccbb4b80b80be6b85fedd6d87" title="Start recording incoming data.">startRecording()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac0ef2795b731c8965890dd54abf9357e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_storeFilterState </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store orientation filter state in the device.  </p>
<p>Use this function when the filters for the device have stabilized to store the current biases in the device. The benefit is that on the next startup the filter will stabilize quicker. However, the stored biases depend on temperature and other external parameters, so the stored values will remain correct for only a short time. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the filter state was saved, false otherwise </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga55c7446796090cdeb7ffab5582877f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice_stringOutputType </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string output type.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The 'string output type' setting of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a3db7f9734a5523a435d67289ec44ecd0" title="Set the string output type for this device.">setStringOutputType</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaa837d3c8dfb99a0ac5daa5f2e9caef9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>* XsDevice_supportedSyncSettings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all supported synchronization settings available on the device.  </p>
<p>This function provides a list of the available synchronization settings of the device, since not all devices support the same synchronization functionality. Every <a class="el" href="struct_xs_sync_setting.html" title="A structure for storing all xsens sync settings.">XsSyncSetting</a> element in the list defines one function and line setting, with supported parameters. If the same function support multiple settings (i.e. multiple lines), then the list will contains multiple items with the same function name, but with different line settings. For easier use, same functions must be listed next to eachother, so each function settings in the list will be grouped. Properties, others then m_function and m_line are set to 0 if not supported or 1 if supported by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings supported by the device. Each settings grouped by functions. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gaa4c4eee95b954077a08ba711445391e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_int_array.html">XsIntArray</a>* XsDevice_supportedUpdateRates </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_int_array.html">XsIntArray</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the device for its supported update rates for the given <em>dataType</em>.  </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the supported update rates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list with the supported update rates or an empty list in case of an error </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gac88933de954028c4c52e88e56011fd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a> XsDevice_syncRole </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the synchronization role of the device.  </p>
<p>For synchronization purposes a device can be a master, a slave, both or neither. This function returns the way the device is currently configured. </p>
<dl class="section return"><dt>Returns</dt><dd>The synchronization role of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga7516215631c6202fbba319998945434a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>* XsDevice_syncSettings </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the current synchronization settings of the device.  </p>
<p>This function is a generic way of requesting the synchonization options of a device, since not all devices support the same synchronization functionality. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings configured for the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a1d1e8487e22ddfa3376893262e3c3607" title="Set the synchronization settings of the device.">setSyncSettings</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gafce827017c16f5866b4a4f741164402c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_transportMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state of the transport mode feature.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>true if tranport mode is currently enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a4dd6644f24f131274421aaea9d0fc0c3" title="Enable or disable the transport mode for the device.">setTransportMode</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gab17a7d374252e7daeda758bc8a8fe3bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_updateCachedDeviceInformation </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the cached device information for all devices connected to this port.  </p>
<p>This function can only be called in config mode. XDA caches all device information to prevent unnecessary communication with the device. When some configuration has changed without XDA knowing about it (through <a class="el" href="struct_xs_device.html#a3589494a7043c386d42fc147301748c5" title="Send a custom message messageSend to the device and possibly wait for a result.">sendCustomMessage()</a> for example), it may be necessary to tell XDA to refresh its cached information by calling this function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the cached information was updated successfully </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga5b0e9bc213a1a0cf58e33628413184d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_updateRate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the legacy update rate of the device.  </p>
<p>This function is only valid for devices in legacy mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The legacy update rate of the device </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gad99b2c6e0df6904201fdcc1e7041a610"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_updateRateForDataIdentifier </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>.  </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. This function only checks the output configured in the device, not possible computed data </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a668e50cfe473e459b5a6d35bb338214e" title="Returns the currently configured update rate for the supplied dataType.">updateRateForProcessedDataIdentifier</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga0256554521df8a45fce8788045f1dfd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_updateRateForProcessedDataIdentifier </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>.  </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. Where updateRateForDataIdentifier only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0" title="Returns the currently configured update rate for the supplied dataType.">updateRateForDataIdentifier</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae6718b4b462e2786ac3fe16313fade6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_usesLegacyDeviceMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the device uses legacy device mode.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>True if the legacy period, outputmode, outputsettings or string reports are used </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gabfc9344d5074c5b6836456e16601d7f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice_wirelessPriority </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the wireless priority of the device.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The wireless priority of the device or 0 if it has none. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="gae978c4d9a80b1e5cd445a0dc39471cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice_writeDeviceSettingsToFile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the emts/wms/xms of the device and all its children to the open logfile.  </p>
<p><dl class="section note"><dt>Note</dt><dd>The default implementation just tells all its children to do the same </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga822044193bb1949eceac4de83cafe82d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>* XsDevice_xdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the filter profile in use for computing orientations on the host PC.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the PC </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c" title="Sets the filter profile to use for computing orientations on the host PC.">setXdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079" title="Gets the filter profile in use by the device for computing orientations.">onboardFilterProfile</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ga3f82f23864ce7afecff683cd244e62b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceConfiguration_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numberOfDevices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitializes the XsDeviceConfiguration with space for <em>numberOfDevices</em> devices and copies them from <em>src</em>. </p>
<p>This function reinitializes the object reserving space for <em>numberOfDevices</em> devices in the buffer. <em>size</em> may be 0. If <em>src</em> is not null, <em>numberOfDevices</em> bytes from <em>src</em> will be copied. Previous data will be cleared and freed automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfDevices</td><td>: The number of devices for which memory should be allocated in the <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> </td></tr>
    <tr><td class="paramname">src</td><td>: A source <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> object that will be used to initialize the new object. May be null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1edca1236b69b9dd0253c9ee218a0108"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceConfiguration_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> is empty </dd></dl>

</div>
</div>
<a class="anchor" id="gac9938ca9ab7f27e7638e6d3b6f31821c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceConfiguration_readFromMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up a <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> based upon <em>msg</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>: The <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> to use to set up the <a class="el" href="struct_xs_device_configuration.html" title="Structure containing a full device configuration as returned by the ReqConfig message.">XsDeviceConfiguration</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ced1d8bb9944a0dae2a91ab9eb8f3ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceConfiguration_writeToMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a message <em>msg</em> that represents the XsDeviceConfiguration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>: An <a class="el" href="struct_xs_message.html" title="Structure for storing a single message.">XsMessage</a> that will represent the XsDeviceConfiguration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fc33a6257bdef8c1b94af98a9e4a687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gaf6d3ba49156a12dc63190c1bb9f01d28">XsCalibratedDataMode</a> XsDeviceMode_calibratedDataMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the calibrated data mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The calibrated data mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#gaf6d3ba49156a12dc63190c1bb9f01d28" title="Legacy calibrated data output selection flags.">XsCalibratedDataMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafe19019f785c9ec88688e55baf5f1a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gab70862c87211b0172b995e269bb9f6b4">XsCoordinateSystem</a> XsDeviceMode_coordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current used coordinate system. </p>
<dl class="section return"><dt>Returns</dt><dd>The current used coordinate system </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b955d9f3394e47f737a0ba79c7d270e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gab069ea83c5534c084605d00747f02d3a">XsFloatFormat</a> XsDeviceMode_dataFormat </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current floating point data format. </p>
<dl class="section return"><dt>Returns</dt><dd>The current floating point data format </dd></dl>

</div>
</div>
<a class="anchor" id="ga34a28dbcf2dfb21d591113941da2581e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isAnalogInChannelEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the analog in channel at <em>channelIndex</em> is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelIndex</td><td>The index of the analog in channel. Can be either channel 0 or 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the analog in channel at <em>channelIndex</em> is enabled </dd></dl>

</div>
</div>
<a class="anchor" id="ga58eb093cba0b229fa7253aef5123d268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isGpsPvtDataEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current status of the gps pvt data output. </p>
<dl class="section return"><dt>Returns</dt><dd>The current status of the gps pvt data output </dd></dl>

</div>
</div>
<a class="anchor" id="ga44cb97f31b66f487ef57e8b8df6ba247"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isModeFlagEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the state of the output mode <em>flag</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>The state of this flag is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of <em>flag</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gab7dcd4bd7715ab85e194607a1f1d1df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isPositionDataEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current status of the position output. </p>
<dl class="section return"><dt>Returns</dt><dd>The current status of the position output </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e8361e349507f84cb3ddd242c6f384b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isRawDataOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current status of the raw data output. </p>
<dl class="section return"><dt>Returns</dt><dd>The current status of the raw data output </dd></dl>

</div>
</div>
<a class="anchor" id="gab6889b176bd9961209213bbecc064eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isSettingsFlagEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the state of the output settings <em>flag</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>The state of this flag is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of <em>flag</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gab37d63e8636a3b76b2bfe1dac69d6c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isStatusOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current status of the status output. </p>
<dl class="section return"><dt>Returns</dt><dd>The current status of the status output </dd></dl>

</div>
</div>
<a class="anchor" id="ga366c1e61891fe32b343494a6bda15243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isTemperatureOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current status of the temperature output. </p>
<dl class="section return"><dt>Returns</dt><dd>The current status of the temperature output </dd></dl>

</div>
</div>
<a class="anchor" id="ga58b15b3c9c80ca1bbecd974fc701f500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceMode_isVelocityDataEnabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current status of the velocity output. </p>
<dl class="section return"><dt>Returns</dt><dd>The current status of the velocity output </dd></dl>

</div>
</div>
<a class="anchor" id="ga72837d79b36d66d6f2196ae640c1bb27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga126d8e6e843bb9ec4b39dff76fd20dd5">XsOrientationMode</a> XsDeviceMode_orientationMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current orientation mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The current orientation mode </dd></dl>

</div>
</div>
<a class="anchor" id="gadf3be05747aa4927396987a285a5a1a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsDeviceMode_sampleRate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sample rate in Hz. </p>
<p>The sample rate is the frequency at which the MT internally queries the IMUs. It can be much higher than the update rate depending on the type of device and filter requirements.</p>
<dl class="section return"><dt>Returns</dt><dd>The sample rate in Hz</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>setSkipFactor(int) </dd>
<dd>
m_skipFactor, period() </dd>
<dd>
updateRate() </dd></dl>

</div>
</div>
<a class="anchor" id="gaa20205fd7f6f611e1db2500df65902f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setAnalogInChannelEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable an analog in channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelIndex</td><td>The index of the analog in channel. Can be either channel 0 or 1 </td></tr>
    <tr><td class="paramname">enabled</td><td>Enable or disable the channel at <em>channelIndex</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5bafbbed5153cace100d4efa1d51d4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setCalibratedDataMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gaf6d3ba49156a12dc63190c1bb9f01d28">XsCalibratedDataMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the calibrated data mode to <em>mode</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The Calibrated data mode to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#gaf6d3ba49156a12dc63190c1bb9f01d28" title="Legacy calibrated data output selection flags.">XsCalibratedDataMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga768c534735515f8afc53010e0061e21d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gab70862c87211b0172b995e269bb9f6b4">XsCoordinateSystem</a>&#160;</td>
          <td class="paramname"><em>coordinatesystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coordinate system used for calibrated and orientation output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinatesystem</td><td>The coordinate system to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#gab70862c87211b0172b995e269bb9f6b4" title="Coordinate system definition flags.">XsCoordinateSystem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga96b832e7869732f349b2721afb19ebfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setDataFormat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gab069ea83c5534c084605d00747f02d3a">XsFloatFormat</a>&#160;</td>
          <td class="paramname"><em>ff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data format for floating point output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ff</td><td>The new <em>XsFloatFormat</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#gab069ea83c5534c084605d00747f02d3a" title="Legacy floating point / fixed point format options.">XsFloatFormat</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafd697df5979cf11be18d79796cba2367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setGpsPvtDataEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the gps pvt data output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to non-zero for enabling gps pvt data output, to zero for disabling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3fe6f7da6b5a9518d003857427b0d9ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setModeFlag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear a <em>flag</em> of the output mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>The flag to enable or disable </td></tr>
    <tr><td class="paramname">enabled</td><td>Set to zero for disabling the <em>flag</em>, non-zero for enabling the <em>flag</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca1334e81ca26f55a89f4a5035ee199f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setOrientationMode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga126d8e6e843bb9ec4b39dff76fd20dd5">XsOrientationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set orientation output mode to <em>mode</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga126d8e6e843bb9ec4b39dff76fd20dd5" title="Legacy orientation output mode selection.">XsOrientationMode</a></dd></dl>
<p>If mode is set to anything other than OM_None, the raw inertial output is automatically disabled. </p>

</div>
</div>
<a class="anchor" id="ga918a42711bce561497949b17115b6165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setPositionDataEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the position output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to non-zero for enabling position output, to zero for disabling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac7a40e52a8a1cc26cd984548f457b660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setRawDataOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the raw data output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to non-zero for enabling raw data output, to zero for disabling</td></tr>
  </table>
  </dd>
</dl>
<p>If enabled, the orientation and calibrated output are automatically disabled. </p>

</div>
</div>
<a class="anchor" id="ga61d6a4e1c6b3d5e7d569928623b399b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setSettingsFlag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear a <em>flag</em> of the output settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>The flag to enable or disable </td></tr>
    <tr><td class="paramname">enabled</td><td>Set to zero for disabling the <em>flag</em>, non-zero for enabling the <em>flag</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac26b2fa0de33a7e7933d358522aa8b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setStatusOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the status output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to non-zero for enabling status output, to zero for disabling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab56affb47cccafee34c80765b13208f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setTemperatureOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the temperature output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to non-zero for enabling temperature output, to zero for disabling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga537b419910590a3b6feb961ed20bc3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setUpdateRate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the update rate to the given <em>rate</em>. </p>
<p>The update rate is internally expressed as a period and a skip factor. This may cause the actual update rate to differ up to 2Hz from the value set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>The update rate to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>updateRate(), sampleRate(), period(), m_skipFactor, setPeriod(uint16_t), setSkipFactor(uint16_t) </dd></dl>

</div>
</div>
<a class="anchor" id="gac3735b2de3243bfb2b9596b3752c2e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_setVelocityDataEnabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the velocity output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to non-zero for enabling velocity output, to zero for disabling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab7bf1d30f92fb298ed50943ea353b519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_toXsDeviceMode </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *&#160;</td>
          <td class="paramname"><em>modeR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device mode as a <a class="el" href="struct_xs_device_mode_r.html" title="A structure for storing device modes.">XsDeviceModeR</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modeR</td><td>The <a class="el" href="struct_xs_device_mode_r.html" title="A structure for storing device modes.">XsDeviceModeR</a> object to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device_mode_p_s.html" title="Stores device modes using period and skip factor.">XsDeviceModePS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga89291a18b727abb67e7fa7c9518abffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceMode_toXsDeviceMode2 </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_xs_device_mode_p_s.html">XsDeviceModePS</a> *&#160;</td>
          <td class="paramname"><em>modePS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device mode as a <a class="el" href="struct_xs_device_mode_p_s.html" title="Stores device modes using period and skip factor.">XsDeviceModePS</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modePS</td><td>The <a class="el" href="struct_xs_device_mode_p_s.html" title="Stores device modes using period and skip factor.">XsDeviceModePS</a> object to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device_mode_r.html" title="A structure for storing device modes.">XsDeviceModeR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e15a2624cfb7a42b0e1618b28a85236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDeviceMode_updateRate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the update rate in Hz. </p>
<p>The update rate is the frequency at which data is output by the sensor. This frequency is a result of sampleRate and skipFactor.</p>
<dl class="section return"><dt>Returns</dt><dd>The current update rate</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>setUpdateRate(int) </dd>
<dd>
m_skipFactor, period() </dd>
<dd>
sampleRate() </dd></dl>

</div>
</div>
<a class="anchor" id="ga9019e771ca7f5073451e2bad03a2b05d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceModePS_setUpdateRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_mode_p_s.html">XsDeviceModePS</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the period and skip factor from an update rate and store them. </p>
<p>This function computes the best period and skip factor from the given update <em>rate</em> and stores them in the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>The desired update rate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga27bd555d485be3f9700ee77f3ffe9ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceModePS_updateRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_mode_p_s.html">XsDeviceModePS</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the update rate in Hz. </p>
<p>This may be up to 2Hz different from the value that is set in setUpdatRate due to hardware limitations at high update rates. </p>
<dl class="section return"><dt>Returns</dt><dd>The update rate in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8c8aa5ec38f3397aae21b52b05e184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceModeR_getPeriodAndSkipFactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the period and skip factor from the stored update rate. </p>
<p>This function computes the period and skipFactor fields from the stored m_updateRate field. The maximum error in the update rate is approximately 0.4%, which occurs at 510Hz (= actually 512 Hz). In general, the higher rates are harder to set up exactly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>Storage for period result </td></tr>
    <tr><td class="paramname">skip</td><td>Storage for skip factor result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6812853d996fa61c9d7bbf3df0999390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDeviceModeR_setPeriodAndSkipFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the update rate from a period and skip factor. </p>
<p>This function does the reverse of the getPeriodAndSkipFactor function, storing the value in the m_updateRate field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The sample period in 1/115200 secons units </td></tr>
    <tr><td class="paramname">skip</td><td>The output skip factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeeb33bd6a79065e3b87dd7b6cf294ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDeviceModeR_updateRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_mode_r.html">XsDeviceModeR</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the real update rate in Hz. </p>
<p>This may be up to 2Hz different from the value that is set in m_updateRate due to hardware limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>The actual update rate that will be used by the device </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3aa84511f07c5b343ee77112361dfaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsMatrix_multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsReal&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies all values in this <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> by <em>scalar</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>: Value to multiply by </td></tr>
    <tr><td class="paramname">dest</td><td>: The <a class="el" href="struct_xs_matrix.html" title="A class that represents a matrix of real numbers.">XsMatrix</a> to store the result in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84490340feeeb8c23327124019db1dde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsMatrix_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the offset in the data for accessing the value at <em>row</em> and <em>column</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The row of the value </td></tr>
    <tr><td class="paramname">column</td><td>The column of the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset of the requested item in the internal buffer </dd></dl>

</div>
</div>
<a class="anchor" id="gab4218a181d23c28cf3e927b7504a9069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsMatrix_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> and <em>b</em>. </p>
<p>This function swaps the internal buffers so no actual data is moved around. This won't work for unmanaged data such as fixed size matrices (<a class="el" href="struct_xs_matrix3x3.html" title="A class that represents a fixed size (3x3) matrix.">XsMatrix3x3</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Object whose contents will be placed in <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>Object whose contents will be placed in <em>a</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9da904b977b09ad3aaa4e32c4672cd12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reinitializes the XsMessage object and reserves <em>dataSize</em> bytes for data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>the expected size of the message payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02356a5cefd94aa7719c39ba9692b598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* XsMessage_constData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a const pointer to the <em>offset</em> in the data of the message in <em>thisptr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset of the data to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data at offset <em>offset</em> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3aff1ac742c36f378747f4df0a7eb65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_constructSized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the XsMessage object and reserves <em>dataSize</em> bytes for data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>the expected size of the message payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5926dcf4e25e601ae0059b95afc5e226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies from <em>thisPtr</em> to <em>copy</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the object to copy to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4ca57ead95b63178f60835f2374039e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsMessage_dataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the datasize of the message in <em>thisptr</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga9212be8c3889701fad8c40da79822bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_deleteData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <em>count</em> bytes of data from the message at <em>offset</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of bytes to remove </td></tr>
    <tr><td class="paramname">offset</td><td>the offset at which to remove the bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee251864355965b32fe3af9fa07e2419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the data in the message. </p>

</div>
</div>
<a class="anchor" id="gaa07140d194f0089a8c40e7738d1622ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsMessage_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this message is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if this message is empty, zero otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gac06b9bc8c27a860d057a39d9c208c327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_message_header.html">XsMessageHeader</a>* XsMessage_getConstHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the message header </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e1ab9a85f8b5c16a798d8920f1b69c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* XsMessage_getDataBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const pointer to the data buffer of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the data buffer of the message </dd></dl>

</div>
</div>
<a class="anchor" id="ga91ca4b85ce514c4688055917e7ec0591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsMessage_getDataByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the byte value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga73b548351bd3eb7e86187679ac83f572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsMessage_getDataDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the double at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double precision floating point value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cf009aeda779d5955bba969390a1fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsMessage_getDataF1220 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the F12.20 value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 12.20 fixed point value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="gafd25a9320f3fbfabcd193bff5b5185c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float XsMessage_getDataFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the float value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single precision float value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga127c683e09b2db4ce8e161949e778bb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double XsMessage_getDataFP1632 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the F16.32 value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 16.32 fixed point value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c80c694ccbad9cc68b216a318a85463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_getDataFPValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>outputSettings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current data values as a double(64 bits), after converting it from float, double, FP1632 or FP1220 depending on outputSettings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputSettings</td><td>the output settings containing the current floating/fixed point settings </td></tr>
    <tr><td class="paramname">dest</td><td>an array of double values containing at least <em>numValues</em> items </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to start reading </td></tr>
    <tr><td class="paramname">numValues</td><td>the amount of numbers to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae0f330f1e8ff7b541f721dcf9211030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_getDataFPValuesById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current data values as double, conversion depends on outputSetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination array </td></tr>
    <tr><td class="paramname">dataIdentifier</td><td>Data identifier containing data precision </td></tr>
    <tr><td class="paramname">offset</td><td>offset in the data buffer from where to start reading. </td></tr>
    <tr><td class="paramname">numValues</td><td>number of values to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42d5a40697d57c0da08e1d21c82fb6e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsMessage_getDataLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the long value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 32-bit integer value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="gabc53fffde12da101d13f3528111e1dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsMessage_getDataShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the short value at <em>offset</em> in the data of the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset in the payload at which to read data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 16-bit integer value at offset <em>offset</em> in the message payload </dd></dl>

</div>
</div>
<a class="anchor" id="gad4ef5f47b2fe7bca6d550001b5b09296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* XsMessage_getMessageStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a const pointer to the header of the message in <em>thisptr</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the message </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dd01bb00c8b697a56aafc443c1ddfd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsMessage_getTotalMessageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the length of the message buffer. </p>
<p>The function returns the total size of the message, including the checksum. This is in effect the number of bytes that would be transferred if the message were to be sent over a communications channel.</p>
<dl class="section return"><dt>Returns</dt><dd>the total message size </dd></dl>

</div>
</div>
<a class="anchor" id="ga4901534c43c5716f67f1b73ae215626e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_insertData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <em>count</em> bytes of empty space at <em>offset</em> in this message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of bytes to reserve </td></tr>
    <tr><td class="paramname">offset</td><td>the offset at which to allocate the space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f7081af4eca1ef8996da037155ce72a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsMessage_isChecksumOk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if the checksum inside the message is correct for the message, zero otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>true (non-zero) if the checksum inside the message is correct, false (zero) otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gad4dde94962cb03ca78d207d7ed7f5b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>msgSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the XsMessage object and reserves <em>msgSize</em> bytes for data, it then copies in the data from <em>src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgSize</td><td>the size of the data pointed to by src </td></tr>
    <tr><td class="paramname">src</td><td>the data to load the message from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a71f01ef77db025407f19e93dae9ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_resizeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the buffer of message to <em>newSize</em> bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the message payload buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf083ca2bf41d2efdd4fd224bc53c9fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setBusId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>busId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bus id for this message to <em>busId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busId</td><td>the bus identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga44cefb784042cbd1494268a2735c095f" title="The bus broadcast bus identifier (all devices)">XS_BID_BROADCAST</a> <a class="el" href="group__cinterface.html#gae8321d23871bd495a735cccbac26b451" title="The bus identifier of the master device.">XS_BID_MASTER</a> <a class="el" href="group__cinterface.html#gab9478ee24f1f927f712dd4ad6caa7bc7" title="The bus identifier for the first MT on the bus.">XS_BID_MT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab68055a504cd3ad0108b216d7ec447fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts <em>size</em> number of bytes from <em>buffer</em> into the message at <em>offset</em>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The buffersize of will be increased if <em>buffer</em> is too large</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer to copy </td></tr>
    <tr><td class="paramname">size</td><td>the size of the buffer </td></tr>
    <tr><td class="paramname">offset</td><td>the offset at which to copy the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa23c89aa06c089d2fec7a4d11c573fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the byte at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 8-bit value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga497e871bda0c859a73dfe1f1e29de6a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the double at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the double precision floating point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga366d27f459a11717add7e69ee6c85878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataF1220 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the F12.20 at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 12.20 fixed point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1234b6e6d4411d8b0c702fa440841ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the float at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the single precision floating point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf69a92d482776fa1c730e6dc1247e5f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFP1632 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the F16.32 at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16.32 fixed point value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04bcae80049f7b33e84ebdffc116b321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFPValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>outputSettings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a floating/fixed point value into to the data buffer, conversion depends on outputSettings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputSettings</td><td>MT output settings </td></tr>
    <tr><td class="paramname">data</td><td>The data array to be written to the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the data buffer from where to start writing. </td></tr>
    <tr><td class="paramname">numValues</td><td>number of values to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadde1d1e334dbf921acf03ee0a25eada3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataFPValuesById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a number of floating/fixed point values into to the data buffer, conversion depends on outputSettings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataIdentifier</td><td>Data Identifier </td></tr>
    <tr><td class="paramname">data</td><td>The data array to be written to the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the data buffer from where to start writing. </td></tr>
    <tr><td class="paramname">numValues</td><td>number of values to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga64de205a7a48f0b109856f2e105e7ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the long at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 32-bit value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga359dc1326aa818e5168db40264d80502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setDataShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the short at <em>offset</em> in the message to <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the 16-bit value to set </td></tr>
    <tr><td class="paramname">offset</td><td>the offset in the message payload at which to write the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga235e41e089f2c0fc8860bf83df1311d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_setMessageId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a>&#160;</td>
          <td class="paramname"><em>msgId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the message id for this message to <em>msgId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>the message identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b9e73d2db2d034d0ae1c3f95fb37cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsMessage_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> and <em>b</em>. </p>
<p>This function swaps the internal buffers so no actual data is moved around. A result is that it won't work for unmanaged data such as fixed size vectors</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the object to receive <em>b's</em> contents </td></tr>
    <tr><td class="paramname">b</td><td>the object to receive <em>a's</em> contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa32b87ad68904738bb4ad9e64758f05a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsPortInfo_portNumber </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port number. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the port number </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Available on Windows only </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f7a31f4a8a7aaf3a18c9152d9e993ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsPortInfo_usbAddress </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The usb address. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the usb address </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Available on Linux only </dd></dl>

</div>
</div>
<a class="anchor" id="ga07a9ed806c36fb0f13e476ad29ff6876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsPortInfo_usbBus </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The usb bus. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the Usb bus number </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Available on Linux only </dd></dl>

</div>
</div>
<a class="anchor" id="ga5021de7e1f89887d357b80e69c15d5ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsQuaternion_fromRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> *&#160;</td>
          <td class="paramname"><em>ori</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a quaternion representation of orientation matrix <em>ori</em>. </p>
<p>The matrix <em>ori</em> is interpreted as an orthonormal orientation matrix, which is translated into a quaternion representation. If <em>ori</em> is not a 3x3 matrix, a null-quaternion is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ori</td><td>The source orientation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b7269b337234843b87fd7df7f68efa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsQuaternion_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse/conjugate of this quaternion. </p>
<p>Where <em>q</em> = a + bi + cj + dk, this function will return a - bi - cj - dk in <em>dest</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The object to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga217fd03f808db0b06765e3bbb85fc9cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsQuaternion_invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert this quaternion. </p>
<p>Where <em>q</em> = a + bi + cj + dk, this function will replace it with a - bi - cj - dk. </p>

</div>
</div>
<a class="anchor" id="ga13553237cb71fff5792dda83f4fa0126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsRange_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of values in the range. </p>
<dl class="section note"><dt>Note</dt><dd>The range is <em>inclusive</em> [first, last] instead of [first, last&gt;. So count [1, 2] = 2 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of values in the range (inclusive) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6de65698e6d8914121c8fde5832fd5cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsRange_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the range is empty. </p>
<p>An empty range has a last element that is lower than its first element. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the range is empty, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gabc5d89008b194a4404db1c8f0cdf35b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsRange_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_range.html">XsRange</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of values in the range. </p>
<dl class="section note"><dt>Note</dt><dd>The range is <em>exclusive</em> [first, last&gt; instead of [first, last]. So interval [1, 2] = 1 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of values in the range (exclusive) </dd></dl>

</div>
</div>
<a class="anchor" id="ga79baa392a62fc5e3ed73d351e4f2c403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsRssi_unbiased </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the raw RSSI value transformed into a usable (unbiased) number. </p>
<p>Actual rssi is calculated by <em>raw</em> + XS_RSSI_MAX, where <em>raw</em> is a negative number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The RSSI value as reported by the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unbiased RSSI value. </dd></dl>

</div>
</div>
<a class="anchor" id="gade542196fc0232e0801ff67f5ae19abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsSdiData_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_sdi_data.html">XsSdiData</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XsReal *&#160;</td>
          <td class="paramname"><em>orientationIncrement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XsReal *&#160;</td>
          <td class="paramname"><em>velocityIncrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an XsSdiData object with the optional arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientationIncrement</td><td>The orientation increment to initialize the object with, may be 0 </td></tr>
    <tr><td class="paramname">velocityIncrement</td><td>The velocity increment to initialize the object with, may be 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae38505926760a0a5e7dd314e683ae546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getDateAsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the date as string representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 bytes </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga393705293aa555086514c8835ad019da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getDateAsWString </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the date as wstring representation The format is YYYYMMDD so 25 dec 2010 is stored as an array dest[8] = {'2', '0', '1', '0', '1', '2', '2', '5' }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 wchars </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae059db4e22b6f6d69ae31bb7291cd9f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTime_getDateTime </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the date and time (platform-independent) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>: if non-zero the local (!) date and time is stored in the tm struct this parameter points to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTC date and time as seconds since 1970 </dd></dl>

</div>
</div>
<a class="anchor" id="gafb389fca2f6341c79b2262caf7a9d6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getTimeAsString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 bytes </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>(for now hundreths are set to 0) </dd></dl>

</div>
</div>
<a class="anchor" id="ga62a4f6afc1dbe845a1b6b09c9d4fbd1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_getTimeAsWString </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>date</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the time as binary The format is HHMMSShh (where H is hour and 'h' is hundredths) so 14:25:01.23 is stored as an array dest[8] = { '1', '4', '2', '5', '0', '1', '2', '3'}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>: A pointer to an array of at least (!) 8 wchars </td></tr>
    <tr><td class="paramname">date</td><td>: If date is non-zero this date is converted, otherwise the current date is retrieved and used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>(for now hundreths are set to 0) </dd></dl>

</div>
</div>
<a class="anchor" id="gac54582842a30b1029a66050279844a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsTime_getTimeOfDay </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>date_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t *&#160;</td>
          <td class="paramname"><em>secs_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the current time of day in ms since midnight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_</td><td>When not 0, the corresponding current date is put in here. </td></tr>
    <tr><td class="paramname">secs_</td><td>When not 0, the full timestamp in seconds since the epoch is put in here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of milliseconds that have passed since midnight. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1b31cc058a52b02959dc1b80e729fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_initializeTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stabilize the clock. </p>
<p>Repeatedly call XsTime_timeStampNow for 16-32 ms to stabilize the clock </p>

</div>
</div>
<a class="anchor" id="ga28efdfd01aad10c9da7baaeb6d7b8931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_msleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the current thread sleep for at least <em>ms</em> milliseconds. </p>
<p>A platform independent sleep routine to sleep for at least <em>ms</em> milliseconds.</p>
<p>On linux we are using pthread_cond_t, which implies that the timedwait() is a cancellation point. This function might return sooner than expected in some cases due to system events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The number of milliseconds to sleep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga45d819f679819b2c2c6bc4f7a35f2dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTime_timeStampNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname"><em>now</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current time in ms since the epoch (Jan 1st 1970) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">now</td><td>Pointer to XsTimeStamp container for the returned value, may be 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current time in ms since the epoch (Jan 1st 1970) as a 64-bit integer </dd></dl>

</div>
</div>
<a class="anchor" id="ga8268408ade85db6aa5f5a8bb56f00f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsTime_udelay </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays the current thread for at least <em>us</em> microseconds. </p>
<p>A platform independent delay routine to sleep for at least <em>us</em> microseconds.</p>
<p>On linux we are using pthread_cond_t, which implies that the timedwait() is a cancellation point. This function might return sooner than expected in some cases due to system events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>The number of microseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96fc3ee8f0b8597295311adb4ff8c78a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTimeStamp_fromUtcTime </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td>
          <td class="paramname"><em>utc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps.">XsTimeStamp</a> from an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utc</td><td>The UTC time to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted time in ms since the epoch (Jan 1st 1970) </dd></dl>

</div>
</div>
<a class="anchor" id="ga471299f2a92ca43888c34e0088f8808d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsTimeStamp_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current time in ms since the epoch (Jan 1st 1970) </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__cinterface.html#ga45d819f679819b2c2c6bc4f7a35f2dde" title="Returns the current time in ms since the epoch (Jan 1st 1970)">XsTime_timeStampNow</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The object to write the time to, may be 0 in which case only the return value is generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current time in ms since the epoch (Jan 1st 1970) </dd></dl>

</div>
</div>
<a class="anchor" id="gad2760d12880e4b6dcd77dac1be3d1068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsTimeStamp_toUtcTime </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_xs_utc_time.html">XsUtcTime</a> *&#160;</td>
          <td class="paramname"><em>utc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the timestamp into an <a class="el" href="struct_xs_utc_time.html" title="A structure for storing UTC Time values.">XsUtcTime</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utc</td><td>The UTC time object to write the conversion result to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga166f34f636ae6c30b3741ee0af30e027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsUsbHubInfo_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a>&#160;</td>
          <td class="paramname"><em>hub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a new hub identifier to the XsUsbHubInfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>the hub identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabcd2d9017d98760bd77cc7f8cdcf3dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsUsbHubInfo_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cinterface.html#ga5c9e4b694fa198168f177ddb6f749f54">XsHubIdentifier</a>&#160;</td>
          <td class="paramname"><em>hub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the XsUsbHubInfo with <em>hub</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hub</td><td>the hub identifier to initialize with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2070c99d652844fdd3ce5216a7e33e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsUsbHubInfo_parentPathMatches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_usb_hub_info.html">XsUsbHubInfo</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the two hub info objects share the same device path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>the left hand side to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>the right hand side to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the two hubs share the same parent </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c6ac21c4bbc663e10723e982150e1b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsVector_angularVelocityFromQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsReal&#160;</td>
          <td class="paramname"><em>deltaT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an effective angular velocity from the quaternion, which must represent a delta angle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deltaT</td><td>The length of the time interval over which <em>quat</em> was integrated in seconds </td></tr>
    <tr><td class="paramname">quat</td><td>The orientation increment to convert to an angular velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the effective angular velocity in radians around each axis. </dd></dl>

</div>
</div>
<a class="anchor" id="gafd92f0315fa77840940cd63b25612f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsVector_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XsReal *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_xs_vector.html" title="A class that represents a vector of real numbers.">XsVector</a> using <em>sz</em> number of items from <em>src</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>The desired size of the vector </td></tr>
    <tr><td class="paramname">src</td><td>0 or a pointer to a buffer containing <em>sz</em> items to copy into the XsVector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga217ff6e4b3e3624cd6d93e7c4e7b61a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsReal XsVector_cartesianLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the cartesian length. </p>
<dl class="section return"><dt>Returns</dt><dd>The cartesian length (square root of the dot product) of the vector </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ff1df86948c024ea56939838641a05e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsVector_equal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero when the two vectors are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector to compare against <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>Vector to compare against <em>a</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero when the vectors are identical </dd></dl>

</div>
</div>
<a class="anchor" id="ga7097bb62e03b0dd0bf57efcb2fa54e7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsVector_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_vector.html">XsVector</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of <em>a</em> and <em>b</em>. </p>
<p>This function swaps the internal buffers so no actual data is moved around. For unmanaged data an elementwise swap is done, but only if the vectors are the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Object whose contents will be placed in <em>b</em> </td></tr>
    <tr><td class="paramname">b</td><td>Object whose contents will be placed in <em>a</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Thu Jan 16 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
