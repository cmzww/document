<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsDevice Struct Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="struct_xs_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsDevice Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A pointer to an <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> object.  
 <a href="struct_xs_device.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8ef4c196946e5b50b67cd2d2a3da5e32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ef4c196946e5b50b67cd2d2a3da5e32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8ef4c196946e5b50b67cd2d2a3da5e32">addRef</a> (void)</td></tr>
<tr class="memdesc:a8ef4c196946e5b50b67cd2d2a3da5e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase reference count of <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer stay alive while reference counter is not zero Also increases the reference count of each child device with 1. <br/></td></tr>
<tr class="separator:a8ef4c196946e5b50b67cd2d2a3da5e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd27bfdcb1f8d7a57d9eeedaa9c1f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9cd27bfdcb1f8d7a57d9eeedaa9c1f19">removeRef</a> (void)</td></tr>
<tr class="memdesc:a9cd27bfdcb1f8d7a57d9eeedaa9c1f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1.  <a href="#a9cd27bfdcb1f8d7a57d9eeedaa9c1f19"></a><br/></td></tr>
<tr class="separator:a9cd27bfdcb1f8d7a57d9eeedaa9c1f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fe272c871a765e6e173483c5bbf59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0c9fe272c871a765e6e173483c5bbf59">refCounter</a> (void) const </td></tr>
<tr class="memdesc:a0c9fe272c871a765e6e173483c5bbf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current reference counter.  <a href="#a0c9fe272c871a765e6e173483c5bbf59"></a><br/></td></tr>
<tr class="separator:a0c9fe272c871a765e6e173483c5bbf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5528e0d30a8958cb6c42398a865724bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5528e0d30a8958cb6c42398a865724bc">master</a> (void) const </td></tr>
<tr class="memdesc:a5528e0d30a8958cb6c42398a865724bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the master device of this device.  <a href="#a5528e0d30a8958cb6c42398a865724bc"></a><br/></td></tr>
<tr class="separator:a5528e0d30a8958cb6c42398a865724bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074354d99b32555a3895bdb5636df671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a074354d99b32555a3895bdb5636df671">children</a> (void) const </td></tr>
<tr class="memdesc:a074354d99b32555a3895bdb5636df671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child devices of this device.  <a href="#a074354d99b32555a3895bdb5636df671"></a><br/></td></tr>
<tr class="separator:a074354d99b32555a3895bdb5636df671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52255d690521d7d92cd4d78aee9bf8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a52255d690521d7d92cd4d78aee9bf8d2">findDevice</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceid) const </td></tr>
<tr class="memdesc:a52255d690521d7d92cd4d78aee9bf8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the child device with <em>deviceid</em>.  <a href="#a52255d690521d7d92cd4d78aee9bf8d2"></a><br/></td></tr>
<tr class="separator:a52255d690521d7d92cd4d78aee9bf8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b19466b66032e3e319375b40c08b30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab9b19466b66032e3e319375b40c08b30">busId</a> (void) const </td></tr>
<tr class="memdesc:ab9b19466b66032e3e319375b40c08b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus ID for this device.  <a href="#ab9b19466b66032e3e319375b40c08b30"></a><br/></td></tr>
<tr class="separator:ab9b19466b66032e3e319375b40c08b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790a9f814ac94d1e71452661c943d521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a790a9f814ac94d1e71452661c943d521">deviceId</a> (void) const </td></tr>
<tr class="memdesc:a790a9f814ac94d1e71452661c943d521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device ID of the device.  <a href="#a790a9f814ac94d1e71452661c943d521"></a><br/></td></tr>
<tr class="separator:a790a9f814ac94d1e71452661c943d521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa132b107f231867f70efbf2044817529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa132b107f231867f70efbf2044817529">firmwareVersion</a> (void) const </td></tr>
<tr class="memdesc:aa132b107f231867f70efbf2044817529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the firmware version.  <a href="#aa132b107f231867f70efbf2044817529"></a><br/></td></tr>
<tr class="separator:aa132b107f231867f70efbf2044817529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed892421bacfa1791ff389a6b266cb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aaed892421bacfa1791ff389a6b266cb7">isMasterDevice</a> (void) const </td></tr>
<tr class="memdesc:aaed892421bacfa1791ff389a6b266cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is the master device (not a child of another device)  <a href="#aaed892421bacfa1791ff389a6b266cb7"></a><br/></td></tr>
<tr class="separator:aaed892421bacfa1791ff389a6b266cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b4786411e559f54f551d877d938288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af6b4786411e559f54f551d877d938288">isInitialized</a> (void) const </td></tr>
<tr class="memdesc:af6b4786411e559f54f551d877d938288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the device is initialized.  <a href="#af6b4786411e559f54f551d877d938288"></a><br/></td></tr>
<tr class="separator:af6b4786411e559f54f551d877d938288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86249a6c447576a8a58a7adff51af0a9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a86249a6c447576a8a58a7adff51af0a9">deviceAtBusId</a> (int busid) const </td></tr>
<tr class="memdesc:a86249a6c447576a8a58a7adff51af0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.  <a href="#a86249a6c447576a8a58a7adff51af0a9"></a><br/></td></tr>
<tr class="separator:a86249a6c447576a8a58a7adff51af0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30ab92581227c3a2b4fe2187f9d761a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa30ab92581227c3a2b4fe2187f9d761a">deviceAtBusId</a> (int busid)</td></tr>
<tr class="memdesc:aa30ab92581227c3a2b4fe2187f9d761a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.  <a href="#aa30ab92581227c3a2b4fe2187f9d761a"></a><br/></td></tr>
<tr class="separator:aa30ab92581227c3a2b4fe2187f9d761a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e0d054ccc6242b4c2f650732fd5d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a77e0d054ccc6242b4c2f650732fd5d6e">setGotoConfigOnClose</a> (bool gotoConfigOnClose)</td></tr>
<tr class="memdesc:a77e0d054ccc6242b4c2f650732fd5d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">On closePort the device will go to config by default, with this function it is possible to prevent that.  <a href="#a77e0d054ccc6242b4c2f650732fd5d6e"></a><br/></td></tr>
<tr class="separator:a77e0d054ccc6242b4c2f650732fd5d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104b615636d419a3e0c3dfa07f1d0185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185">createLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a104b615636d419a3e0c3dfa07f1d0185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a log file for logging.  <a href="#a104b615636d419a3e0c3dfa07f1d0185"></a><br/></td></tr>
<tr class="separator:a104b615636d419a3e0c3dfa07f1d0185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a0f86279cde90b7f4441410f272cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a672a0f86279cde90b7f4441410f272cc">closeLogFile</a> (void)</td></tr>
<tr class="memdesc:a672a0f86279cde90b7f4441410f272cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.  <a href="#a672a0f86279cde90b7f4441410f272cc"></a><br/></td></tr>
<tr class="separator:a672a0f86279cde90b7f4441410f272cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12626445fb21fa7a5072045bac8046f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a12626445fb21fa7a5072045bac8046f0">isMeasuring</a> (void) const </td></tr>
<tr class="memdesc:a12626445fb21fa7a5072045bac8046f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a measuring state.  <a href="#a12626445fb21fa7a5072045bac8046f0"></a><br/></td></tr>
<tr class="separator:a12626445fb21fa7a5072045bac8046f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2746404553d0a7bfa90745b8619db193"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2746404553d0a7bfa90745b8619db193">isRecording</a> (void) const </td></tr>
<tr class="memdesc:a2746404553d0a7bfa90745b8619db193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a recording state.  <a href="#a2746404553d0a7bfa90745b8619db193"></a><br/></td></tr>
<tr class="separator:a2746404553d0a7bfa90745b8619db193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af283c0d414b83b3deda483cbff3b3087"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af283c0d414b83b3deda483cbff3b3087">isReadingFromFile</a> (void) const </td></tr>
<tr class="memdesc:af283c0d414b83b3deda483cbff3b3087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is reading from a file.  <a href="#af283c0d414b83b3deda483cbff3b3087"></a><br/></td></tr>
<tr class="separator:af283c0d414b83b3deda483cbff3b3087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b196648683b7d9d0038979eb697073c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b196648683b7d9d0038979eb697073c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4b196648683b7d9d0038979eb697073c">restartFilter</a> (void)</td></tr>
<tr class="memdesc:a4b196648683b7d9d0038979eb697073c"><td class="mdescLeft">&#160;</td><td class="mdescRight">restart the filter used by this device <br/></td></tr>
<tr class="separator:a4b196648683b7d9d0038979eb697073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add086b77793cf3c81e5107118143956f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#add086b77793cf3c81e5107118143956f">queueLength</a> (void) const </td></tr>
<tr class="memdesc:add086b77793cf3c81e5107118143956f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently in the cache for the device.  <a href="#add086b77793cf3c81e5107118143956f"></a><br/></td></tr>
<tr class="separator:add086b77793cf3c81e5107118143956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf406f28a693c3bed6e717c39f397573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adf406f28a693c3bed6e717c39f397573">deviceState</a> (void) const </td></tr>
<tr class="memdesc:adf406f28a693c3bed6e717c39f397573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of this device.  <a href="#adf406f28a693c3bed6e717c39f397573"></a><br/></td></tr>
<tr class="separator:adf406f28a693c3bed6e717c39f397573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c13affa6f5cc92fd0a64aecb709d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a060c13affa6f5cc92fd0a64aecb709d4">nextAvailableDataPacket</a> (void)</td></tr>
<tr class="memdesc:a060c13affa6f5cc92fd0a64aecb709d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next data packet in the live stream.  <a href="#a060c13affa6f5cc92fd0a64aecb709d4"></a><br/></td></tr>
<tr class="separator:a060c13affa6f5cc92fd0a64aecb709d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2ab8100043d0622459b73ba134f8f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0a2ab8100043d0622459b73ba134f8f9">dataPacketByIndex</a> (uint32_t index)</td></tr>
<tr class="memdesc:a0a2ab8100043d0622459b73ba134f8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <em>index'th</em> data packet for the device.  <a href="#a0a2ab8100043d0622459b73ba134f8f9"></a><br/></td></tr>
<tr class="separator:a0a2ab8100043d0622459b73ba134f8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0149482e881275a42cb00bf62f2822ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0149482e881275a42cb00bf62f2822ff">dataPacketById</a> (uint64_t packetId)</td></tr>
<tr class="memdesc:a0149482e881275a42cb00bf62f2822ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a data packet for the device with the supplied <em>packetId</em>.  <a href="#a0149482e881275a42cb00bf62f2822ff"></a><br/></td></tr>
<tr class="separator:a0149482e881275a42cb00bf62f2822ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd94fa30eac6af10e5d4c5cc2374ae73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afd94fa30eac6af10e5d4c5cc2374ae73">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:afd94fa30eac6af10e5d4c5cc2374ae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="#afd94fa30eac6af10e5d4c5cc2374ae73"></a><br/></td></tr>
<tr class="separator:afd94fa30eac6af10e5d4c5cc2374ae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e4d381affb5286f57b25256dbf88c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a43e4d381affb5286f57b25256dbf88c9">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a43e4d381affb5286f57b25256dbf88c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="#a43e4d381affb5286f57b25256dbf88c9"></a><br/></td></tr>
<tr class="separator:a43e4d381affb5286f57b25256dbf88c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187440a3a947426a09e51f8050fdbbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a187440a3a947426a09e51f8050fdbbcd">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a187440a3a947426a09e51f8050fdbbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#a187440a3a947426a09e51f8050fdbbcd"></a><br/></td></tr>
<tr class="separator:a187440a3a947426a09e51f8050fdbbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150dd0d4d207678d991a67d7c9d8a8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a150dd0d4d207678d991a67d7c9d8a8ba">deviceConfiguration</a> (void) const </td></tr>
<tr class="memdesc:a150dd0d4d207678d991a67d7c9d8a8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device configuration.  <a href="#a150dd0d4d207678d991a67d7c9d8a8ba"></a><br/></td></tr>
<tr class="separator:a150dd0d4d207678d991a67d7c9d8a8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043c5d2829d9294ebc1a230903a3410a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043c5d2829d9294ebc1a230903a3410a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a043c5d2829d9294ebc1a230903a3410a">clear</a> (void)</td></tr>
<tr class="memdesc:a043c5d2829d9294ebc1a230903a3410a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate all fields, possibly removing stuff like filters and calibration info. <br/></td></tr>
<tr class="separator:a043c5d2829d9294ebc1a230903a3410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a5dd4a13161a69e4927191a7295cd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad9a5dd4a13161a69e4927191a7295cd3">batteryLevel</a> (void) const </td></tr>
<tr class="memdesc:ad9a5dd4a13161a69e4927191a7295cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication.  <a href="#ad9a5dd4a13161a69e4927191a7295cd3"></a><br/></td></tr>
<tr class="separator:ad9a5dd4a13161a69e4927191a7295cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f031725cdf6f7b41ef393f1fd1f1f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0">updateRateForDataIdentifier</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a47f031725cdf6f7b41ef393f1fd1f1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.  <a href="#a47f031725cdf6f7b41ef393f1fd1f1f0"></a><br/></td></tr>
<tr class="separator:a47f031725cdf6f7b41ef393f1fd1f1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e50cfe473e459b5a6d35bb338214e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a668e50cfe473e459b5a6d35bb338214e">updateRateForProcessedDataIdentifier</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a668e50cfe473e459b5a6d35bb338214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.  <a href="#a668e50cfe473e459b5a6d35bb338214e"></a><br/></td></tr>
<tr class="separator:a668e50cfe473e459b5a6d35bb338214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358a87088eeee36a8be981d95cd252f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_int_array.html">XsIntArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a358a87088eeee36a8be981d95cd252f0">supportedUpdateRates</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType=XDI_None) const </td></tr>
<tr class="memdesc:a358a87088eeee36a8be981d95cd252f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the device for its supported update rates for the given <em>dataType</em>.  <a href="#a358a87088eeee36a8be981d95cd252f0"></a><br/></td></tr>
<tr class="separator:a358a87088eeee36a8be981d95cd252f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9270a980750ea542a0584a360e2758"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2d9270a980750ea542a0584a360e2758">maximumUpdateRate</a> (void) const </td></tr>
<tr class="memdesc:a2d9270a980750ea542a0584a360e2758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum update rate for the device.  <a href="#a2d9270a980750ea542a0584a360e2758"></a><br/></td></tr>
<tr class="separator:a2d9270a980750ea542a0584a360e2758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32dc53bf86ce26b9671d9c4180ecb3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa32dc53bf86ce26b9671d9c4180ecb3b">hasDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:aa32dc53bf86ce26b9671d9c4180ecb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em>.  <a href="#aa32dc53bf86ce26b9671d9c4180ecb3b"></a><br/></td></tr>
<tr class="separator:aa32dc53bf86ce26b9671d9c4180ecb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67109aa78da4effcd63ef007810f6e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac67109aa78da4effcd63ef007810f6e7">hasProcessedDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:ac67109aa78da4effcd63ef007810f6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em> after processing on the host.  <a href="#ac67109aa78da4effcd63ef007810f6e7"></a><br/></td></tr>
<tr class="separator:ac67109aa78da4effcd63ef007810f6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e487178fca0cda67e06fe66bf17575b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2e487178fca0cda67e06fe66bf17575b">productCode</a> (void) const </td></tr>
<tr class="memdesc:a2e487178fca0cda67e06fe66bf17575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product code of the device.  <a href="#a2e487178fca0cda67e06fe66bf17575b"></a><br/></td></tr>
<tr class="separator:a2e487178fca0cda67e06fe66bf17575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2d4bf3b5d990d064daebb955771234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4a2d4bf3b5d990d064daebb955771234">portName</a> (void) const </td></tr>
<tr class="memdesc:a4a2d4bf3b5d990d064daebb955771234"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port name of the connection.  <a href="#a4a2d4bf3b5d990d064daebb955771234"></a><br/></td></tr>
<tr class="separator:a4a2d4bf3b5d990d064daebb955771234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613cd4d200015a0e457c29ddcb689152"><td class="memItemLeft" align="right" valign="top">XsBaudRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a613cd4d200015a0e457c29ddcb689152">baudRate</a> (void) const </td></tr>
<tr class="memdesc:a613cd4d200015a0e457c29ddcb689152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected.  <a href="#a613cd4d200015a0e457c29ddcb689152"></a><br/></td></tr>
<tr class="separator:a613cd4d200015a0e457c29ddcb689152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7748ffd37793917d6ce13e464cf2c9"><td class="memItemLeft" align="right" valign="top">XsBaudRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6c7748ffd37793917d6ce13e464cf2c9">serialBaudRate</a> (void) const </td></tr>
<tr class="memdesc:a6c7748ffd37793917d6ce13e464cf2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The baud rate configured for cabled connection.  <a href="#a6c7748ffd37793917d6ce13e464cf2c9"></a><br/></td></tr>
<tr class="separator:a6c7748ffd37793917d6ce13e464cf2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa282f42a414355218001f4471079a48a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa282f42a414355218001f4471079a48a">hardwareVersion</a> (void) const </td></tr>
<tr class="memdesc:aa282f42a414355218001f4471079a48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hardware version of the device.  <a href="#aa282f42a414355218001f4471079a48a"></a><br/></td></tr>
<tr class="separator:aa282f42a414355218001f4471079a48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab14a71dc537d1ca319a94ee50eb7aaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aab14a71dc537d1ca319a94ee50eb7aaf">portNumber</a> (void) const </td></tr>
<tr class="memdesc:aab14a71dc537d1ca319a94ee50eb7aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the port number of the connection.  <a href="#aab14a71dc537d1ca319a94ee50eb7aaf"></a><br/></td></tr>
<tr class="separator:aab14a71dc537d1ca319a94ee50eb7aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aef28ccbb4b80b80be6b85fedd6d87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab8aef28ccbb4b80b80be6b85fedd6d87">startRecording</a> (void)</td></tr>
<tr class="memdesc:ab8aef28ccbb4b80b80be6b85fedd6d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording incoming data.  <a href="#ab8aef28ccbb4b80b80be6b85fedd6d87"></a><br/></td></tr>
<tr class="separator:ab8aef28ccbb4b80b80be6b85fedd6d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7899e535c8459b3154a6610c71b7c471"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7899e535c8459b3154a6610c71b7c471">stopRecording</a> (void)</td></tr>
<tr class="memdesc:a7899e535c8459b3154a6610c71b7c471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording incoming data.  <a href="#a7899e535c8459b3154a6610c71b7c471"></a><br/></td></tr>
<tr class="separator:a7899e535c8459b3154a6610c71b7c471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f5dfc2bd1168a70d1e7f2335cdb5a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a59f5dfc2bd1168a70d1e7f2335cdb5a8">setOptionEnabled</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option, bool enabled)</td></tr>
<tr class="memdesc:a59f5dfc2bd1168a70d1e7f2335cdb5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable a processing option.  <a href="#a59f5dfc2bd1168a70d1e7f2335cdb5a8"></a><br/></td></tr>
<tr class="separator:a59f5dfc2bd1168a70d1e7f2335cdb5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0da29c15d3aaf244711c98c48c128e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae0da29c15d3aaf244711c98c48c128e9">isOptionEnabled</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option) const </td></tr>
<tr class="memdesc:ae0da29c15d3aaf244711c98c48c128e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a processing option is enabled or not.  <a href="#ae0da29c15d3aaf244711c98c48c128e9"></a><br/></td></tr>
<tr class="separator:ae0da29c15d3aaf244711c98c48c128e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92bb39794188879d0731c4fd1fb0720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac92bb39794188879d0731c4fd1fb0720">initializeFilter</a> (void)</td></tr>
<tr class="memdesc:ac92bb39794188879d0731c4fd1fb0720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the filter used by this device.  <a href="#ac92bb39794188879d0731c4fd1fb0720"></a><br/></td></tr>
<tr class="separator:ac92bb39794188879d0731c4fd1fb0720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3589494a7043c386d42fc147301748c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3589494a7043c386d42fc147301748c5">sendCustomMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;messageSend, bool waitForResult, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;messageReceive, int timeout=0)</td></tr>
<tr class="memdesc:a3589494a7043c386d42fc147301748c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a custom message <em>messageSend</em> to the device and possibly wait for a result.  <a href="#a3589494a7043c386d42fc147301748c5"></a><br/></td></tr>
<tr class="separator:a3589494a7043c386d42fc147301748c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91de612878efc23c4686f7c9d236e995"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a91de612878efc23c4686f7c9d236e995">sendRawMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a91de612878efc23c4686f7c9d236e995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message directly to the communicator.  <a href="#a91de612878efc23c4686f7c9d236e995"></a><br/></td></tr>
<tr class="separator:a91de612878efc23c4686f7c9d236e995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac891f7171b5e55f2a20d8b9d5b105"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a81ac891f7171b5e55f2a20d8b9d5b105">setSerialBaudRate</a> (XsBaudRate baudrate)</td></tr>
<tr class="memdesc:a81ac891f7171b5e55f2a20d8b9d5b105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the serial baudrate to <em>baudrate</em>.  <a href="#a81ac891f7171b5e55f2a20d8b9d5b105"></a><br/></td></tr>
<tr class="separator:a81ac891f7171b5e55f2a20d8b9d5b105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1d6380fb464aaab3fdbd5dc10e9fcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4c1d6380fb464aaab3fdbd5dc10e9fcc">isMotionTracker</a> (void) const </td></tr>
<tr class="memdesc:a4c1d6380fb464aaab3fdbd5dc10e9fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a motion tracker.  <a href="#a4c1d6380fb464aaab3fdbd5dc10e9fcc"></a><br/></td></tr>
<tr class="separator:a4c1d6380fb464aaab3fdbd5dc10e9fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed7e4f103b81d0d7dab12e4bbd19e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0ed7e4f103b81d0d7dab12e4bbd19e44">outputMode</a> (void) const </td></tr>
<tr class="memdesc:a0ed7e4f103b81d0d7dab12e4bbd19e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output mode.  <a href="#a0ed7e4f103b81d0d7dab12e4bbd19e44"></a><br/></td></tr>
<tr class="separator:a0ed7e4f103b81d0d7dab12e4bbd19e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d63878cb644ff64a4053d82c3a2d063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6d63878cb644ff64a4053d82c3a2d063">setOutputMode</a> (<a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a> mode)</td></tr>
<tr class="memdesc:a6d63878cb644ff64a4053d82c3a2d063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the outputmode for this device.  <a href="#a6d63878cb644ff64a4053d82c3a2d063"></a><br/></td></tr>
<tr class="separator:a6d63878cb644ff64a4053d82c3a2d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ed7e8c1ec819efff29652b0378d27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa1ed7e8c1ec819efff29652b0378d27c">outputSettings</a> (void) const </td></tr>
<tr class="memdesc:aa1ed7e8c1ec819efff29652b0378d27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output settings.  <a href="#aa1ed7e8c1ec819efff29652b0378d27c"></a><br/></td></tr>
<tr class="separator:aa1ed7e8c1ec819efff29652b0378d27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6858b0e1ff701f8c8312b0085626e3f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6858b0e1ff701f8c8312b0085626e3f7">setOutputSettings</a> (<a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a> outputsettings)</td></tr>
<tr class="memdesc:a6858b0e1ff701f8c8312b0085626e3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output settings for this device.  <a href="#a6858b0e1ff701f8c8312b0085626e3f7"></a><br/></td></tr>
<tr class="separator:a6858b0e1ff701f8c8312b0085626e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e05d870d575a755034e2f10f264d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a365e05d870d575a755034e2f10f264d5">updateRate</a> (void) const </td></tr>
<tr class="memdesc:a365e05d870d575a755034e2f10f264d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the legacy update rate of the device.  <a href="#a365e05d870d575a755034e2f10f264d5"></a><br/></td></tr>
<tr class="separator:a365e05d870d575a755034e2f10f264d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da43d5b8efb0e99b724bd999a9459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3c0da43d5b8efb0e99b724bd999a9459">setUpdateRate</a> (int rate)</td></tr>
<tr class="memdesc:a3c0da43d5b8efb0e99b724bd999a9459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the legacy update rate of the device.  <a href="#a3c0da43d5b8efb0e99b724bd999a9459"></a><br/></td></tr>
<tr class="separator:a3c0da43d5b8efb0e99b724bd999a9459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf953cbe304a22bd94892a7baf265738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738">outputConfiguration</a> (void) const </td></tr>
<tr class="memdesc:acf953cbe304a22bd94892a7baf265738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured output of the device.  <a href="#acf953cbe304a22bd94892a7baf265738"></a><br/></td></tr>
<tr class="separator:acf953cbe304a22bd94892a7baf265738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9de7bd8ac2786cd7d1d3cd3f46878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad0c9de7bd8ac2786cd7d1d3cd3f46878">processedOutputConfiguration</a> (void) const </td></tr>
<tr class="memdesc:ad0c9de7bd8ac2786cd7d1d3cd3f46878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full output configuration including post processing outputs.  <a href="#ad0c9de7bd8ac2786cd7d1d3cd3f46878"></a><br/></td></tr>
<tr class="separator:ad0c9de7bd8ac2786cd7d1d3cd3f46878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af303efb04dde3783bfebc8e4b1025578"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578">setOutputConfiguration</a> (<a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> &amp;config)</td></tr>
<tr class="memdesc:af303efb04dde3783bfebc8e4b1025578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output configuration for this device When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.  <a href="#af303efb04dde3783bfebc8e4b1025578"></a><br/></td></tr>
<tr class="separator:af303efb04dde3783bfebc8e4b1025578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0561ec33a8d9c188b2e22b5ca73880e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e">isInLegacyMode</a> (void) const </td></tr>
<tr class="memdesc:aa0561ec33a8d9c188b2e22b5ca73880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device is outputting data in legacy mode.  <a href="#aa0561ec33a8d9c188b2e22b5ca73880e"></a><br/></td></tr>
<tr class="separator:aa0561ec33a8d9c188b2e22b5ca73880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94004970e7e9c628dc0007bc8422bffa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a94004970e7e9c628dc0007bc8422bffa">isInStringOutputMode</a> (void) const </td></tr>
<tr class="memdesc:a94004970e7e9c628dc0007bc8422bffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device is outputting data in string mode.  <a href="#a94004970e7e9c628dc0007bc8422bffa"></a><br/></td></tr>
<tr class="separator:a94004970e7e9c628dc0007bc8422bffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7240291ff040ebbe6abb6ee229ea5756"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7240291ff040ebbe6abb6ee229ea5756">usesLegacyDeviceMode</a> (void) const </td></tr>
<tr class="memdesc:a7240291ff040ebbe6abb6ee229ea5756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the device uses legacy device mode.  <a href="#a7240291ff040ebbe6abb6ee229ea5756"></a><br/></td></tr>
<tr class="separator:a7240291ff040ebbe6abb6ee229ea5756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00e59356f6f4a9bd4124b0c2a628989"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af00e59356f6f4a9bd4124b0c2a628989">stringOutputType</a> (void) const </td></tr>
<tr class="memdesc:af00e59356f6f4a9bd4124b0c2a628989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string output type.  <a href="#af00e59356f6f4a9bd4124b0c2a628989"></a><br/></td></tr>
<tr class="separator:af00e59356f6f4a9bd4124b0c2a628989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db7f9734a5523a435d67289ec44ecd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3db7f9734a5523a435d67289ec44ecd0">setStringOutputType</a> (uint16_t type)</td></tr>
<tr class="memdesc:a3db7f9734a5523a435d67289ec44ecd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the string output type for this device.  <a href="#a3db7f9734a5523a435d67289ec44ecd0"></a><br/></td></tr>
<tr class="separator:a3db7f9734a5523a435d67289ec44ecd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae105a1c7376133c8d74e5635ffe088e9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae105a1c7376133c8d74e5635ffe088e9">samplePeriod</a> (void) const </td></tr>
<tr class="memdesc:ae105a1c7376133c8d74e5635ffe088e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample period.  <a href="#ae105a1c7376133c8d74e5635ffe088e9"></a><br/></td></tr>
<tr class="separator:ae105a1c7376133c8d74e5635ffe088e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a744f146c605a383ce90cac08dafa63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1a744f146c605a383ce90cac08dafa63">setSamplePeriod</a> (uint16_t period)</td></tr>
<tr class="memdesc:a1a744f146c605a383ce90cac08dafa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample period for this device.  <a href="#a1a744f146c605a383ce90cac08dafa63"></a><br/></td></tr>
<tr class="separator:a1a744f146c605a383ce90cac08dafa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7330dcb033684c248d73781414f1fc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1b7330dcb033684c248d73781414f1fc">outputSkipFactor</a> (void) const </td></tr>
<tr class="memdesc:a1b7330dcb033684c248d73781414f1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output skip factor.  <a href="#a1b7330dcb033684c248d73781414f1fc"></a><br/></td></tr>
<tr class="separator:a1b7330dcb033684c248d73781414f1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148ae39934d2bfff02afad6092cbbbcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a148ae39934d2bfff02afad6092cbbbcc">setOutputSkipFactor</a> (uint16_t skipFactor)</td></tr>
<tr class="memdesc:a148ae39934d2bfff02afad6092cbbbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output skip factor for this device.  <a href="#a148ae39934d2bfff02afad6092cbbbcc"></a><br/></td></tr>
<tr class="separator:a148ae39934d2bfff02afad6092cbbbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530efa668ba72fc4fc693c56676b71fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd">deviceMode</a> (void) const </td></tr>
<tr class="memdesc:a530efa668ba72fc4fc693c56676b71fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the legacy output configuration as an XsDeviceMode object.  <a href="#a530efa668ba72fc4fc693c56676b71fd"></a><br/></td></tr>
<tr class="separator:a530efa668ba72fc4fc693c56676b71fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45b46b9b36d94c9e254f6152b7f9207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207">setDeviceMode</a> (const <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> &amp;mode)</td></tr>
<tr class="memdesc:ab45b46b9b36d94c9e254f6152b7f9207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the legacy output configuration of the device.  <a href="#ab45b46b9b36d94c9e254f6152b7f9207"></a><br/></td></tr>
<tr class="separator:ab45b46b9b36d94c9e254f6152b7f9207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8612480d5b3eead853413bb37544b5a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8612480d5b3eead853413bb37544b5a6">dataLength</a> (void) const </td></tr>
<tr class="memdesc:a8612480d5b3eead853413bb37544b5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the data in the legacy MTData packets that the device will send in measurement mode.  <a href="#a8612480d5b3eead853413bb37544b5a6"></a><br/></td></tr>
<tr class="separator:a8612480d5b3eead853413bb37544b5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80911ae5aca0ccce12dfb7be00c82a79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80911ae5aca0ccce12dfb7be00c82a79"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a80911ae5aca0ccce12dfb7be00c82a79">clearCache</a> (void)</td></tr>
<tr class="memdesc:a80911ae5aca0ccce12dfb7be00c82a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the caches of this device. <br/></td></tr>
<tr class="separator:a80911ae5aca0ccce12dfb7be00c82a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b162561df7e93e8a3ebe35a920ba655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6b162561df7e93e8a3ebe35a920ba655">syncSettings</a> (void) const </td></tr>
<tr class="memdesc:a6b162561df7e93e8a3ebe35a920ba655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the current synchronization settings of the device.  <a href="#a6b162561df7e93e8a3ebe35a920ba655"></a><br/></td></tr>
<tr class="separator:a6b162561df7e93e8a3ebe35a920ba655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1e8487e22ddfa3376893262e3c3607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1d1e8487e22ddfa3376893262e3c3607">setSyncSettings</a> (const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> &amp;settingList)</td></tr>
<tr class="memdesc:a1d1e8487e22ddfa3376893262e3c3607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the synchronization settings of the device.  <a href="#a1d1e8487e22ddfa3376893262e3c3607"></a><br/></td></tr>
<tr class="separator:a1d1e8487e22ddfa3376893262e3c3607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a3d053b062705db378d774f8609a6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad5a3d053b062705db378d774f8609a6e">isSyncMaster</a> (void) const </td></tr>
<tr class="memdesc:ad5a3d053b062705db378d774f8609a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a master role regarding the device synchronization  <a href="#ad5a3d053b062705db378d774f8609a6e"></a><br/></td></tr>
<tr class="separator:ad5a3d053b062705db378d774f8609a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1d4340c666b090dfc2d3b2d0a4b75d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afb1d4340c666b090dfc2d3b2d0a4b75d">isSyncSlave</a> (void) const </td></tr>
<tr class="memdesc:afb1d4340c666b090dfc2d3b2d0a4b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a slave role regarding the device synchronization  <a href="#afb1d4340c666b090dfc2d3b2d0a4b75d"></a><br/></td></tr>
<tr class="separator:afb1d4340c666b090dfc2d3b2d0a4b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99fb37cbc1479c774c891c01dd43fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af99fb37cbc1479c774c891c01dd43fad">supportedSyncSettings</a> (void) const </td></tr>
<tr class="memdesc:af99fb37cbc1479c774c891c01dd43fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all supported synchronization settings available on the device.  <a href="#af99fb37cbc1479c774c891c01dd43fad"></a><br/></td></tr>
<tr class="separator:af99fb37cbc1479c774c891c01dd43fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4539825a286248b59c66bd89cf7c1090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4539825a286248b59c66bd89cf7c1090">gotoMeasurement</a> (void)</td></tr>
<tr class="memdesc:a4539825a286248b59c66bd89cf7c1090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put this device in measurement mode.  <a href="#a4539825a286248b59c66bd89cf7c1090"></a><br/></td></tr>
<tr class="separator:a4539825a286248b59c66bd89cf7c1090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b32660f266c44ba18323d1a26b6b7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab2b32660f266c44ba18323d1a26b6b7e">gotoConfig</a> (void)</td></tr>
<tr class="memdesc:ab2b32660f266c44ba18323d1a26b6b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in config mode.  <a href="#ab2b32660f266c44ba18323d1a26b6b7e"></a><br/></td></tr>
<tr class="separator:ab2b32660f266c44ba18323d1a26b6b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9625df9c12421a71686103b4becb17a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9625df9c12421a71686103b4becb17a2">restoreFactoryDefaults</a> (void)</td></tr>
<tr class="memdesc:a9625df9c12421a71686103b4becb17a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the device to its factory default settings.  <a href="#a9625df9c12421a71686103b4becb17a2"></a><br/></td></tr>
<tr class="separator:a9625df9c12421a71686103b4becb17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede7b469948953c5ea2f28dd6bda48f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aede7b469948953c5ea2f28dd6bda48f1">reset</a> (void)</td></tr>
<tr class="memdesc:aede7b469948953c5ea2f28dd6bda48f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the device.  <a href="#aede7b469948953c5ea2f28dd6bda48f1"></a><br/></td></tr>
<tr class="separator:aede7b469948953c5ea2f28dd6bda48f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd03e4859deb925975b4a3423b35d2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adcd03e4859deb925975b4a3423b35d2c">writeDeviceSettingsToFile</a> (void)</td></tr>
<tr class="memdesc:adcd03e4859deb925975b4a3423b35d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the emts/wms/xms of the device and all its children to the open logfile.  <a href="#adcd03e4859deb925975b4a3423b35d2c"></a><br/></td></tr>
<tr class="separator:adcd03e4859deb925975b4a3423b35d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96da6f3434f509e20b46dec2e81f5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae96da6f3434f509e20b46dec2e81f5ed">flushInputBuffers</a> (bool complete)</td></tr>
<tr class="memdesc:ae96da6f3434f509e20b46dec2e81f5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of the device.  <a href="#ae96da6f3434f509e20b46dec2e81f5ed"></a><br/></td></tr>
<tr class="separator:ae96da6f3434f509e20b46dec2e81f5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e2d6a5a3edec9b8185f065b41a2ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a60e2d6a5a3edec9b8185f065b41a2ae3">syncRole</a> (void) const </td></tr>
<tr class="memdesc:a60e2d6a5a3edec9b8185f065b41a2ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the synchronization role of the device.  <a href="#a60e2d6a5a3edec9b8185f065b41a2ae3"></a><br/></td></tr>
<tr class="separator:a60e2d6a5a3edec9b8185f065b41a2ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15312f246b4a1eaace09d3f98e8f9ed7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a15312f246b4a1eaace09d3f98e8f9ed7">loadLogFile</a> (void)</td></tr>
<tr class="memdesc:a15312f246b4a1eaace09d3f98e8f9ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a complete logfile.  <a href="#a15312f246b4a1eaace09d3f98e8f9ed7"></a><br/></td></tr>
<tr class="separator:a15312f246b4a1eaace09d3f98e8f9ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46902bfacdd9f993daa935399bacc781"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a46902bfacdd9f993daa935399bacc781">abortLoadLogFile</a> (void)</td></tr>
<tr class="memdesc:a46902bfacdd9f993daa935399bacc781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts loading a logfile.  <a href="#a46902bfacdd9f993daa935399bacc781"></a><br/></td></tr>
<tr class="separator:a46902bfacdd9f993daa935399bacc781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067da0d706ba791a76448d648066c934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a067da0d706ba791a76448d648066c934">logFileName</a> (void) const </td></tr>
<tr class="memdesc:a067da0d706ba791a76448d648066c934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the log file the device is reading from.  <a href="#a067da0d706ba791a76448d648066c934"></a><br/></td></tr>
<tr class="separator:a067da0d706ba791a76448d648066c934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c1ca0b7962af4334aa765bfb5155a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af46c1ca0b7962af4334aa765bfb5155a">droppedPacketCount</a> (void) const </td></tr>
<tr class="memdesc:af46c1ca0b7962af4334aa765bfb5155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of packets dropped by the port.  <a href="#af46c1ca0b7962af4334aa765bfb5155a"></a><br/></td></tr>
<tr class="separator:af46c1ca0b7962af4334aa765bfb5155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dae7f768d4bec3f98fbec0b82d92490"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5dae7f768d4bec3f98fbec0b82d92490">resetOrientation</a> (<a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a> resetmethod)</td></tr>
<tr class="memdesc:a5dae7f768d4bec3f98fbec0b82d92490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an orientation reset on the device using the given <em>resetMethod</em>.  <a href="#a5dae7f768d4bec3f98fbec0b82d92490"></a><br/></td></tr>
<tr class="separator:a5dae7f768d4bec3f98fbec0b82d92490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae662335ace1527f73fe918ddf5364242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae662335ace1527f73fe918ddf5364242">peekMessageId</a> (void)</td></tr>
<tr class="memdesc:ae662335ace1527f73fe918ddf5364242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a peek at the next message's message ID in the file.  <a href="#ae662335ace1527f73fe918ddf5364242"></a><br/></td></tr>
<tr class="separator:ae662335ace1527f73fe918ddf5364242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d64884658c21c321545420ab8f0aa4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a41d64884658c21c321545420ab8f0aa4">resetLogFileReadPosition</a> (void)</td></tr>
<tr class="memdesc:a41d64884658c21c321545420ab8f0aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read position of the open log file to the start of the file.  <a href="#a41d64884658c21c321545420ab8f0aa4"></a><br/></td></tr>
<tr class="separator:a41d64884658c21c321545420ab8f0aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b20b09509ae122b7b72129a1689f081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2b20b09509ae122b7b72129a1689f081">logFileSize</a> (void) const </td></tr>
<tr class="memdesc:a2b20b09509ae122b7b72129a1689f081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the log file the device is reading from.  <a href="#a2b20b09509ae122b7b72129a1689f081"></a><br/></td></tr>
<tr class="separator:a2b20b09509ae122b7b72129a1689f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b4bcf9503a0e531de04d40fb05dc0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af5b4bcf9503a0e531de04d40fb05dc0d">logFileReadPosition</a> (void) const </td></tr>
<tr class="memdesc:af5b4bcf9503a0e531de04d40fb05dc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current read position of the open log file.  <a href="#af5b4bcf9503a0e531de04d40fb05dc0d"></a><br/></td></tr>
<tr class="separator:af5b4bcf9503a0e531de04d40fb05dc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a029ceaba1cdfcd0ab1092e8c42662c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4a029ceaba1cdfcd0ab1092e8c42662c">updateCachedDeviceInformation</a> (void)</td></tr>
<tr class="memdesc:a4a029ceaba1cdfcd0ab1092e8c42662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the cached device information for all devices connected to this port.  <a href="#a4a029ceaba1cdfcd0ab1092e8c42662c"></a><br/></td></tr>
<tr class="separator:a4a029ceaba1cdfcd0ab1092e8c42662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e5368ad9948b79ff0d45ec5068b9c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab8e5368ad9948b79ff0d45ec5068b9c6">enableProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:ab8e5368ad9948b79ff0d45ec5068b9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an additional communication protocol when reading messages.  <a href="#ab8e5368ad9948b79ff0d45ec5068b9c6"></a><br/></td></tr>
<tr class="separator:ab8e5368ad9948b79ff0d45ec5068b9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1bb5ae93a04f0067456fd3cd866f54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adb1bb5ae93a04f0067456fd3cd866f54">disableProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:adb1bb5ae93a04f0067456fd3cd866f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#ab8e5368ad9948b79ff0d45ec5068b9c6" title="Enable an additional communication protocol when reading messages.">XsDevice::enableProtocol</a>.  <a href="#adb1bb5ae93a04f0067456fd3cd866f54"></a><br/></td></tr>
<tr class="separator:adb1bb5ae93a04f0067456fd3cd866f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89565c9eb41e44eed36c83eca34b822d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a89565c9eb41e44eed36c83eca34b822d">isProtocolEnabled</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol) const </td></tr>
<tr class="separator:a89565c9eb41e44eed36c83eca34b822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b7ef873a12e425901544c7349092b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6b2b7ef873a12e425901544c7349092b">resetDroppedPacketCount</a> (void)</td></tr>
<tr class="memdesc:a6b2b7ef873a12e425901544c7349092b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the dropped packet count.  <a href="#a6b2b7ef873a12e425901544c7349092b"></a><br/></td></tr>
<tr class="separator:a6b2b7ef873a12e425901544c7349092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404b469ed2b928365d5a6ff63ee81ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac404b469ed2b928365d5a6ff63ee81ea">setQueueMode</a> (<a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> mode)</td></tr>
<tr class="memdesc:ac404b469ed2b928365d5a6ff63ee81ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the queue mode to the given <em>mode</em>.  <a href="#ac404b469ed2b928365d5a6ff63ee81ea"></a><br/></td></tr>
<tr class="separator:ac404b469ed2b928365d5a6ff63ee81ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b86ccc2b443f1c2bfd6c99fefcfe34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a45b86ccc2b443f1c2bfd6c99fefcfe34">queueMode</a> (void) const </td></tr>
<tr class="memdesc:a45b86ccc2b443f1c2bfd6c99fefcfe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently used queue mode.  <a href="#a45b86ccc2b443f1c2bfd6c99fefcfe34"></a><br/></td></tr>
<tr class="separator:a45b86ccc2b443f1c2bfd6c99fefcfe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4b495e36200adb8602af9374a18972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4c4b495e36200adb8602af9374a18972">connectivityState</a> (void) const </td></tr>
<tr class="memdesc:a4c4b495e36200adb8602af9374a18972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connectivity state of the device.  <a href="#a4c4b495e36200adb8602af9374a18972"></a><br/></td></tr>
<tr class="separator:a4c4b495e36200adb8602af9374a18972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451ae32410afc778ef81fa3e3c7a9fe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a451ae32410afc778ef81fa3e3c7a9fe4">enableRadio</a> (int channel)</td></tr>
<tr class="memdesc:a451ae32410afc778ef81fa3e3c7a9fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio channel to use for wireless communication.  <a href="#a451ae32410afc778ef81fa3e3c7a9fe4"></a><br/></td></tr>
<tr class="separator:a451ae32410afc778ef81fa3e3c7a9fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3614a08ca0e3d2df2f72aa9632189f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac3614a08ca0e3d2df2f72aa9632189f6">disableRadio</a> (void)</td></tr>
<tr class="memdesc:ac3614a08ca0e3d2df2f72aa9632189f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the radio for this station, resetting all children to disconnected state.  <a href="#ac3614a08ca0e3d2df2f72aa9632189f6"></a><br/></td></tr>
<tr class="separator:ac3614a08ca0e3d2df2f72aa9632189f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467926061f722fd0f63900420144a57d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a467926061f722fd0f63900420144a57d">radioChannel</a> (void) const </td></tr>
<tr class="memdesc:a467926061f722fd0f63900420144a57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radio channel used for wireless communication.  <a href="#a467926061f722fd0f63900420144a57d"></a><br/></td></tr>
<tr class="separator:a467926061f722fd0f63900420144a57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded40bf432fa254340cb4c5640a0d038"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aded40bf432fa254340cb4c5640a0d038">isRadioEnabled</a> (void) const </td></tr>
<tr class="memdesc:aded40bf432fa254340cb4c5640a0d038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the radio is enabled.  <a href="#aded40bf432fa254340cb4c5640a0d038"></a><br/></td></tr>
<tr class="separator:aded40bf432fa254340cb4c5640a0d038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53dfaa0f730f065fcb6c1eb5b411db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae53dfaa0f730f065fcb6c1eb5b411db0">makeOperational</a> (void)</td></tr>
<tr class="memdesc:ae53dfaa0f730f065fcb6c1eb5b411db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets te Awinda station to operational state.  <a href="#ae53dfaa0f730f065fcb6c1eb5b411db0"></a><br/></td></tr>
<tr class="separator:ae53dfaa0f730f065fcb6c1eb5b411db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa63b9e9973ab42e6f57a020e03314f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3fa63b9e9973ab42e6f57a020e03314f">isOperational</a> (void) const </td></tr>
<tr class="separator:a3fa63b9e9973ab42e6f57a020e03314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac523a222c2eb7e72864862ef2534e6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aac523a222c2eb7e72864862ef2534e6a">isInSyncBoxMode</a> (void)</td></tr>
<tr class="separator:aac523a222c2eb7e72864862ef2534e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c94357252aee3388dee8cca4ea6b42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa9c94357252aee3388dee8cca4ea6b42">setSyncBoxMode</a> (bool enabled)</td></tr>
<tr class="memdesc:aa9c94357252aee3388dee8cca4ea6b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sync box mode of the Awinda Station device.  <a href="#aa9c94357252aee3388dee8cca4ea6b42"></a><br/></td></tr>
<tr class="separator:aa9c94357252aee3388dee8cca4ea6b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c7b3f9663a3407ff1953937a56d5dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a14c7b3f9663a3407ff1953937a56d5dd">abortFlushing</a> (void)</td></tr>
<tr class="memdesc:a14c7b3f9663a3407ff1953937a56d5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the wireless flushing operation and finalize the recording.  <a href="#a14c7b3f9663a3407ff1953937a56d5dd"></a><br/></td></tr>
<tr class="separator:a14c7b3f9663a3407ff1953937a56d5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ca303a74e4655f2481276c3ebc1d70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a65ca303a74e4655f2481276c3ebc1d70">setDeviceAccepted</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#a790a9f814ac94d1e71452661c943d521">deviceId</a>)</td></tr>
<tr class="memdesc:a65ca303a74e4655f2481276c3ebc1d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a device.  <a href="#a65ca303a74e4655f2481276c3ebc1d70"></a><br/></td></tr>
<tr class="separator:a65ca303a74e4655f2481276c3ebc1d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d6aa7f51ace66f2b3c5435f4bf71eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab6d6aa7f51ace66f2b3c5435f4bf71eb">setDeviceRejected</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#a790a9f814ac94d1e71452661c943d521">deviceId</a>)</td></tr>
<tr class="memdesc:ab6d6aa7f51ace66f2b3c5435f4bf71eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejects a device.  <a href="#ab6d6aa7f51ace66f2b3c5435f4bf71eb"></a><br/></td></tr>
<tr class="separator:ab6d6aa7f51ace66f2b3c5435f4bf71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf98f466ea315052a1cb926961c2e8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0bf98f466ea315052a1cb926961c2e8a">acceptConnection</a> (void)</td></tr>
<tr class="memdesc:a0bf98f466ea315052a1cb926961c2e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connections from the device on the parent/master device.  <a href="#a0bf98f466ea315052a1cb926961c2e8a"></a><br/></td></tr>
<tr class="separator:a0bf98f466ea315052a1cb926961c2e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f132f99c5e9e67e699abb62d135739"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a40f132f99c5e9e67e699abb62d135739">rejectConnection</a> (void)</td></tr>
<tr class="memdesc:a40f132f99c5e9e67e699abb62d135739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject connections from the device on the parent/master device.  <a href="#a40f132f99c5e9e67e699abb62d135739"></a><br/></td></tr>
<tr class="separator:a40f132f99c5e9e67e699abb62d135739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f18679b251353c73efd5e6455bd002"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a82f18679b251353c73efd5e6455bd002">wirelessPriority</a> (void) const </td></tr>
<tr class="memdesc:a82f18679b251353c73efd5e6455bd002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wireless priority of the device.  <a href="#a82f18679b251353c73efd5e6455bd002"></a><br/></td></tr>
<tr class="separator:a82f18679b251353c73efd5e6455bd002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1664dc8053156b76530fa5070a8dbe59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1664dc8053156b76530fa5070a8dbe59">setWirelessPriority</a> (int priority)</td></tr>
<tr class="memdesc:a1664dc8053156b76530fa5070a8dbe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wireless priority of the device.  <a href="#a1664dc8053156b76530fa5070a8dbe59"></a><br/></td></tr>
<tr class="separator:a1664dc8053156b76530fa5070a8dbe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729def5c76bfd153ae0761014f2588d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a729def5c76bfd153ae0761014f2588d0">rejectReason</a> (void) const </td></tr>
<tr class="memdesc:a729def5c76bfd153ae0761014f2588d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason why a device's connection was rejected.  <a href="#a729def5c76bfd153ae0761014f2588d0"></a><br/></td></tr>
<tr class="separator:a729def5c76bfd153ae0761014f2588d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cc7e5d0cdab1740edc9aeb5f724774"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae2cc7e5d0cdab1740edc9aeb5f724774">requestBatteryLevel</a> (void)</td></tr>
<tr class="memdesc:ae2cc7e5d0cdab1740edc9aeb5f724774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the battery level from the device.  <a href="#ae2cc7e5d0cdab1740edc9aeb5f724774"></a><br/></td></tr>
<tr class="separator:ae2cc7e5d0cdab1740edc9aeb5f724774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6644f24f131274421aaea9d0fc0c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4dd6644f24f131274421aaea9d0fc0c3">setTransportMode</a> (bool transportModeEnabled)</td></tr>
<tr class="memdesc:a4dd6644f24f131274421aaea9d0fc0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the transport mode for the device.  <a href="#a4dd6644f24f131274421aaea9d0fc0c3"></a><br/></td></tr>
<tr class="separator:a4dd6644f24f131274421aaea9d0fc0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ef88c8926351b40355758f9dc681b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae9ef88c8926351b40355758f9dc681b7">transportMode</a> (void)</td></tr>
<tr class="memdesc:ae9ef88c8926351b40355758f9dc681b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the transport mode feature.  <a href="#ae9ef88c8926351b40355758f9dc681b7"></a><br/></td></tr>
<tr class="separator:ae9ef88c8926351b40355758f9dc681b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1689ca3bd26c9c104504cf65a57375a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa1689ca3bd26c9c104504cf65a57375a">lastKnownRssi</a> (void) const </td></tr>
<tr class="memdesc:aa1689ca3bd26c9c104504cf65a57375a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last known RSSI value of the device.  <a href="#aa1689ca3bd26c9c104504cf65a57375a"></a><br/></td></tr>
<tr class="separator:aa1689ca3bd26c9c104504cf65a57375a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1db7aa59f179672f34b3026941053ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab1db7aa59f179672f34b3026941053ff">isBlueToothEnabled</a> (void) const </td></tr>
<tr class="memdesc:ab1db7aa59f179672f34b3026941053ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device has its BlueTooth radio enabled (Xbus Master only)  <a href="#ab1db7aa59f179672f34b3026941053ff"></a><br/></td></tr>
<tr class="separator:ab1db7aa59f179672f34b3026941053ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae951952646d9e109e6f04b1b90b9bdee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae951952646d9e109e6f04b1b90b9bdee">setBlueToothEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:ae951952646d9e109e6f04b1b90b9bdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the BlueTooth radio of the device (Xbus Master only)  <a href="#ae951952646d9e109e6f04b1b90b9bdee"></a><br/></td></tr>
<tr class="separator:ae951952646d9e109e6f04b1b90b9bdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab576743221b08c8e04f802e5fad8feaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab576743221b08c8e04f802e5fad8feaf">isDualOutputEnabled</a> (void) const </td></tr>
<tr class="memdesc:ab576743221b08c8e04f802e5fad8feaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is sending output over its BlueTooth radio and over the serial connection (Xbus Master only)  <a href="#ab576743221b08c8e04f802e5fad8feaf"></a><br/></td></tr>
<tr class="separator:ab576743221b08c8e04f802e5fad8feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe553d06248b87484637c090e0541108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afe553d06248b87484637c090e0541108">setDualOutputEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:afe553d06248b87484637c090e0541108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the BlueTooth radio of the device (Xbus Master only)  <a href="#afe553d06248b87484637c090e0541108"></a><br/></td></tr>
<tr class="separator:afe553d06248b87484637c090e0541108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e63c9d1fdd942c39a2194e9ec56334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab4e63c9d1fdd942c39a2194e9ec56334">isBusPowerEnabled</a> (void) const </td></tr>
<tr class="memdesc:ab4e63c9d1fdd942c39a2194e9ec56334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Xbus Master is powering its child devices or not.  <a href="#ab4e63c9d1fdd942c39a2194e9ec56334"></a><br/></td></tr>
<tr class="separator:ab4e63c9d1fdd942c39a2194e9ec56334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45461d069fe6ab4315f3880eeffc6819"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a45461d069fe6ab4315f3880eeffc6819">setBusPowerEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a45461d069fe6ab4315f3880eeffc6819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the Xbus Master to provide power to its child devices or not.  <a href="#a45461d069fe6ab4315f3880eeffc6819"></a><br/></td></tr>
<tr class="separator:a45461d069fe6ab4315f3880eeffc6819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e996cee01ae20630171ad7316e15384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2e996cee01ae20630171ad7316e15384">powerDown</a> (void)</td></tr>
<tr class="memdesc:a2e996cee01ae20630171ad7316e15384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the device to power down completely (Xbus Master only)  <a href="#a2e996cee01ae20630171ad7316e15384"></a><br/></td></tr>
<tr class="separator:a2e996cee01ae20630171ad7316e15384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c6e0f5be723782b0ae6440be696ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a57c6e0f5be723782b0ae6440be696ea9">errorMode</a> (void) const </td></tr>
<tr class="memdesc:a57c6e0f5be723782b0ae6440be696ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error mode of the device (Xbus Master only)  <a href="#a57c6e0f5be723782b0ae6440be696ea9"></a><br/></td></tr>
<tr class="separator:a57c6e0f5be723782b0ae6440be696ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de11adb871b12fc84c3a37ae3b83e6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0de11adb871b12fc84c3a37ae3b83e6d">setErrorMode</a> (<a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> errormode)</td></tr>
<tr class="memdesc:a0de11adb871b12fc84c3a37ae3b83e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error mode of the device (Xbus Master only)  <a href="#a0de11adb871b12fc84c3a37ae3b83e6d"></a><br/></td></tr>
<tr class="separator:a0de11adb871b12fc84c3a37ae3b83e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04058dd4f3e6f48af73e54d8bf6c77c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1">setHeadingOffset</a> (double offset)</td></tr>
<tr class="memdesc:a04058dd4f3e6f48af73e54d8bf6c77c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'heading offset' setting of the device.  <a href="#a04058dd4f3e6f48af73e54d8bf6c77c1"></a><br/></td></tr>
<tr class="separator:a04058dd4f3e6f48af73e54d8bf6c77c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcce3002fee1759260ea024318ef9730"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730">headingOffset</a> (void) const </td></tr>
<tr class="memdesc:abcce3002fee1759260ea024318ef9730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 'heading offset' setting of the device.  <a href="#abcce3002fee1759260ea024318ef9730"></a><br/></td></tr>
<tr class="separator:abcce3002fee1759260ea024318ef9730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a46ea2a77ab9a0a392ebf7b21ebd46d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4a46ea2a77ab9a0a392ebf7b21ebd46d">setLocationId</a> (int id)</td></tr>
<tr class="memdesc:a4a46ea2a77ab9a0a392ebf7b21ebd46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location ID of the device.  <a href="#a4a46ea2a77ab9a0a392ebf7b21ebd46d"></a><br/></td></tr>
<tr class="separator:a4a46ea2a77ab9a0a392ebf7b21ebd46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd80807c1e9d0dcf3fd4b0481ef3de2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6cd80807c1e9d0dcf3fd4b0481ef3de2">locationId</a> (void) const </td></tr>
<tr class="memdesc:a6cd80807c1e9d0dcf3fd4b0481ef3de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location ID of the device.  <a href="#a6cd80807c1e9d0dcf3fd4b0481ef3de2"></a><br/></td></tr>
<tr class="separator:a6cd80807c1e9d0dcf3fd4b0481ef3de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82640a51951f119f5947bc81953cf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa82640a51951f119f5947bc81953cf4d">objectAlignment</a> (void) const </td></tr>
<tr class="memdesc:aa82640a51951f119f5947bc81953cf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object alignment matrix of the device.  <a href="#aa82640a51951f119f5947bc81953cf4d"></a><br/></td></tr>
<tr class="separator:aa82640a51951f119f5947bc81953cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae523c9b1a429357ffabc7927a51cc7e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae523c9b1a429357ffabc7927a51cc7e3">setObjectAlignment</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:ae523c9b1a429357ffabc7927a51cc7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the object alignment of the device to the given <em>matrix</em>.  <a href="#ae523c9b1a429357ffabc7927a51cc7e3"></a><br/></td></tr>
<tr class="separator:ae523c9b1a429357ffabc7927a51cc7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482ee44a2d1915c8fa6c4c5f60f37aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab">labMagneticField</a> (void) const </td></tr>
<tr class="memdesc:a482ee44a2d1915c8fa6c4c5f60f37aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'Lab Magnetic Field' of the device.  <a href="#a482ee44a2d1915c8fa6c4c5f60f37aab"></a><br/></td></tr>
<tr class="separator:a482ee44a2d1915c8fa6c4c5f60f37aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9a445b82dfb0cc5b3dce96722cc289"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6a9a445b82dfb0cc5b3dce96722cc289">setLabMagneticField</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;magfield)</td></tr>
<tr class="memdesc:a6a9a445b82dfb0cc5b3dce96722cc289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Lab Magnetic Field' of the device to the given <em>vector</em>.  <a href="#a6a9a445b82dfb0cc5b3dce96722cc289"></a><br/></td></tr>
<tr class="separator:a6a9a445b82dfb0cc5b3dce96722cc289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2edf0c9d7e1d8e2b53c02f7ebd0b624"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624">gravityMagnitude</a> (void) const </td></tr>
<tr class="memdesc:ab2edf0c9d7e1d8e2b53c02f7ebd0b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'Gravity Magnitude' of the device.  <a href="#ab2edf0c9d7e1d8e2b53c02f7ebd0b624"></a><br/></td></tr>
<tr class="separator:ab2edf0c9d7e1d8e2b53c02f7ebd0b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f6730561da7c7b54fe591f1209314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae75f6730561da7c7b54fe591f1209314">setGravityMagnitude</a> (double mag)</td></tr>
<tr class="memdesc:ae75f6730561da7c7b54fe591f1209314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>.  <a href="#ae75f6730561da7c7b54fe591f1209314"></a><br/></td></tr>
<tr class="separator:ae75f6730561da7c7b54fe591f1209314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f056042ffb956c48ed6717b24ec28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28">latLonAlt</a> (void) const </td></tr>
<tr class="memdesc:a6e4f056042ffb956c48ed6717b24ec28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'Latitude Longitude Altitude' setting of the device.  <a href="#a6e4f056042ffb956c48ed6717b24ec28"></a><br/></td></tr>
<tr class="separator:a6e4f056042ffb956c48ed6717b24ec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3b2eb82952163acc7db94deeebbf7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a">setLatLonAlt</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;lla)</td></tr>
<tr class="memdesc:a1e3b2eb82952163acc7db94deeebbf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>.  <a href="#a1e3b2eb82952163acc7db94deeebbf7a"></a><br/></td></tr>
<tr class="separator:a1e3b2eb82952163acc7db94deeebbf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b5be213bda85dbdae39cdfa944b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a760b5be213bda85dbdae39cdfa944b6b">reinitialize</a> (void)</td></tr>
<tr class="memdesc:a760b5be213bda85dbdae39cdfa944b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>.  <a href="#a760b5be213bda85dbdae39cdfa944b6b"></a><br/></td></tr>
<tr class="separator:a760b5be213bda85dbdae39cdfa944b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bf6c8506ba64416548de5ab5db0716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716">xdaFilterProfile</a> (void) const </td></tr>
<tr class="memdesc:a18bf6c8506ba64416548de5ab5db0716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use for computing orientations on the host PC.  <a href="#a18bf6c8506ba64416548de5ab5db0716"></a><br/></td></tr>
<tr class="separator:a18bf6c8506ba64416548de5ab5db0716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba7e1380aabd196f77809a56a26ce3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c">setXdaFilterProfile</a> (int profileType)</td></tr>
<tr class="memdesc:a9ba7e1380aabd196f77809a56a26ce3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the host PC.  <a href="#a9ba7e1380aabd196f77809a56a26ce3c"></a><br/></td></tr>
<tr class="separator:a9ba7e1380aabd196f77809a56a26ce3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f18e73cb0d73a5b0994690c478b079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079">onboardFilterProfile</a> (void) const </td></tr>
<tr class="memdesc:a40f18e73cb0d73a5b0994690c478b079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use by the device for computing orientations.  <a href="#a40f18e73cb0d73a5b0994690c478b079"></a><br/></td></tr>
<tr class="separator:a40f18e73cb0d73a5b0994690c478b079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac315cf6332ea92920b06e7d30b47f028"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028">setOnboardFilterProfile</a> (int profileType)</td></tr>
<tr class="memdesc:ac315cf6332ea92920b06e7d30b47f028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the device.  <a href="#ac315cf6332ea92920b06e7d30b47f028"></a><br/></td></tr>
<tr class="separator:ac315cf6332ea92920b06e7d30b47f028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985cb493b55e4336137e99d804fd3556"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a985cb493b55e4336137e99d804fd3556">replaceFilterProfile</a> (const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;profileCurrent, const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;profileNew)</td></tr>
<tr class="memdesc:a985cb493b55e4336137e99d804fd3556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces profileCurrent by profileNew in the device.  <a href="#a985cb493b55e4336137e99d804fd3556"></a><br/></td></tr>
<tr class="separator:a985cb493b55e4336137e99d804fd3556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3869ecd19fa3eecac439f790f043d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d">availableOnboardFilterProfiles</a> (void) const </td></tr>
<tr class="memdesc:a25b3869ecd19fa3eecac439f790f043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the device.  <a href="#a25b3869ecd19fa3eecac439f790f043d"></a><br/></td></tr>
<tr class="separator:a25b3869ecd19fa3eecac439f790f043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a13f22e39ec655c58aec317206fcce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce">availableXdaFilterProfiles</a> (void) const </td></tr>
<tr class="memdesc:aa6a13f22e39ec655c58aec317206fcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the host PC.  <a href="#aa6a13f22e39ec655c58aec317206fcce"></a><br/></td></tr>
<tr class="separator:aa6a13f22e39ec655c58aec317206fcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbeb1684b594d94b3abcb5b55f0f335"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8fbeb1684b594d94b3abcb5b55f0f335">accelerometerRange</a> (void) const </td></tr>
<tr class="memdesc:a8fbeb1684b594d94b3abcb5b55f0f335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the accelerometers in the device.  <a href="#a8fbeb1684b594d94b3abcb5b55f0f335"></a><br/></td></tr>
<tr class="separator:a8fbeb1684b594d94b3abcb5b55f0f335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb71371914a61505fb133895000937"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a26eb71371914a61505fb133895000937">gyroscopeRange</a> (void) const </td></tr>
<tr class="memdesc:a26eb71371914a61505fb133895000937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the gyroscopes in the device.  <a href="#a26eb71371914a61505fb133895000937"></a><br/></td></tr>
<tr class="separator:a26eb71371914a61505fb133895000937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6ebbd9e51082930fdd5abcc6879a34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5a6ebbd9e51082930fdd5abcc6879a34">setNoRotation</a> (uint16_t duration)</td></tr>
<tr class="memdesc:a5a6ebbd9e51082930fdd5abcc6879a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the no rotation period to <em>duration</em>.  <a href="#a5a6ebbd9e51082930fdd5abcc6879a34"></a><br/></td></tr>
<tr class="separator:a5a6ebbd9e51082930fdd5abcc6879a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab593a883c91d00fa56cccf9dd0c2eb12"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab593a883c91d00fa56cccf9dd0c2eb12">rs485TransmissionDelay</a> (void) const </td></tr>
<tr class="memdesc:ab593a883c91d00fa56cccf9dd0c2eb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transmission delay used for RS485 transmissions.  <a href="#ab593a883c91d00fa56cccf9dd0c2eb12"></a><br/></td></tr>
<tr class="separator:ab593a883c91d00fa56cccf9dd0c2eb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46dc569444542b62bfb6402e9183865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa46dc569444542b62bfb6402e9183865">setRs485TransmissionDelay</a> (uint16_t delay)</td></tr>
<tr class="memdesc:aa46dc569444542b62bfb6402e9183865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transmission delay used for RS485 transmissions.  <a href="#aa46dc569444542b62bfb6402e9183865"></a><br/></td></tr>
<tr class="separator:aa46dc569444542b62bfb6402e9183865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade80265d5f3e15337a96465d88c68e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ade80265d5f3e15337a96465d88c68e4a">runSelfTest</a> (void)</td></tr>
<tr class="memdesc:ade80265d5f3e15337a96465d88c68e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the self test for the device.  <a href="#ade80265d5f3e15337a96465d88c68e4a"></a><br/></td></tr>
<tr class="separator:ade80265d5f3e15337a96465d88c68e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e591d4cef4cb3f4d02f73c2f587f210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6e591d4cef4cb3f4d02f73c2f587f210">requestData</a> (void)</td></tr>
<tr class="memdesc:a6e591d4cef4cb3f4d02f73c2f587f210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request data when configured in legacy mode with infinite skip factor.  <a href="#a6e591d4cef4cb3f4d02f73c2f587f210"></a><br/></td></tr>
<tr class="separator:a6e591d4cef4cb3f4d02f73c2f587f210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d00abeeea6064e990195233d5ce8eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad5d00abeeea6064e990195233d5ce8eb">storeFilterState</a> (void)</td></tr>
<tr class="memdesc:ad5d00abeeea6064e990195233d5ce8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store orientation filter state in the device.  <a href="#ad5d00abeeea6064e990195233d5ce8eb"></a><br/></td></tr>
<tr class="separator:ad5d00abeeea6064e990195233d5ce8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782d2d345c99aa2039fdc3298ae994a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a782d2d345c99aa2039fdc3298ae994a7">isInitialBiasUpdateEnabled</a> (void) const </td></tr>
<tr class="memdesc:a782d2d345c99aa2039fdc3298ae994a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device does gyroscope bias estimation when switching to measurement mode.  <a href="#a782d2d345c99aa2039fdc3298ae994a7"></a><br/></td></tr>
<tr class="separator:a782d2d345c99aa2039fdc3298ae994a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bdd87c62c9fdea175acaf98e5d0e49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a38bdd87c62c9fdea175acaf98e5d0e49">setInitialBiasUpdateEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a38bdd87c62c9fdea175acaf98e5d0e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if the device does gyroscope bias estimation when switching to measurement mode.  <a href="#a38bdd87c62c9fdea175acaf98e5d0e49"></a><br/></td></tr>
<tr class="separator:a38bdd87c62c9fdea175acaf98e5d0e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dcf8b4f2aad25e547a44a4858d4a23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac9dcf8b4f2aad25e547a44a4858d4a23">isFixedGravityEnabled</a> (void) const </td></tr>
<tr class="memdesc:ac9dcf8b4f2aad25e547a44a4858d4a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the fixed gravity value should be used or if it should be computed from the LatLonAlt value.  <a href="#ac9dcf8b4f2aad25e547a44a4858d4a23"></a><br/></td></tr>
<tr class="separator:ac9dcf8b4f2aad25e547a44a4858d4a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a317dc6368a72e2a5bcb8c46c3f3e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a33a317dc6368a72e2a5bcb8c46c3f3e5">setFixedGravityEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a33a317dc6368a72e2a5bcb8c46c3f3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the fixed gravity value should be used or if it should be computed from the LatLonAlt value.  <a href="#a33a317dc6368a72e2a5bcb8c46c3f3e5"></a><br/></td></tr>
<tr class="separator:a33a317dc6368a72e2a5bcb8c46c3f3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f79cb71f2f65cc578133421a59f6691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9f79cb71f2f65cc578133421a59f6691">createConfigFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a9f79cb71f2f65cc578133421a59f6691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the current device configuration in a config file(.xsa)  <a href="#a9f79cb71f2f65cc578133421a59f6691"></a><br/></td></tr>
<tr class="separator:a9f79cb71f2f65cc578133421a59f6691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d89cecea51d7980afe9443cccf5897b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7d89cecea51d7980afe9443cccf5897b">applyConfigFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a7d89cecea51d7980afe9443cccf5897b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a config file(.xsa) and configures the device accordingly.  <a href="#a7d89cecea51d7980afe9443cccf5897b"></a><br/></td></tr>
<tr class="separator:a7d89cecea51d7980afe9443cccf5897b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db27fb6afef01dd3d3e2c72e67613f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2">setAlignmentRotationMatrix</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:a1db27fb6afef01dd3d3e2c72e67613f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the chosen frame S  <a href="#a1db27fb6afef01dd3d3e2c72e67613f2"></a><br/></td></tr>
<tr class="separator:a1db27fb6afef01dd3d3e2c72e67613f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ededbf2aad434c030f258e90799add4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4">alignmentRotationMatrix</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame) const </td></tr>
<tr class="memdesc:a5ededbf2aad434c030f258e90799add4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation matrix to rotate S to the chosen frame S  <a href="#a5ededbf2aad434c030f258e90799add4"></a><br/></td></tr>
<tr class="separator:a5ededbf2aad434c030f258e90799add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddd92e26153da568a828525aa9026be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be">setAlignmentRotationQuaternion</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> &amp;quat)</td></tr>
<tr class="memdesc:aaddd92e26153da568a828525aa9026be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to the chosen frame S  <a href="#aaddd92e26153da568a828525aa9026be"></a><br/></td></tr>
<tr class="separator:aaddd92e26153da568a828525aa9026be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aba825d963ea3042e8ed7a28619307"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307">alignmentRotationQuaternion</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame) const </td></tr>
<tr class="memdesc:af1aba825d963ea3042e8ed7a28619307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation quaternion.  <a href="#af1aba825d963ea3042e8ed7a28619307"></a><br/></td></tr>
<tr class="separator:af1aba825d963ea3042e8ed7a28619307"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad05ec8323a049bc4203d3b6b8ce77825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad05ec8323a049bc4203d3b6b8ce77825"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad05ec8323a049bc4203d3b6b8ce77825">XsDevice</a> ()</td></tr>
<tr class="memdesc:ad05ec8323a049bc4203d3b6b8ce77825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor not implemented to prevent faulty memory allocation, use construct() function instead. <br/></td></tr>
<tr class="separator:ad05ec8323a049bc4203d3b6b8ce77825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273ade1ba9ce3b6aa3b8894d599ebd36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a273ade1ba9ce3b6aa3b8894d599ebd36">~XsDevice</a> ()</td></tr>
<tr class="memdesc:a273ade1ba9ce3b6aa3b8894d599ebd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor not implemented, use destruct() function instead.  <a href="#a273ade1ba9ce3b6aa3b8894d599ebd36"></a><br/></td></tr>
<tr class="separator:a273ade1ba9ce3b6aa3b8894d599ebd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3510c79938c8dd9e8548c6417147c644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3510c79938c8dd9e8548c6417147c644"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3510c79938c8dd9e8548c6417147c644">operator new</a> (size_t)</td></tr>
<tr class="memdesc:a3510c79938c8dd9e8548c6417147c644"><td class="mdescLeft">&#160;</td><td class="mdescRight">new operator not implemented to prevent faulty memory allocation by user, use construct() function instead <br/></td></tr>
<tr class="separator:a3510c79938c8dd9e8548c6417147c644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b814436dbe1c25776e9b343c9519b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b814436dbe1c25776e9b343c9519b4"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a24b814436dbe1c25776e9b343c9519b4">operator new[]</a> (size_t)</td></tr>
<tr class="memdesc:a24b814436dbe1c25776e9b343c9519b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">array new operator not implemented to prevent faulty memory allocation by user, use construct() function instead <br/></td></tr>
<tr class="separator:a24b814436dbe1c25776e9b343c9519b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2748b6e13602339d5cbcd382afd8252e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2748b6e13602339d5cbcd382afd8252e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2748b6e13602339d5cbcd382afd8252e">operator delete</a> (void *)</td></tr>
<tr class="memdesc:a2748b6e13602339d5cbcd382afd8252e"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete operator not implemented to prevent faulty memory deallocation by user, use destruct() function instead <br/></td></tr>
<tr class="separator:a2748b6e13602339d5cbcd382afd8252e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568a74ce8629296b377716e89bc22a89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568a74ce8629296b377716e89bc22a89"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a568a74ce8629296b377716e89bc22a89">operator delete[]</a> (void *)</td></tr>
<tr class="memdesc:a568a74ce8629296b377716e89bc22a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">array delete operator not implemented to prevent faulty memory deallocation by user, use destruct() function instead <br/></td></tr>
<tr class="separator:a568a74ce8629296b377716e89bc22a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A pointer to an <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a273ade1ba9ce3b6aa3b8894d599ebd36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevice::~XsDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor not implemented, use destruct() function instead. </p>
<p>Destroy the device. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a14c7b3f9663a3407ff1953937a56d5dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::abortFlushing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort the wireless flushing operation and finalize the recording. </p>
<dl class="section return"><dt>Returns</dt><dd>true if no flushing is in progress when the function exits </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a46902bfacdd9f993daa935399bacc781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::abortLoadLogFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts loading a logfile. </p>
<dl class="section return"><dt>Returns</dt><dd>true if loading is aborted successfully </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if no file was currently loading returns false </dd></dl>

</div>
</div>
<a class="anchor" id="a8fbeb1684b594d94b3abcb5b55f0f335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice::accelerometerRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum official value of the accelerometers in the device. </p>
<p>The actual official range is -accelerometerRange() .. <a class="el" href="struct_xs_device.html#a8fbeb1684b594d94b3abcb5b55f0f335" title="Returns the maximum official value of the accelerometers in the device.">accelerometerRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of the accelerometers in m/s^2 </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf98f466ea315052a1cb926961c2e8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::acceptConnection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept connections from the device on the parent/master device. </p>
<p>This function can be used to accept connections from a device that has been rejected. Call this function from within the onConnectivityChanged callback. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device will be accepted next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw rejected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a43e4d381affb5286f57b25256dbf88c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevice::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ededbf2aad434c030f258e90799add4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> XsDevice::alignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation matrix to rotate S to the chosen frame S </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to ...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307" title="Retrieve the alignment rotation quaternion.">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the c...">setAlignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1aba825d963ea3042e8ed7a28619307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> XsDevice::alignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to ...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the c...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d89cecea51d7980afe9443cccf5897b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevice::applyConfigFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a config file(.xsa) and configures the device accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a25b3869ecd19fa3eecac439f790f043d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &gt; XsDevice::availableOnboardFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce" title="Return the list of filter profiles available on the host PC.">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079" title="Gets the filter profile in use by the device for computing orientations.">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028" title="Sets the filter profile to use for computing orientations on the device.">setOnboardFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa6a13f22e39ec655c58aec317206fcce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &gt; XsDevice::availableXdaFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the host PC. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the host PC </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d" title="Return the list of filter profiles available on the device.">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716" title="Gets the filter profile in use for computing orientations on the host PC.">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c" title="Sets the filter profile to use for computing orientations on the host PC.">setXdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a5dd4a13161a69e4927191a7295cd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::batteryLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication. </p>
<p>XbusMaster: The amount of time remaining for measurement given any battery level greatly depends on the type of batteries used, the number of sensors attached to the Xbus Master and the used output options. Mtw: The last known battery level for this motion tracker. First call </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae2cc7e5d0cdab1740edc9aeb5f724774" title="Request the battery level from the device.">requestBatteryLevel</a> to have a battery level available. The callback </dd>
<dd>
onInfoResponse with ID XIR_BatteryLevel will indicate when the requested battery level is available. This function is available in both config and measurement mode. For devices in wired mode this function can be called without calling </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae2cc7e5d0cdab1740edc9aeb5f724774" title="Request the battery level from the device.">requestBatteryLevel</a> first </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The battery level in the range 0-100 </dd></dl>

</div>
</div>
<a class="anchor" id="a613cd4d200015a0e457c29ddcb689152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate XsDevice::baudRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected. </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#a6c7748ffd37793917d6ce13e464cf2c9" title="The baud rate configured for cabled connection.">serialBaudRate()</a> function in that it will only return the baud rate of the current connection, whereas the <a class="el" href="struct_xs_device.html#a6c7748ffd37793917d6ce13e464cf2c9" title="The baud rate configured for cabled connection.">serialBaudRate()</a> function will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly). </p>
<dl class="section return"><dt>Returns</dt><dd>The baud rate of the serial connection or XBR_Invalid </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b19466b66032e3e319375b40c08b30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::busId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bus ID for this device. </p>
<dl class="section return"><dt>Returns</dt><dd>The bus ID of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a074354d99b32555a3895bdb5636df671"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device.html">XsDevice</a> * &gt; XsDevice::children </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the child devices of this device. </p>
<dl class="section return"><dt>Returns</dt><dd>The child devices of this device </dd></dl>

</div>
</div>
<a class="anchor" id="afd94fa30eac6af10e5d4c5cc2374ae73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevice::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all child devices as well (true, default) or just the callback handlers of this XsDevice object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a672a0f86279cde90b7f4441410f272cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::closeLogFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the log file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>

</div>
</div>
<a class="anchor" id="a4c4b495e36200adb8602af9374a18972"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> XsDevice::connectivityState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connectivity state of the device. </p>
<p>The connectivity describes how and if the device is connected to XDA. </p>
<dl class="section return"><dt>Returns</dt><dd>The current connectivity of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c" title="XsDevice connectivity state identifiers.">XsConnectivityState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f79cb71f2f65cc578133421a59f6691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevice::createConfigFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the current device configuration in a config file(.xsa) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a104b615636d419a3e0c3dfa07f1d0185"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevice::createLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a log file for logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The desired path and filename of the log file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8612480d5b3eead853413bb37544b5a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::dataLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the data in the legacy MTData packets that the device will send in measurement mode. </p>
<p>This function will only return a value when the device is configured for legacy output, otherwise it will return 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The data size of the MTData packets that will be sent by the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207" title="Sets the legacy output configuration of the device.">setDeviceMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd" title="Returns the legacy output configuration as an XsDeviceMode object.">deviceMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0149482e881275a42cb00bf62f2822ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevice::dataPacketById </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>packetId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a data packet for the device with the supplied <em>packetId</em>. </p>
<p>This function retrieves the packet with id <em>packetId</em>. Packet IDs are increasing numbers, but they are not always continuous. They are assigned to a packet by XDA based on the availability of time stamps and counters in the data.</p>
<p>XDA will use (in this order if they are available): packet counter, sample time, order of arrival of messages. Counters that wrap around at some point are automatically extended to a 64-bit packet ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetId</td><td>The specific packet ID to retrieve data for. If a 0 is supplied, the first available item is returned to provide a start-point for further dataPacketById calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packet with the supplied <em>packetId</em> or an empty XsDataPacket if no packet exists with the requested <em>packetId</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>lastResult() </dd>
<dd>
<a class="el" href="struct_xs_device.html#a0a2ab8100043d0622459b73ba134f8f9" title="Retrieve the index&#39;th data packet for the device.">dataPacketByIndex</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a2ab8100043d0622459b73ba134f8f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevice::dataPacketByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the <em>index'th</em> data packet for the device. </p>
<p>The function returns item <em>index</em> from the cache, simply counting from 0 onward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The offset of the sample to retrieve, 0-based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packet at the supplied index or an empty XsDataPacket if <em>index</em> is too high </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>lastResult() </dd>
<dd>
<a class="el" href="struct_xs_device.html#a0149482e881275a42cb00bf62f2822ff" title="Retrieve a data packet for the device with the supplied packetId.">dataPacketById</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86249a6c447576a8a58a7adff51af0a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevice::deviceAtBusId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The const <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aa30ab92581227c3a2b4fe2187f9d761a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevice::deviceAtBusId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a150dd0d4d207678d991a67d7c9d8a8ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> &amp; XsDevice::deviceConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device configuration. </p>
<p>The device configuration contains a summary of the devices connected to the same port. The function will always return the configuration for the port's main device. </p>
<dl class="section return"><dt>Returns</dt><dd>The device configuration of the port </dd></dl>

</div>
</div>
<a class="anchor" id="a790a9f814ac94d1e71452661c943d521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsDevice::deviceId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device ID of the device. </p>
<p>Each Xsens device has a unique ID. The ID identifies the device as well as the product family it belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>The device ID </dd></dl>

</div>
</div>
<a class="anchor" id="a530efa668ba72fc4fc693c56676b71fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> XsDevice::deviceMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the legacy output configuration as an XsDeviceMode object. </p>
<p>This function can be used to retrieve the full output configuration of a device in legacy mode. When the device is not in legacy mode, the returned object will indicate that no data will be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>The legacy output configuration of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207" title="Sets the legacy output configuration of the device.">setDeviceMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adf406f28a693c3bed6e717c39f397573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> XsDevice::deviceState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the state of this device. </p>
<p>The device state indiciates whether the device is in config mode, measuring, recording, etc </p>
<dl class="section return"><dt>Returns</dt><dd>The state of the device </dd></dl>

</div>
</div>
<a class="anchor" id="adb1bb5ae93a04f0067456fd3cd866f54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::disableProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#ab8e5368ad9948b79ff0d45ec5068b9c6" title="Enable an additional communication protocol when reading messages.">XsDevice::enableProtocol</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the removal was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>

</div>
</div>
<a class="anchor" id="ac3614a08ca0e3d2df2f72aa9632189f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::disableRadio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the radio for this station, resetting all children to disconnected state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="af46c1ca0b7962af4334aa765bfb5155a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::droppedPacketCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of packets dropped by the port. </p>
<p>This value can only be detected when the device is configured to have a packet counter or a sample range. It indicates the number of packets that were never received. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of dropped packets so far. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6b2b7ef873a12e425901544c7349092b" title="Reset the dropped packet count.">resetDroppedPacketCount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e5368ad9948b79ff0d45ec5068b9c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::enableProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable an additional communication protocol when reading messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the addition was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>

</div>
</div>
<a class="anchor" id="a451ae32410afc778ef81fa3e3c7a9fe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::enableRadio </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the radio channel to use for wireless communication. </p>
<p>This function can be used to enable or disable the radio of an Awinda Station. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A valid channel number in the range [11..25] or -1 to disable the radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully reconfigured </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a57c6e0f5be723782b0ae6440be696ea9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> XsDevice::errorMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error mode of the device (Xbus Master only) </p>
<p>The error mode tells the device what to do if a problem occurs. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured error mode of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a0de11adb871b12fc84c3a37ae3b83e6d" title="Sets the error mode of the device (Xbus Master only)">setErrorMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52255d690521d7d92cd4d78aee9bf8d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevice::findDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the child device with <em>deviceid</em>. </p>
<p>This function returns the child device of the current device that matches the given ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceid</td><td>The device ID to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found XsDevice or 0 if the device could not be found </dd></dl>

</div>
</div>
<a class="anchor" id="aa132b107f231867f70efbf2044817529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsDevice::firmwareVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the firmware version. </p>
<dl class="section return"><dt>Returns</dt><dd>The firmware version of the live device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The firmware version is not stored in mtb files, so when reading from file this function will return an empty XsVersion object </dd></dl>

</div>
</div>
<a class="anchor" id="ae96da6f3434f509e20b46dec2e81f5ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice::flushInputBuffers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the inbound data buffers of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">complete</td><td>When false, only the processed data queue is cleared. When true, the unprocessed data queue is also cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2b32660f266c44ba18323d1a26b6b7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::gotoConfig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the device in config mode. </p>
<p>Device settings can only be changed in config mode, since changing anything during measurement would mess up the sample timing. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in config mode or was already in config mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a4539825a286248b59c66bd89cf7c1090" title="Put this device in measurement mode.">gotoMeasurement</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4539825a286248b59c66bd89cf7c1090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::gotoMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put this device in measurement mode. </p>
<p>Measurement mode is where the device is sampling data and producing inertial and orientation output. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in measurement mode or was already in measurement mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab2b32660f266c44ba18323d1a26b6b7e" title="Put the device in config mode.">gotoConfig</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2edf0c9d7e1d8e2b53c02f7ebd0b624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice::gravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 'Gravity Magnitude' of the device. </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'Gravity Magnitude' setting of the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae75f6730561da7c7b54fe591f1209314" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag.">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26eb71371914a61505fb133895000937"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice::gyroscopeRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum official value of the gyroscopes in the device. </p>
<p>The actual official range is -gyroscopeRange() .. <a class="el" href="struct_xs_device.html#a26eb71371914a61505fb133895000937" title="Returns the maximum official value of the gyroscopes in the device.">gyroscopeRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of the gyroscopes in degrees/s </dd></dl>

</div>
</div>
<a class="anchor" id="aa282f42a414355218001f4471079a48a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsDevice::hardwareVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hardware version of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The hardware version of the device </dd></dl>

</div>
</div>
<a class="anchor" id="aa32dc53bf86ce26b9671d9c4180ecb3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::hasDataEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac67109aa78da4effcd63ef007810f6e7" title="Returns if the currently configured output contains dataType after processing on the host...">hasProcessedDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0" title="Returns the currently configured update rate for the supplied dataType.">updateRateForDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac67109aa78da4effcd63ef007810f6e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::hasProcessedDataEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em> after processing on the host. </p>
<p>Where <a class="el" href="struct_xs_device.html#aa32dc53bf86ce26b9671d9c4180ecb3b" title="Returns if the currently configured output contains dataType.">hasDataEnabled()</a> only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa32dc53bf86ce26b9671d9c4180ecb3b" title="Returns if the currently configured output contains dataType.">hasDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ad0c9de7bd8ac2786cd7d1d3cd3f46878" title="Return the full output configuration including post processing outputs.">processedOutputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0" title="Returns the currently configured update rate for the supplied dataType.">updateRateForDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abcce3002fee1759260ea024318ef9730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevice::headingOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 'heading offset' setting of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured heading offset in degrees </dd></dl>

</div>
</div>
<a class="anchor" id="ac92bb39794188879d0731c4fd1fb0720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::initializeFilter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the filter used by this device. </p>
<p>This function will restart the filter used on the PC for computing orientations </p>
<dl class="section return"><dt>Returns</dt><dd>true if the filter was successfully (re-)initialized </dd></dl>

</div>
</div>
<a class="anchor" id="ab1db7aa59f179672f34b3026941053ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device has its BlueTooth radio enabled (Xbus Master only) </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has its BlueTooth radio enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae951952646d9e109e6f04b1b90b9bdee" title="Enable or disable the BlueTooth radio of the device (Xbus Master only)">setBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4e63c9d1fdd942c39a2194e9ec56334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the Xbus Master is powering its child devices or not. </p>
<p>When the bus power is off, the child devices are disabled </p>
<dl class="section return"><dt>Returns</dt><dd>true If the Xbus Master is currently providing power to its child devices </dd></dl>

</div>
</div>
<a class="anchor" id="ab576743221b08c8e04f802e5fad8feaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isDualOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is sending output over its BlueTooth radio and over the serial connection (Xbus Master only) </p>
<p>When configured like this, the Xbus Master still only accepts commands on its BlueTooth connection. This is mostly useful when trying to troubleshoot wireless connectivity issues. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is configured for dual output mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#afe553d06248b87484637c090e0541108" title="Enable or disable the BlueTooth radio of the device (Xbus Master only)">setDualOutputEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9dcf8b4f2aad25e547a44a4858d4a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the fixed gravity value should be used or if it should be computed from the LatLonAlt value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a33a317dc6368a72e2a5bcb8c46c3f3e5" title="Sets whether the fixed gravity value should be used or if it should be computed from the LatLonAlt va...">setFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a782d2d345c99aa2039fdc3298ae994a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device does gyroscope bias estimation when switching to measurement mode. </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a5a6ebbd9e51082930fdd5abcc6879a34" title="Set the no rotation period to duration.">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a38bdd87c62c9fdea175acaf98e5d0e49" title="Set if the device does gyroscope bias estimation when switching to measurement mode.">setInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6b4786411e559f54f551d877d938288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isInitialized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when the device is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been initialized </dd></dl>

</div>
</div>
<a class="anchor" id="aa0561ec33a8d9c188b2e22b5ca73880e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isInLegacyMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device is outputting data in legacy mode. </p>
<p>In legacy mode all data is sent as MTData packets at the same update rate and not all Mk4 output types are available. When not in legacy mode, data is sent as MTData2 packets and may arrive at different update rates depending on the type of data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is configured for legacy mode output. </dd></dl>

</div>
</div>
<a class="anchor" id="a94004970e7e9c628dc0007bc8422bffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isInStringOutputMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device is outputting data in string mode. </p>
<p>In string mode only NMEA packets are transmitted at the legacy update rate </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is configured for string mode output. </dd></dl>

</div>
</div>
<a class="anchor" id="aac523a222c2eb7e72864862ef2534e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isInSyncBoxMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when the device is in Sync Box mode (Awinda Station only) </dd></dl>

</div>
</div>
<a class="anchor" id="aaed892421bacfa1791ff389a6b266cb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isMasterDevice </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is the master device (not a child of another device) </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is the master device </dd></dl>

</div>
</div>
<a class="anchor" id="a12626445fb21fa7a5072045bac8046f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isMeasuring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a measuring state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a measuring state </dd></dl>

</div>
</div>
<a class="anchor" id="a4c1d6380fb464aaab3fdbd5dc10e9fcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isMotionTracker </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a motion tracker. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a motion tracker or false if it is a master device such as an Awinda Station or an Xbus Master </dd></dl>

</div>
</div>
<a class="anchor" id="a3fa63b9e9973ab42e6f57a020e03314f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isOperational </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when the device is operational </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>AwindaStationDevice::makeOperational() </dd></dl>

</div>
</div>
<a class="anchor" id="ae0da29c15d3aaf244711c98c48c128e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isOptionEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a processing option is enabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a59f5dfc2bd1168a70d1e7f2335cdb5a8" title="Enable or disable a processing option.">setOptionEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89565c9eb41e44eed36c83eca34b822d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isProtocolEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when a protocol with type <em>type</em> has been added </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>The protocol type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aded40bf432fa254340cb4c5640a0d038"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isRadioEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the radio is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the radio is enabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>

</div>
</div>
<a class="anchor" id="af283c0d414b83b3deda483cbff3b3087"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isReadingFromFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is reading from a file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is reading from a file </dd></dl>

</div>
</div>
<a class="anchor" id="a2746404553d0a7bfa90745b8619db193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a recording state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a recording state </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a3d053b062705db378d774f8609a6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isSyncMaster </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this device is in a master role regarding the device synchronization </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization master role </dd></dl>

</div>
</div>
<a class="anchor" id="afb1d4340c666b090dfc2d3b2d0a4b75d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::isSyncSlave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this device is in a slave role regarding the device synchronization </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization slave role </dd></dl>

</div>
</div>
<a class="anchor" id="a482ee44a2d1915c8fa6c4c5f60f37aab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> XsDevice::labMagneticField </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 'Lab Magnetic Field' of the device. </p>
<p>The Lab Magnetic Field is the earth magnetic field where the measurements are done. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'Lab Magnetic Field' setting of the device. This is either a 3-element vector or an empty vector. When the vector is empty or all 0 values, the setting is not used by the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6a9a445b82dfb0cc5b3dce96722cc289" title="Sets the &#39;Lab Magnetic Field&#39; of the device to the given vector.">setLabMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1689ca3bd26c9c104504cf65a57375a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t XsDevice::lastKnownRssi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last known RSSI value of the device. </p>
<p>RSSI values are only relevant for wireless devices. Since the value is measured passively, any time an RSSI value is received by XDA, the last known value is updated. </p>
<dl class="section return"><dt>Returns</dt><dd>The last known biased RSSI value or XS_RSSI_UNKNOWN if no RSSI value is available (yet) </dd></dl>

</div>
</div>
<a class="anchor" id="a6e4f056042ffb956c48ed6717b24ec28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> XsDevice::latLonAlt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'Latitude Longitude Altitude' setting of the device. </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. </p>
<dl class="section return"><dt>Returns</dt><dd>lla The desired 'Latitude Longitude Altitude' setting for the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab" title="Returns the &#39;Lab Magnetic Field&#39; of the device.">labMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a15312f246b4a1eaace09d3f98e8f9ed7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::loadLogFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a complete logfile. </p>
<p>Load the opened log file completely. This function loads all data from the open logfile in a separate thread, generating onProgressUpdated callbacks. This function will return true if the reading was scheduled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the threaded loading was successfully started </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>onProgressUpdated </dd></dl>

</div>
</div>
<a class="anchor" id="a6cd80807c1e9d0dcf3fd4b0481ef3de2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::locationId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the location ID of the device. </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p>
<dl class="section return"><dt>Returns</dt><dd>The current location ID stord in the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a4a46ea2a77ab9a0a392ebf7b21ebd46d" title="Set the location ID of the device.">setLocationId</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a067da0d706ba791a76448d648066c934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevice::logFileName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the log file the device is reading from. </p>
<p>Returns an empty string when not in file mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the logfile </dd></dl>

</div>
</div>
<a class="anchor" id="af5b4bcf9503a0e531de04d40fb05dc0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevice::logFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current read position of the open log file. </p>
<p>If the function encounters an error the function returns -1. </p>
<dl class="section return"><dt>Returns</dt><dd>The current read position (in bytes) from the start of the file or -1 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a2b20b09509ae122b7b72129a1689f081" title="Get the size of the log file the device is reading from.">logFileSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b20b09509ae122b7b72129a1689f081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevice::logFileSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the log file the device is reading from. </p>
<p>If the function encounters an error the function returns 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the log file or 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af5b4bcf9503a0e531de04d40fb05dc0d" title="Get the current read position of the open log file.">logFileReadPosition</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae53dfaa0f730f065fcb6c1eb5b411db0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::makeOperational </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets te Awinda station to operational state. </p>
<dl class="section note"><dt>Note</dt><dd>this is considered an extension to the config state, not a new state. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when the awindastation is put in operational mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a5528e0d30a8958cb6c42398a865724bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevice::master </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the master device of this device. </p>
<p>This function returns the master device of the current device. This may be the device itself </p>
<dl class="section return"><dt>Returns</dt><dd>The master device of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a2d9270a980750ea542a0584a360e2758"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::maximumUpdateRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum update rate for the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum update rate of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a358a87088eeee36a8be981d95cd252f0" title="Ask the device for its supported update rates for the given dataType.">supportedUpdateRates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a060c13affa6f5cc92fd0a64aecb709d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevice::nextAvailableDataPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the next data packet in the live stream. </p>
<p>The function returns the first item in the packet queue and removes it from the queue. If there are no packets in the queue, an empty XsDataPacket is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>The requested XsDataPacket if available or an empty one if the queue is empty </dd></dl>

</div>
</div>
<a class="anchor" id="aa82640a51951f119f5947bc81953cf4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> XsDevice::objectAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object alignment matrix of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'object alignment matrix' setting of the device. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>setObjectAlignmentMatrix() </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a40f18e73cb0d73a5b0994690c478b079"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> XsDevice::onboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the filter profile in use by the device for computing orientations. </p>
<dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028" title="Sets the filter profile to use for computing orientations on the device.">setOnboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716" title="Gets the filter profile in use for computing orientations on the host PC.">xdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acf953cbe304a22bd94892a7baf265738"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> XsDevice::outputConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured output of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The output configuration of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed7e4f103b81d0d7dab12e4bbd19e44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a> XsDevice::outputMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the output mode. </p>
<p>In legacy output mode, the output mode combined with the output settings define which data is sent by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output mode' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1ed7e8c1ec819efff29652b0378d27c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a> XsDevice::outputSettings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the output settings. </p>
<p>In legacy output mode, the output mode combined with the output settings define which data is sent by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output settings' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b7330dcb033684c248d73781414f1fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice::outputSkipFactor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the output skip factor. </p>
<p>In legacy output mode, the output skip factor combined with the sample period define the rate at which data is sent by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output skip factor' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae662335ace1527f73fe918ddf5364242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a> XsDevice::peekMessageId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a peek at the next message's message ID in the file. </p>
<p>This function can be used to look ahead in a file without having XDA do any processing. If the device is not a main device, the corresponding main device will be queried instead. The data returned is not necessarily the data for this device when reading from a stream that contains data for multiple devices. </p>
<dl class="section return"><dt>Returns</dt><dd>The Xsens Xbus message ID of the next message or XMID_InvalidMessage if no more messages are available. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To avoid confusion it is recommended to always use the main device when calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a2d4bf3b5d990d064daebb955771234"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevice::portName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port name of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the communication port or an empty string if not connected to a communication port </dd></dl>

</div>
</div>
<a class="anchor" id="aab14a71dc537d1ca319a94ee50eb7aaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::portNumber </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the port number of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The port number or 0 if no port is open that can be identified by a single number </dd></dl>

</div>
</div>
<a class="anchor" id="a2e996cee01ae20630171ad7316e15384"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the device to power down completely (Xbus Master only) </p>
<p>This function can be used to tell the device to shut down completely, requiring a physical button press on the device to power up again. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully powered down </dd></dl>

</div>
</div>
<a class="anchor" id="ad0c9de7bd8ac2786cd7d1d3cd3f46878"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> XsDevice::processedOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full output configuration including post processing outputs. </p>
<p>This function return the list returned by <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> and adds outputs that become available during post-processing. </p>
<dl class="section return"><dt>Returns</dt><dd>The requested output configuration list </dd></dl>

</div>
</div>
<a class="anchor" id="a2e487178fca0cda67e06fe66bf17575b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevice::productCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product code of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The product code of the device </dd></dl>

</div>
</div>
<a class="anchor" id="add086b77793cf3c81e5107118143956f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::queueLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items currently in the cache for the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of packets that are ready to be read from the live queue </dd></dl>

</div>
</div>
<a class="anchor" id="a45b86ccc2b443f1c2bfd6c99fefcfe34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> XsDevice::queueMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently used queue mode. </p>
<dl class="section return"><dt>Returns</dt><dd>the currently selected queue mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ac404b469ed2b928365d5a6ff63ee81ea" title="Set the queue mode to the given mode.">setQueueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a10af14e5ee745c50f4565078861c5d70" title="Get the currently used queue mode.">XsControl::queueMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a467926061f722fd0f63900420144a57d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::radioChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radio channel used for wireless communication. </p>
<dl class="section return"><dt>Returns</dt><dd>The radio channel used for wireless communication or -1 if the radio is disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>

</div>
</div>
<a class="anchor" id="a0c9fe272c871a765e6e173483c5bbf59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::refCounter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current reference counter. </p>
<dl class="section return"><dt>Returns</dt><dd>The current reference count </dd></dl>

</div>
</div>
<a class="anchor" id="a760b5be213bda85dbdae39cdfa944b6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::reinitialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a>. </p>
<p>This function will read all configuration details freshly from the device and will reinitialize all filters. Especially when you have made changes to the device configuration outside XDA or through <a class="el" href="struct_xs_device.html#a3589494a7043c386d42fc147301748c5" title="Send a custom message messageSend to the device and possibly wait for a result.">sendCustomMessage()</a> it is advisable to call this function so XDA will show the correct state of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reinitialized </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device itself is not reset, but will be put in config mode while the settings are being updated. </dd></dl>

</div>
</div>
<a class="anchor" id="a40f132f99c5e9e67e699abb62d135739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::rejectConnection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reject connections from the device on the parent/master device. </p>
<p>This function can be used to reject connections from a device that has connected. This function can be called from within the onConnectivityChanged callback or at other times when a device is connected. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device will be rejected next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After the function returns, this <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> should no longer be used. </dd>
<dd>
MTw connected to Awinda Station only </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a729def5c76bfd153ae0761014f2588d0" title="Returns the reason why a device&#39;s connection was rejected.">rejectReason</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a729def5c76bfd153ae0761014f2588d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a> XsDevice::rejectReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reason why a device's connection was rejected. </p>
<p>This function is typically called from within the onConnectivityChanged callback when the connectivity has changed to XCS_Rejected. </p>
<dl class="section return"><dt>Returns</dt><dd>The reason why the connection was rejected </dd></dl>

</div>
</div>
<a class="anchor" id="a187440a3a947426a09e51f8050fdbbcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevice::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cd27bfdcb1f8d7a57d9eeedaa9c1f19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice::removeRef </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1. </p>
<ul>
<li>If it is a child device, it will delete itself when the reference count reaches zero. It will also remove itself from its master's child list and ask the master if it can be deleted</li>
<li>If it is a master device, it will delete itself when the reference count reaches zero and the reference count of all children is zero. </li>
</ul>

</div>
</div>
<a class="anchor" id="a985cb493b55e4336137e99d804fd3556"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::replaceFilterProfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;&#160;</td>
          <td class="paramname"><em>profileCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;&#160;</td>
          <td class="paramname"><em>profileNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces profileCurrent by profileNew in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileCurrent</td><td>The profile that should be replaced </td></tr>
    <tr><td class="paramname">profileNew</td><td>The new profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ae2cc7e5d0cdab1740edc9aeb5f724774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::requestBatteryLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the battery level from the device. </p>
<p>This is an asynchronous operation. The Awinda station or MTw sends the battery level when possible. For devices in wired mode the </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ad9a5dd4a13161a69e4927191a7295cd3" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">batteryLevel()</a> function can be called without calling this function first. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true If the battery level request was successfully sent </dd></dl>

</div>
</div>
<a class="anchor" id="a6e591d4cef4cb3f4d02f73c2f587f210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::requestData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request data when configured in legacy mode with infinite skip factor. </p>
<p>When configured in legacy mode and an output skip factor of 0xFFFF, the device will not send data by itself, but will instead send the latest data after receiving an explicit request. This function is that request. After the request, the normal callback mechanism will take over. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent. </dd></dl>

</div>
</div>
<a class="anchor" id="aede7b469948953c5ea2f28dd6bda48f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the device. </p>
<p>This function tells the device to reboot itself. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reset </dd></dl>

</div>
</div>
<a class="anchor" id="a6b2b7ef873a12e425901544c7349092b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::resetDroppedPacketCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the dropped packet count. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af46c1ca0b7962af4334aa765bfb5155a" title="Get the number of packets dropped by the port.">droppedPacketCount</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the packet count has been successfully reset to 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a41d64884658c21c321545420ab8f0aa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::resetLogFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the read position of the open log file to the start of the file. </p>
<p>If software filtering is enabled, the appropriate filters will be restarted as if the file was just opened. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the read position was successfully reset to the start of the file </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dae7f768d4bec3f98fbec0b82d92490"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::resetOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a>&#160;</td>
          <td class="paramname"><em>resetmethod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an orientation reset on the device using the given <em>resetMethod</em>. </p>
<p>This function schedules an orientation reset command to be applied in the first available orientation filter update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetmethod</td><td>The requested orientation reset method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the orientation reset was successfully scheduled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>XRM_StoreAlignmentMatrix can only be used in config mode, the others only in measurement mode </dd></dl>

</div>
</div>
<a class="anchor" id="a9625df9c12421a71686103b4becb17a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::restoreFactoryDefaults </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the device to its factory default settings. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the settings have been successfully restored </dd></dl>

</div>
</div>
<a class="anchor" id="ab593a883c91d00fa56cccf9dd0c2eb12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice::rs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transmission delay used for RS485 transmissions. </p>
<p>See the low level documentation for more information on this function. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured RS485 transmission delay </dd></dl>

</div>
</div>
<a class="anchor" id="ade80265d5f3e15337a96465d88c68e4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a> XsDevice::runSelfTest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the self test for the device. </p>
<p>All Xsens devices have limited self-diagnostic functionality, which can be triggered by calling this function. The device automatically does some self tests during startup, but this function returns more information. </p>
<dl class="section return"><dt>Returns</dt><dd>Results of the test </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and can take a few 100 ms </dd></dl>

</div>
</div>
<a class="anchor" id="ae105a1c7376133c8d74e5635ffe088e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice::samplePeriod </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample period. </p>
<p>In legacy output mode, the output skip factor combined with the sample period define the rate at which data is sent by the device. The sample period is set in units of 1/115200 seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'sample period' setting of the device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#acf953cbe304a22bd94892a7baf265738" title="Returns the currently configured output of the device.">outputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3589494a7043c386d42fc147301748c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::sendCustomMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>messageSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>messageReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a custom message <em>messageSend</em> to the device and possibly wait for a result. </p>
<p>If <em>waitForResult</em> is true, the function will wait for a result and put it in the given <em>messageReceive</em>. Otherwise the contents of messageReceive will not be altered. If an error message is received or the wait times out, <em>messageReceive</em> will contain an error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSend</td><td>The message to send to the device </td></tr>
    <tr><td class="paramname">waitForResult</td><td>true if it is required that the function waits for the appropriate reply. A valid reply always has a message ID that is one higher than the sent message ID. </td></tr>
    <tr><td class="paramname">messageReceive</td><td>When <em>waitForResult</em> is true, the reply will be put in this object. </td></tr>
    <tr><td class="paramname">timeout</td><td>Optional timeout in ms. When 0 is supplied (the default), the default timeout is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent and when <em>waitForResult</em> is true the correct reply has been received </dd></dl>

</div>
</div>
<a class="anchor" id="a91de612878efc23c4686f7c9d236e995"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::sendRawMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message directly to the communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message that will be send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent </dd></dl>

</div>
</div>
<a class="anchor" id="a6c7748ffd37793917d6ce13e464cf2c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsBaudRate XsDevice::serialBaudRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The baud rate configured for cabled connection. </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#a613cd4d200015a0e457c29ddcb689152" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function in that it will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly), whereas the <a class="el" href="struct_xs_device.html#a613cd4d200015a0e457c29ddcb689152" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function will return the baud rate of the current connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The configured baud rate </dd></dl>

</div>
</div>
<a class="anchor" id="a1db27fb6afef01dd3d3e2c72e67613f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setAlignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the chosen frame S </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">matrix</td><td>The desired alignment rotation setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aaddd92e26153da568a828525aa9026be" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to ...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307" title="Retrieve the alignment rotation quaternion.">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaddd92e26153da568a828525aa9026be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setAlignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L or S to the chosen frame S </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">quat</td><td>The desired alignment rotation setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af1aba825d963ea3042e8ed7a28619307" title="Retrieve the alignment rotation quaternion.">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a1db27fb6afef01dd3d3e2c72e67613f2" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L or S to the c...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a5ededbf2aad434c030f258e90799add4" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae951952646d9e109e6f04b1b90b9bdee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the BlueTooth radio of the device (Xbus Master only) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to enable the BlueTooth radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab1db7aa59f179672f34b3026941053ff" title="Returns true if the device has its BlueTooth radio enabled (Xbus Master only)">isBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a45461d069fe6ab4315f3880eeffc6819"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the Xbus Master to provide power to its child devices or not. </p>
<p>This function can be used to tell the Xbus Master to stop and start powering its child devices. By default when the Xbus Master starts up it will provide power to its child devices. Switching the power off can save a lot of energy, but powering the system up again will take some time, depending on the number of connected devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable bus power, false to disable the bus power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the Xbus Master's bus power state was successfully updated. </dd></dl>

</div>
</div>
<a class="anchor" id="a65ca303a74e4655f2481276c3ebc1d70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setDeviceAccepted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to accept </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been succesfully accepted </dd></dl>

</div>
</div>
<a class="anchor" id="ab45b46b9b36d94c9e254f6152b7f9207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setDeviceMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_mode.html">XsDeviceMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the legacy output configuration of the device. </p>
<p>This function can be used to switch to legacy output mode and set the full output configuration of the device in legacy mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired legacy output configuration for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully configured </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd" title="Returns the legacy output configuration as an XsDeviceMode object.">deviceMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6d6aa7f51ace66f2b3c5435f4bf71eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setDeviceRejected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rejects a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to reject </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been succesfully rejected </dd></dl>

</div>
</div>
<a class="anchor" id="afe553d06248b87484637c090e0541108"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setDualOutputEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the BlueTooth radio of the device (Xbus Master only) </p>
<p>When configured for dual output mode this, the Xbus Master still only accepts commands on its BlueTooth connection, which must be enabled for this function to work. This configuration is mostly useful when trying to troubleshoot wireless connectivity issues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to enable dual output mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab576743221b08c8e04f802e5fad8feaf" title="Returns true if the device is sending output over its BlueTooth radio and over the serial connection ...">isDualOutputEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab1db7aa59f179672f34b3026941053ff" title="Returns true if the device has its BlueTooth radio enabled (Xbus Master only)">isBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0de11adb871b12fc84c3a37ae3b83e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setErrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td>
          <td class="paramname"><em>errormode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the error mode of the device (Xbus Master only) </p>
<p>The error mode tells the device what to do if a problem occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errormode</td><td>The desired error mode of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a57c6e0f5be723782b0ae6440be696ea9" title="Returns the error mode of the device (Xbus Master only)">errorMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33a317dc6368a72e2a5bcb8c46c3f3e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the fixed gravity value should be used or if it should be computed from the LatLonAlt value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to use fixed gravity, false to compute from LatLonAlt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ac9dcf8b4f2aad25e547a44a4858d4a23" title="Returns if the fixed gravity value should be used or if it should be computed from the LatLonAlt valu...">isFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae75f6730561da7c7b54fe591f1209314" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag.">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a77e0d054ccc6242b4c2f650732fd5d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice::setGotoConfigOnClose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gotoConfigOnClose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On closePort the device will go to config by default, with this function it is possible to prevent that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gotoConfigOnClose</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae75f6730561da7c7b54fe591f1209314"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setGravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>. </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mag</td><td>The desired 'Gravity Magnitude' setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Gravity Magnitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default value is usually computed from the last known Lat Lon Alt value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">setLatLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04058dd4f3e6f48af73e54d8bf6c77c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setHeadingOffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the 'heading offset' setting of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The desired heading offset of the device in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a38bdd87c62c9fdea175acaf98e5d0e49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if the device does gyroscope bias estimation when switching to measurement mode. </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a5a6ebbd9e51082930fdd5abcc6879a34" title="Set the no rotation period to duration.">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a782d2d345c99aa2039fdc3298ae994a7" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9a445b82dfb0cc5b3dce96722cc289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setLabMagneticField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>magfield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Lab Magnetic Field' of the device to the given <em>vector</em>. </p>
<p>The Lab Magnetic Field is the earth magnetic field where the measurements are done. Setting this value allows more accurate north reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">magfield</td><td>The desired 'Lab Magnetic Field' setting of the device. This should be a 3-element vector. When the vector is empty or all 0 values, the setting is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Lab Magnetic Field was successfully written </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab" title="Returns the &#39;Lab Magnetic Field&#39; of the device.">labMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3b2eb82952163acc7db94deeebbf7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setLatLonAlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lla</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>. </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. The default gravity magnitude and earth magnetic field are computed form this value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>The desired 'Latitude Longitude Altitude' setting for the device. This should be a 3-element vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Latitude Longitude Altitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When GPS is available, this value is automatically updated with the last known position when the device is put in config mode after measurement. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6e4f056042ffb956c48ed6717b24ec28" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device.">latLonAlt</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a482ee44a2d1915c8fa6c4c5f60f37aab" title="Returns the &#39;Lab Magnetic Field&#39; of the device.">labMagneticField</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab2edf0c9d7e1d8e2b53c02f7ebd0b624" title="Returns the &#39;Gravity Magnitude&#39; of the device.">gravityMagnitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a46ea2a77ab9a0a392ebf7b21ebd46d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setLocationId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the location ID of the device. </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The desired location ID for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Location ID was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6cd80807c1e9d0dcf3fd4b0481ef3de2" title="Get the location ID of the device.">locationId</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6ebbd9e51082930fdd5abcc6879a34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setNoRotation </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the no rotation period to <em>duration</em>. </p>
<p>This function can be called in both config and measurement modes. In config mode it specifies the duration that the device is considered to be stationary as soon as it enters measurement mode. In measurement mode, it specifies the duration that the device is considered to be stationary, starting immediately.</p>
<p>During the stationary period, the gyroscope biases are measured, giving better performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The desired stationary duration in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the no rotation command was accepted by the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a782d2d345c99aa2039fdc3298ae994a7" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a38bdd87c62c9fdea175acaf98e5d0e49" title="Set if the device does gyroscope bias estimation when switching to measurement mode.">setInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae523c9b1a429357ffabc7927a51cc7e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setObjectAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the object alignment of the device to the given <em>matrix</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The desired 'object alignment matrix' setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object alignment matrix was successfully written </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>objectAlignmentMatrix </dd>
<dd>
<a class="el" href="struct_xs_device.html#abcce3002fee1759260ea024318ef9730" title="Return the &#39;heading offset&#39; setting of the device.">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a04058dd4f3e6f48af73e54d8bf6c77c1" title="Set the &#39;heading offset&#39; setting of the device.">setHeadingOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac315cf6332ea92920b06e7d30b47f028"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setOnboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the device. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d" title="Return the list of filter profiles available on the device.">availableOnboardFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a25b3869ecd19fa3eecac439f790f043d" title="Return the list of filter profiles available on the device.">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079" title="Gets the filter profile in use by the device for computing orientations.">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c" title="Sets the filter profile to use for computing orientations on the host PC.">setXdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a59f5dfc2bd1168a70d1e7f2335cdb5a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setOptionEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable a processing option. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data. The default state of these options is enabled. On a system with limited resources it may be useful to limit the processing done by XDA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to enable or disable </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the option was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some options depend on each other and thus can cause other options to become enabled or disabled as well. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#ae0da29c15d3aaf244711c98c48c128e9" title="Returns whether a processing option is enabled or not.">isOptionEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af303efb04dde3783bfebc8e4b1025578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output configuration for this device When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined. </p>
<p><em>config</em> is updated to reflect frequency mismatches in desired configuration and actually possible configuration. As input, a frequency of 65535 (0xFFFF) may be supplied to indicate 'maximum output rate', but after configuration XDA will have put the actual maximum value in <em>config</em>. Similarly, some data types may not have a real update rate (ie. packet counter) and will return an update rate of 65535 (0xFFFF) when configured at any rate other than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The desired output configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output configuration was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a6d63878cb644ff64a4053d82c3a2d063"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setOutputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a3c29ec781b610861d5647f6d7e2375">XsOutputMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the outputmode for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired 'output mode' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6858b0e1ff701f8c8312b0085626e3f7" title="Set the output settings for this device.">setOutputSettings</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6858b0e1ff701f8c8312b0085626e3f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setOutputSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga495d13d74173f9670b4e4a544557c88a">XsOutputSettings</a>&#160;</td>
          <td class="paramname"><em>outputsettings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output settings for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputsettings</td><td>The desired 'output settings' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6d63878cb644ff64a4053d82c3a2d063" title="Set the outputmode for this device.">setOutputMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a148ae39934d2bfff02afad6092cbbbcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setOutputSkipFactor </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>skipFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output skip factor for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipFactor</td><td>The desired 'output skip factor' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac404b469ed2b928365d5a6ff63ee81ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setQueueMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the queue mode to the given <em>mode</em>. </p>
<p>Indicate if a readData call for a live system should get the latest data or the next in queue data or nothing at all. The default queue mode is XQM_CallbackOnly, which means that data is not queued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the new queue mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a45b86ccc2b443f1c2bfd6c99fefcfe34" title="Get the currently used queue mode.">queueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a9720f314343d0bc679e5d19d077086d4" title="Set the queue mode to the given mode.">XsControl::setQueueMode</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when the queue mode has been successfully set. </dd></dl>

</div>
</div>
<a class="anchor" id="aa46dc569444542b62bfb6402e9183865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setRs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the transmission delay used for RS485 transmissions. </p>
<p>See the low level documentation for more information on this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>The desired delay </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a1a744f146c605a383ce90cac08dafa63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setSamplePeriod </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sample period for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>The desired 'sample period' setting for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use <a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration()</a> instead. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#af303efb04dde3783bfebc8e4b1025578" title="Set the output configuration for this device When the function exits with a true value config will co...">setOutputConfiguration</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a81ac891f7171b5e55f2a20d8b9d5b105"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setSerialBaudRate </td>
          <td>(</td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the serial baudrate to <em>baudrate</em>. </p>
<p>This function is only useful when using a serial communication channel, such as a serial-USB converter or a direct COM port. It is advised to make the baud rate as high as your platform allows, to minimize latency and problems with bandwidth.</p>
<p>After setting the baudrate and communicating over the same communication channel, it is required to reset the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The desired serial baudrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the baud rate was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a3db7f9734a5523a435d67289ec44ecd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setStringOutputType </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the string output type for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired stringOutputType for this device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The string output type is a bitwise or of individual types </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__enums.html#ga8f9ea9c77823d74374700729ba69e9d9" title="NMEA string types.">XsNmeaStringType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa9c94357252aee3388dee8cca4ea6b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setSyncBoxMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sync box mode of the Awinda Station device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable sync box mode, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a1d1e8487e22ddfa3376893262e3c3607"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setSyncSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> &amp;&#160;</td>
          <td class="paramname"><em>settingList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the synchronization settings of the device. </p>
<p>This function can be used to set all the synchronization options of the device at once. It is translated into device-specific commands by XDA, since not all devices support the same synchronization functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settingList</td><td>The list of synchronization settings to set. An empty list will clear all synchronization settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a6b162561df7e93e8a3ebe35a920ba655" title="Get all the current synchronization settings of the device.">syncSettings</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4dd6644f24f131274421aaea9d0fc0c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setTransportMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transportModeEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the transport mode for the device. </p>
<p>The MTw has a "wake up by motion" feature that requires some power and can cause unnecessary wakeups when transporting the device. This function can be used to put the device in "transport mode", which effectively disables the motion wake up feature until the device is plugged into something or the transport mode is explicitly disabled by this function again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transportModeEnabled</td><td>true to enable transport mode (which disables the motion wakeup) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in transport mode (or taken out of it) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw only </dd></dl>

</div>
</div>
<a class="anchor" id="a3c0da43d5b8efb0e99b724bd999a9459"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setUpdateRate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the legacy update rate of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rate</td><td>The desired legacy update rate for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the update rate was successfully set </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa0561ec33a8d9c188b2e22b5ca73880e" title="Returns if the device is outputting data in legacy mode.">isInLegacyMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a530efa668ba72fc4fc693c56676b71fd" title="Returns the legacy output configuration as an XsDeviceMode object.">deviceMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab45b46b9b36d94c9e254f6152b7f9207" title="Sets the legacy output configuration of the device.">setDeviceMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1664dc8053156b76530fa5070a8dbe59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setWirelessPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wireless priority of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired wireless priority of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the wireless priority has been successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba7e1380aabd196f77809a56a26ce3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::setXdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the host PC. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. By default XDA will attempt to match the software filter profile to the configured hardware filter profile when detecting a new device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce" title="Return the list of filter profiles available on the host PC.">availableXdaFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When reading from a file, make sure to call <a class="el" href="struct_xs_device.html#a41d64884658c21c321545420ab8f0aa4" title="Set the read position of the open log file to the start of the file.">resetLogFileReadPosition()</a> and possibly <a class="el" href="struct_xs_device.html#a15312f246b4a1eaace09d3f98e8f9ed7" title="Load a complete logfile.">loadLogFile()</a> after changing the filter profile to make sure all cached data is recomputed. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#aa6a13f22e39ec655c58aec317206fcce" title="Return the list of filter profiles available on the host PC.">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a18bf6c8506ba64416548de5ab5db0716" title="Gets the filter profile in use for computing orientations on the host PC.">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac315cf6332ea92920b06e7d30b47f028" title="Sets the filter profile to use for computing orientations on the device.">setOnboardFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8aef28ccbb4b80b80be6b85fedd6d87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::startRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording incoming data. </p>
<p>To record succesfully, a log file should be created by calling <a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185" title="Create a log file for logging.">createLogFile()</a> before this function is called. startRecording(XsString, XsDeviceId) can be used to achieve the same result. </p>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully started </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Starting recording for a single non-main device will start a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185" title="Create a log file for logging.">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a7899e535c8459b3154a6610c71b7c471" title="Stop recording incoming data.">stopRecording()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7899e535c8459b3154a6610c71b7c471"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::stopRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop recording incoming data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully stopped </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stopping recording for a single non-main device will stop a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a104b615636d419a3e0c3dfa07f1d0185" title="Create a log file for logging.">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab8aef28ccbb4b80b80be6b85fedd6d87" title="Start recording incoming data.">startRecording()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5d00abeeea6064e990195233d5ce8eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::storeFilterState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store orientation filter state in the device. </p>
<p>Use this function when the filters for the device have stabilized to store the current biases in the device. The benefit is that on the next startup the filter will stabilize quicker. However, the stored biases depend on temperature and other external parameters, so the stored values will remain correct for only a short time. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the filter state was saved, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af00e59356f6f4a9bd4124b0c2a628989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevice::stringOutputType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string output type. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'string output type' setting of the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a3db7f9734a5523a435d67289ec44ecd0" title="Set the string output type for this device.">setStringOutputType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af99fb37cbc1479c774c891c01dd43fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> &gt; XsDevice::supportedSyncSettings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all supported synchronization settings available on the device. </p>
<p>This function provides a list of the available synchronization settings of the device, since not all devices support the same synchronization functionality. Every <a class="el" href="struct_xs_sync_setting.html" title="A structure for storing all xsens sync settings.">XsSyncSetting</a> element in the list defines one function and line setting, with supported parameters. If the same function support multiple settings (i.e. multiple lines), then the list will contains multiple items with the same function name, but with different line settings. For easier use, same functions must be listed next to eachother, so each function settings in the list will be grouped. Properties, others then m_function and m_line are set to 0 if not supported or 1 if supported by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings supported by the device. Each settings grouped by functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a358a87088eeee36a8be981d95cd252f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; XsDevice::supportedUpdateRates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em> = <code>XDI_None</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the device for its supported update rates for the given <em>dataType</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the supported update rates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list with the supported update rates or an empty list in case of an error </dd></dl>

</div>
</div>
<a class="anchor" id="a60e2d6a5a3edec9b8185f065b41a2ae3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a> XsDevice::syncRole </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the synchronization role of the device. </p>
<p>For synchronization purposes a device can be a master, a slave, both or neither. This function returns the way the device is currently configured. </p>
<dl class="section return"><dt>Returns</dt><dd>The synchronization role of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a6b162561df7e93e8a3ebe35a920ba655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> &gt; XsDevice::syncSettings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the current synchronization settings of the device. </p>
<p>This function is a generic way of requesting the synchonization options of a device, since not all devices support the same synchronization functionality. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings configured for the device </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a1d1e8487e22ddfa3376893262e3c3607" title="Set the synchronization settings of the device.">setSyncSettings</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9ef88c8926351b40355758f9dc681b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::transportMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current state of the transport mode feature. </p>
<dl class="section return"><dt>Returns</dt><dd>true if tranport mode is currently enabled </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a4dd6644f24f131274421aaea9d0fc0c3" title="Enable or disable the transport mode for the device.">setTransportMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a029ceaba1cdfcd0ab1092e8c42662c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::updateCachedDeviceInformation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the cached device information for all devices connected to this port. </p>
<p>This function can only be called in config mode. XDA caches all device information to prevent unnecessary communication with the device. When some configuration has changed without XDA knowing about it (through <a class="el" href="struct_xs_device.html#a3589494a7043c386d42fc147301748c5" title="Send a custom message messageSend to the device and possibly wait for a result.">sendCustomMessage()</a> for example), it may be necessary to tell XDA to refresh its cached information by calling this function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the cached information was updated successfully </dd></dl>

</div>
</div>
<a class="anchor" id="a365e05d870d575a755034e2f10f264d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::updateRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the legacy update rate of the device. </p>
<p>This function is only valid for devices in legacy mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The legacy update rate of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a47f031725cdf6f7b41ef393f1fd1f1f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::updateRateForDataIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>. </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. This function only checks the output configured in the device, not possible computed data </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a668e50cfe473e459b5a6d35bb338214e" title="Returns the currently configured update rate for the supplied dataType.">updateRateForProcessedDataIdentifier</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>

</div>
</div>
<a class="anchor" id="a668e50cfe473e459b5a6d35bb338214e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::updateRateForProcessedDataIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>. </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. Where updateRateForDataIdentifier only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a47f031725cdf6f7b41ef393f1fd1f1f0" title="Returns the currently configured update rate for the supplied dataType.">updateRateForDataIdentifier</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>

</div>
</div>
<a class="anchor" id="a7240291ff040ebbe6abb6ee229ea5756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevice::usesLegacyDeviceMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the device uses legacy device mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the legacy period, outputmode, outputsettings or string reports are used </dd></dl>

</div>
</div>
<a class="anchor" id="a82f18679b251353c73efd5e6455bd002"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevice::wirelessPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wireless priority of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The wireless priority of the device or 0 if it has none. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="adcd03e4859deb925975b4a3423b35d2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevice::writeDeviceSettingsToFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the emts/wms/xms of the device and all its children to the open logfile. </p>
<dl class="section note"><dt>Note</dt><dd>The default implementation just tells all its children to do the same </dd></dl>

</div>
</div>
<a class="anchor" id="a18bf6c8506ba64416548de5ab5db0716"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> XsDevice::xdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the filter profile in use for computing orientations on the host PC. </p>
<dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the PC </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a9ba7e1380aabd196f77809a56a26ce3c" title="Sets the filter profile to use for computing orientations on the host PC.">setXdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a40f18e73cb0d73a5b0994690c478b079" title="Gets the filter profile in use by the device for computing orientations.">onboardFilterProfile</a> </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Thu Jan 16 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
