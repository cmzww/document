<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsControl Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_xs_control-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsControl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>High level Motion Tracker (MT) management class.  
 <a href="struct_xs_control.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a383124de0bf073f72800eb1905008eee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a383124de0bf073f72800eb1905008eee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee">destruct</a> (void)</td></tr>
<tr class="memdesc:a383124de0bf073f72800eb1905008eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object and free all memory allocated for it. <br/></td></tr>
<tr class="separator:a383124de0bf073f72800eb1905008eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aa4b38d3c19b733d0c1bf5e63dbb0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a40aa4b38d3c19b733d0c1bf5e63dbb0f">flushInputBuffers</a> (bool complete)</td></tr>
<tr class="memdesc:a40aa4b38d3c19b733d0c1bf5e63dbb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of all devices.  <a href="#a40aa4b38d3c19b733d0c1bf5e63dbb0f"></a><br/></td></tr>
<tr class="separator:a40aa4b38d3c19b733d0c1bf5e63dbb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0281f1055d6080734ce67526e2210fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3">close</a> (void)</td></tr>
<tr class="memdesc:a0281f1055d6080734ce67526e2210fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all ports and files.  <a href="#a0281f1055d6080734ce67526e2210fd3"></a><br/></td></tr>
<tr class="separator:a0281f1055d6080734ce67526e2210fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcd5f3427b7509b07baf64650e56dbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd">openPort</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname, XsBaudRate baudrate, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:a0dcd5f3427b7509b07baf64650e56dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel on serial port with the given <em>portname</em>.  <a href="#a0dcd5f3427b7509b07baf64650e56dbd"></a><br/></td></tr>
<tr class="separator:a0dcd5f3427b7509b07baf64650e56dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3a38146617728cea9490fa3c98fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae7f3a38146617728cea9490fa3c98fe7">openPort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo, uint32_t timeout=0)</td></tr>
<tr class="memdesc:ae7f3a38146617728cea9490fa3c98fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel using the details in the supplied XsPortInfo structure.  <a href="#ae7f3a38146617728cea9490fa3c98fe7"></a><br/></td></tr>
<tr class="separator:ae7f3a38146617728cea9490fa3c98fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79">closePort</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname)</td></tr>
<tr class="memdesc:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portname</em>.  <a href="#a9b3617d4a55cf48ddf7257788e1d5a79"></a><br/></td></tr>
<tr class="separator:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2a3ac5d55588c89de12347b17304a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aee2a3ac5d55588c89de12347b17304a2">closePort</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId)</td></tr>
<tr class="memdesc:aee2a3ac5d55588c89de12347b17304a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the port that is used for communication with the given <em>deviceId</em>.  <a href="#aee2a3ac5d55588c89de12347b17304a2"></a><br/></td></tr>
<tr class="separator:aee2a3ac5d55588c89de12347b17304a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ce0525bfbd2726822d8d04306f8ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a16ce0525bfbd2726822d8d04306f8ba3">closePort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo)</td></tr>
<tr class="memdesc:a16ce0525bfbd2726822d8d04306f8ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port that matches <em>portinfo</em>.  <a href="#a16ce0525bfbd2726822d8d04306f8ba3"></a><br/></td></tr>
<tr class="separator:a16ce0525bfbd2726822d8d04306f8ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2f1637761664f1828e4d7895cdb453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ace2f1637761664f1828e4d7895cdb453">openPort</a> (int portNr, XsBaudRate baudrate, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:ace2f1637761664f1828e4d7895cdb453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel to the given COM <em>portNr</em>.  <a href="#ace2f1637761664f1828e4d7895cdb453"></a><br/></td></tr>
<tr class="separator:ace2f1637761664f1828e4d7895cdb453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afe51569172239121d6f0520b93d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a47afe51569172239121d6f0520b93d6e">closePort</a> (int portNr)</td></tr>
<tr class="memdesc:a47afe51569172239121d6f0520b93d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portNr</em>.  <a href="#a47afe51569172239121d6f0520b93d6e"></a><br/></td></tr>
<tr class="separator:a47afe51569172239121d6f0520b93d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19d4bbf1c8331a77c1583800314fb60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae19d4bbf1c8331a77c1583800314fb60">openLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:ae19d4bbf1c8331a77c1583800314fb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the log file with the given <em>filename</em>.  <a href="#ae19d4bbf1c8331a77c1583800314fb60"></a><br/></td></tr>
<tr class="separator:ae19d4bbf1c8331a77c1583800314fb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552d32d161eb719c0ca469385581c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f">lastResult</a> (void) const </td></tr>
<tr class="memdesc:a6552d32d161eb719c0ca469385581c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="#a6552d32d161eb719c0ca469385581c2f"></a><br/></td></tr>
<tr class="separator:a6552d32d161eb719c0ca469385581c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3caf40d684b29db2c89f98b0c9cd9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec">lastResultText</a> (void) const </td></tr>
<tr class="memdesc:af3caf40d684b29db2c89f98b0c9cd9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text for the value returned by <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a>  <a href="#af3caf40d684b29db2c89f98b0c9cd9ec"></a><br/></td></tr>
<tr class="separator:af3caf40d684b29db2c89f98b0c9cd9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdbd84451e2f19f44d453c9a71835eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#abfdbd84451e2f19f44d453c9a71835eb">deviceCount</a> (void) const </td></tr>
<tr class="memdesc:abfdbd84451e2f19f44d453c9a71835eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected devices.  <a href="#abfdbd84451e2f19f44d453c9a71835eb"></a><br/></td></tr>
<tr class="separator:abfdbd84451e2f19f44d453c9a71835eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b6af07042af55cb056c6534ab02ae4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a02b6af07042af55cb056c6534ab02ae4">mainDeviceCount</a> (void) const </td></tr>
<tr class="memdesc:a02b6af07042af55cb056c6534ab02ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of main devices.  <a href="#a02b6af07042af55cb056c6534ab02ae4"></a><br/></td></tr>
<tr class="separator:a02b6af07042af55cb056c6534ab02ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fecb52cb85a7150ab3b5895f823e374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8fecb52cb85a7150ab3b5895f823e374">mainDeviceIds</a> (void) const </td></tr>
<tr class="memdesc:a8fecb52cb85a7150ab3b5895f823e374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available main devices.  <a href="#a8fecb52cb85a7150ab3b5895f823e374"></a><br/></td></tr>
<tr class="separator:a8fecb52cb85a7150ab3b5895f823e374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dae55abd64daeb1a88cbc9f8e55777"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a94dae55abd64daeb1a88cbc9f8e55777">mtCount</a> (void) const </td></tr>
<tr class="memdesc:a94dae55abd64daeb1a88cbc9f8e55777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected MTs.  <a href="#a94dae55abd64daeb1a88cbc9f8e55777"></a><br/></td></tr>
<tr class="separator:a94dae55abd64daeb1a88cbc9f8e55777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b81e6e2056cbee49272335e93b3584d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6b81e6e2056cbee49272335e93b3584d">mtDeviceIds</a> (void) const </td></tr>
<tr class="memdesc:a6b81e6e2056cbee49272335e93b3584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available MTs.  <a href="#a6b81e6e2056cbee49272335e93b3584d"></a><br/></td></tr>
<tr class="separator:a6b81e6e2056cbee49272335e93b3584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfac6d3619be75bdb81855fc4a8c8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aedfac6d3619be75bdb81855fc4a8c8ed">deviceIds</a> (void) const </td></tr>
<tr class="memdesc:aedfac6d3619be75bdb81855fc4a8c8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of all the connected devices.  <a href="#aedfac6d3619be75bdb81855fc4a8c8ed"></a><br/></td></tr>
<tr class="separator:aedfac6d3619be75bdb81855fc4a8c8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c2a1fcbd5d953565e936386d1c165b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a51c2a1fcbd5d953565e936386d1c165b">getDeviceIdFromLocationId</a> (uint16_t locationId) const </td></tr>
<tr class="memdesc:a51c2a1fcbd5d953565e936386d1c165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of the device on the given <em>locationId</em>.  <a href="#a51c2a1fcbd5d953565e936386d1c165b"></a><br/></td></tr>
<tr class="separator:a51c2a1fcbd5d953565e936386d1c165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77aaaa30c35b154fe843fa193fccb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ac77aaaa30c35b154fe843fa193fccb67">dockDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:ac77aaaa30c35b154fe843fa193fccb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of the dock device for the given <em>deviceId</em>.  <a href="#ac77aaaa30c35b154fe843fa193fccb67"></a><br/></td></tr>
<tr class="separator:ac77aaaa30c35b154fe843fa193fccb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644e0cd86bc9aafab800fd27770d4db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a644e0cd86bc9aafab800fd27770d4db4">isDeviceWireless</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:a644e0cd86bc9aafab800fd27770d4db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected.  <a href="#a644e0cd86bc9aafab800fd27770d4db4"></a><br/></td></tr>
<tr class="separator:a644e0cd86bc9aafab800fd27770d4db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34eed83d36127b1eef98a3f9d5cc01d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae34eed83d36127b1eef98a3f9d5cc01d">isDeviceDocked</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:ae34eed83d36127b1eef98a3f9d5cc01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is an MTw and whether it is docked (or USB connected).  <a href="#ae34eed83d36127b1eef98a3f9d5cc01d"></a><br/></td></tr>
<tr class="separator:ae34eed83d36127b1eef98a3f9d5cc01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9720f314343d0bc679e5d19d077086d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9720f314343d0bc679e5d19d077086d4">setQueueMode</a> (<a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> mode)</td></tr>
<tr class="memdesc:a9720f314343d0bc679e5d19d077086d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the queue mode to the given <em>mode</em>.  <a href="#a9720f314343d0bc679e5d19d077086d4"></a><br/></td></tr>
<tr class="separator:a9720f314343d0bc679e5d19d077086d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af14e5ee745c50f4565078861c5d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a10af14e5ee745c50f4565078861c5d70">queueMode</a> (void) const </td></tr>
<tr class="memdesc:a10af14e5ee745c50f4565078861c5d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently used queue mode.  <a href="#a10af14e5ee745c50f4565078861c5d70"></a><br/></td></tr>
<tr class="separator:a10af14e5ee745c50f4565078861c5d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e2ba28d2710417b2e321520597a14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a700e2ba28d2710417b2e321520597a14">loadFilterProfiles</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a700e2ba28d2710417b2e321520597a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load filter profile definitions from a settings file with the given <em>filename</em>.  <a href="#a700e2ba28d2710417b2e321520597a14"></a><br/></td></tr>
<tr class="separator:a700e2ba28d2710417b2e321520597a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc1b909edb8a34b0935efbb31d8e841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0cc1b909edb8a34b0935efbb31d8e841">setOptionEnabled</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option, bool enabled)</td></tr>
<tr class="memdesc:a0cc1b909edb8a34b0935efbb31d8e841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristently enable or disable an option.  <a href="#a0cc1b909edb8a34b0935efbb31d8e841"></a><br/></td></tr>
<tr class="separator:a0cc1b909edb8a34b0935efbb31d8e841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d5dcdaf496a1fadba2b6e4e3f2503"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4e8d5dcdaf496a1fadba2b6e4e3f2503">isOptionEnabled</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> option) const </td></tr>
<tr class="memdesc:a4e8d5dcdaf496a1fadba2b6e4e3f2503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an option is persistently enabled or not.  <a href="#a4e8d5dcdaf496a1fadba2b6e4e3f2503"></a><br/></td></tr>
<tr class="separator:a4e8d5dcdaf496a1fadba2b6e4e3f2503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b1fba7b2b70c59f7fa09a27deb3815"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a89b1fba7b2b70c59f7fa09a27deb3815">setLatLonAlt</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;lla)</td></tr>
<tr class="memdesc:a89b1fba7b2b70c59f7fa09a27deb3815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current GPS position of the system.  <a href="#a89b1fba7b2b70c59f7fa09a27deb3815"></a><br/></td></tr>
<tr class="separator:a89b1fba7b2b70c59f7fa09a27deb3815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a3e46365b0381eb5bdecec5c66014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a1f9a3e46365b0381eb5bdecec5c66014">device</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:a1f9a3e46365b0381eb5bdecec5c66014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface object associated with the supplied <em>deviceId</em>.  <a href="#a1f9a3e46365b0381eb5bdecec5c66014"></a><br/></td></tr>
<tr class="separator:a1f9a3e46365b0381eb5bdecec5c66014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ca3e78e879d72befb8454e60a847f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af4ca3e78e879d72befb8454e60a847f8">mainDevices</a> (void) const </td></tr>
<tr class="memdesc:af4ca3e78e879d72befb8454e60a847f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface objects.  <a href="#af4ca3e78e879d72befb8454e60a847f8"></a><br/></td></tr>
<tr class="separator:af4ca3e78e879d72befb8454e60a847f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e5245b55d5423b0cb42f5dc37e8afd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a90e5245b55d5423b0cb42f5dc37e8afd">broadcast</a> (void) const </td></tr>
<tr class="memdesc:a90e5245b55d5423b0cb42f5dc37e8afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the broadcast device.  <a href="#a90e5245b55d5423b0cb42f5dc37e8afd"></a><br/></td></tr>
<tr class="separator:a90e5245b55d5423b0cb42f5dc37e8afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33c5f8f9417b79aa830e65cdeec2d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae33c5f8f9417b79aa830e65cdeec2d0e">testSynchronization</a> (void)</td></tr>
<tr class="memdesc:ae33c5f8f9417b79aa830e65cdeec2d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the connected main devices are hardware-synchronized.  <a href="#ae33c5f8f9417b79aa830e65cdeec2d0e"></a><br/></td></tr>
<tr class="separator:ae33c5f8f9417b79aa830e65cdeec2d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f24c9ba286897b176f4fb8efd0f285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a30f24c9ba286897b176f4fb8efd0f285">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:a30f24c9ba286897b176f4fb8efd0f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="#a30f24c9ba286897b176f4fb8efd0f285"></a><br/></td></tr>
<tr class="separator:a30f24c9ba286897b176f4fb8efd0f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189065247d7fb3758a355c403c68866d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a189065247d7fb3758a355c403c68866d">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a189065247d7fb3758a355c403c68866d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="#a189065247d7fb3758a355c403c68866d"></a><br/></td></tr>
<tr class="separator:a189065247d7fb3758a355c403c68866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8b49db27bd202e7b2f5d24468ec34bd1">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#a8b49db27bd202e7b2f5d24468ec34bd1"></a><br/></td></tr>
<tr class="separator:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370ec5f19b1c42b23d9d7abd453787c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a370ec5f19b1c42b23d9d7abd453787c4">~XsControl</a> ()</td></tr>
<tr class="memdesc:a370ec5f19b1c42b23d9d7abd453787c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, calls <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function to clean up object.  <a href="#a370ec5f19b1c42b23d9d7abd453787c4"></a><br/></td></tr>
<tr class="separator:a370ec5f19b1c42b23d9d7abd453787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a025a2b6f7542f1f731028633fab21562"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a025a2b6f7542f1f731028633fab21562"></a>
static <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562">construct</a> (void)</td></tr>
<tr class="memdesc:a025a2b6f7542f1f731028633fab21562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new XsControl* object. Clean it up with the <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function. <br/></td></tr>
<tr class="separator:a025a2b6f7542f1f731028633fab21562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6673814556e4a0b2120962324104a87"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ab6673814556e4a0b2120962324104a87">setSerialKey</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;key)</td></tr>
<tr class="memdesc:ab6673814556e4a0b2120962324104a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the serial key for XDA.  <a href="#ab6673814556e4a0b2120962324104a87"></a><br/></td></tr>
<tr class="separator:ab6673814556e4a0b2120962324104a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0bbc6a90441f4f6fca7acc1ed94132"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0d0bbc6a90441f4f6fca7acc1ed94132">version</a> (void)</td></tr>
<tr class="memdesc:a0d0bbc6a90441f4f6fca7acc1ed94132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version of the XDA dll.  <a href="#a0d0bbc6a90441f4f6fca7acc1ed94132"></a><br/></td></tr>
<tr class="separator:a0d0bbc6a90441f4f6fca7acc1ed94132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7dab3c9babc9f30368db489a77b45a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6d7dab3c9babc9f30368db489a77b45a">libraryPath</a> (void)</td></tr>
<tr class="memdesc:a6d7dab3c9babc9f30368db489a77b45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical path of the XDA dll.  <a href="#a6d7dab3c9babc9f30368db489a77b45a"></a><br/></td></tr>
<tr class="separator:a6d7dab3c9babc9f30368db489a77b45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6e97e9dad8eea2681994d9d31cd272"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">resultText</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> resultCode)</td></tr>
<tr class="memdesc:aee6e97e9dad8eea2681994d9d31cd272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptive text for the given <em>resultCode</em>.  <a href="#aee6e97e9dad8eea2681994d9d31cd272"></a><br/></td></tr>
<tr class="separator:aee6e97e9dad8eea2681994d9d31cd272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae048b7cbd1cfa3f5a2947ddc3162db9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae048b7cbd1cfa3f5a2947ddc3162db9b">setLogPath</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;path)</td></tr>
<tr class="memdesc:ae048b7cbd1cfa3f5a2947ddc3162db9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path where the xda.log file will be written.  <a href="#ae048b7cbd1cfa3f5a2947ddc3162db9b"></a><br/></td></tr>
<tr class="separator:ae048b7cbd1cfa3f5a2947ddc3162db9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab6dc054a1f43f78b97ef132689df0109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6dc054a1f43f78b97ef132689df0109"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ab6dc054a1f43f78b97ef132689df0109">operator delete</a> (void *)</td></tr>
<tr class="memdesc:ab6dc054a1f43f78b97ef132689df0109"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded delete operator to allow user to use delete instead of calling <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function <br/></td></tr>
<tr class="separator:ab6dc054a1f43f78b97ef132689df0109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581ed8c305367d1d4df972b8d8ff1c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4581ed8c305367d1d4df972b8d8ff1c8">XsControl</a> ()</td></tr>
<tr class="memdesc:a4581ed8c305367d1d4df972b8d8ff1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562" title="Construct a new XsControl* object. Clean it up with the destruct() function.">construct()</a> function instead.  <a href="#a4581ed8c305367d1d4df972b8d8ff1c8"></a><br/></td></tr>
<tr class="separator:a4581ed8c305367d1d4df972b8d8ff1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ca40a1716e4bde890f6d3629a7beca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4ca40a1716e4bde890f6d3629a7beca"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ab4ca40a1716e4bde890f6d3629a7beca">operator new</a> (size_t)</td></tr>
<tr class="memdesc:ab4ca40a1716e4bde890f6d3629a7beca"><td class="mdescLeft">&#160;</td><td class="mdescRight">new operator not implemented to prevent faulty memory allocation by user, use <a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562" title="Construct a new XsControl* object. Clean it up with the destruct() function.">construct()</a> function instead <br/></td></tr>
<tr class="separator:ab4ca40a1716e4bde890f6d3629a7beca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848d31e9cedbf8aa4187dfc54a59b6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9848d31e9cedbf8aa4187dfc54a59b6b"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9848d31e9cedbf8aa4187dfc54a59b6b">operator new[]</a> (size_t)</td></tr>
<tr class="memdesc:a9848d31e9cedbf8aa4187dfc54a59b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">array new operator not implemented to prevent faulty memory allocation by user, use <a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562" title="Construct a new XsControl* object. Clean it up with the destruct() function.">construct()</a> function instead <br/></td></tr>
<tr class="separator:a9848d31e9cedbf8aa4187dfc54a59b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dfd00660d1bf038894cbd55a0306d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7dfd00660d1bf038894cbd55a0306d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af7dfd00660d1bf038894cbd55a0306d1">operator delete[]</a> (void *)</td></tr>
<tr class="memdesc:af7dfd00660d1bf038894cbd55a0306d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">array delete operator not implemented to prevent faulty memory deallocation by user, use <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function instead <br/></td></tr>
<tr class="separator:af7dfd00660d1bf038894cbd55a0306d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>High level Motion Tracker (MT) management class. </p>
<p>CMT version 2 and higher do not use the explicit error codes that CMT version 1 used. Most functions return a boolean indicating success, a null-object, empty lists or nothing at all. In some cases more in-depth knowledge of the last error is required. For these occasions, use <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> or <a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec" title="Get the text for the value returned by lastResult()">lastResultText()</a> to find out what exactly went wrong.</p>
<dl class="section note"><dt>Note</dt><dd>This object cannot be copied. The copy constructor has been disabled. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a370ec5f19b1c42b23d9d7abd453787c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::~XsControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, calls <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it.">destruct()</a> function to clean up object. </p>
<p>Destroy this XsensDeviceAPI object.</p>
<p>All connected devices are put in config mode. All serial ports and files are subsequently closed. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3" title="Close all ports and files.">close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4581ed8c305367d1d4df972b8d8ff1c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::XsControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor not implemented to prevent faulty memory allocation, use <a class="el" href="struct_xs_control.html#a025a2b6f7542f1f731028633fab21562" title="Construct a new XsControl* object. Clean it up with the destruct() function.">construct()</a> function instead. </p>
<p>Construct a new Xsens Device API control object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a189065247d7fb3758a355c403c68866d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a90e5245b55d5423b0cb42f5dc37e8afd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the broadcast device. </p>
<p>The broadcast device can be used to apply an operation to all connected devices at once (if they support it) </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> pointer representing the broadcast device </dd></dl>

</div>
</div>
<a class="anchor" id="a30f24c9ba286897b176f4fb8efd0f285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all connected devices as well (true, default) or just the callback handlers of the XsControl object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0281f1055d6080734ce67526e2210fd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close all ports and files. </p>
<p>All devices are put in config mode before the serial port is closed. </p>

</div>
</div>
<a class="anchor" id="a9b3617d4a55cf48ddf7257788e1d5a79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portname</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portname</td><td>the name of the port to close (e.g. COM1 on Windows, /dev/ttyUSB0 on Linux) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee2a3ac5d55588c89de12347b17304a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the port that is used for communication with the given <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The device ID to clos eth port for. When 0, the first available port is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the port hosts multiple devices, this function will make all devices connected to the port invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a16ce0525bfbd2726822d8d04306f8ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the serial port that matches <em>portinfo</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>A port information structure that contains the name of the port to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79" title="Close the serial port with the given portname.">closePort(const XsString&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a47afe51569172239121d6f0520b93d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portNr</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portNr</td><td>The COM port number of the port that should be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only available on Windows systems </dd></dl>

</div>
</div>
<a class="anchor" id="a1f9a3e46365b0381eb5bdecec5c66014"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface object associated with the supplied <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The ID of the device to return, 0 to return the first available main device or XS_DID_BROADCAST to return the broadcast device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> attached to the <em>deviceId</em> or 0 if the device was not found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a90e5245b55d5423b0cb42f5dc37e8afd" title="Returns the broadcast device.">broadcast()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abfdbd84451e2f19f44d453c9a71835eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::deviceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of connected devices. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of connected devices </dd></dl>

</div>
</div>
<a class="anchor" id="aedfac6d3619be75bdb81855fc4a8c8ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::deviceIds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of all the connected devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the device IDs of all the connected devices. </dd></dl>

</div>
</div>
<a class="anchor" id="ac77aaaa30c35b154fe843fa193fccb67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsControl::dockDeviceId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device ID of the dock device for the given <em>deviceId</em>. </p>
<p>This function returns the ID of the docking station that deviceId is plugged into. If the docking station itself is not an open port in this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> or the device is not plugged into a docking station, the function will return a 0 id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to find the dock parent for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the device that has <em>deviceId</em> docked</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>mainDevice(), isMTwDocked() </dd></dl>

</div>
</div>
<a class="anchor" id="a40aa4b38d3c19b733d0c1bf5e63dbb0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::flushInputBuffers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the inbound data buffers of all devices. </p>
<p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">complete</td><td>When false, only the processed data queue is cleared. When true, the unprocessed data queue is also cleared. </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="a51c2a1fcbd5d953565e936386d1c165b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsControl::getDeviceIdFromLocationId </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>locationId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device ID of the device on the given <em>locationId</em>. </p>
<p>If the location ID is not found, the lastResult value is set and the function returns an null <a class="el" href="struct_xs_device_id.html" title="Contains an Xsens device ID and provides operations for determining the type of device.">XsDeviceId</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationId</td><td>the location ID of the device we're looking for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the device for <em>locationId</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae34eed83d36127b1eef98a3f9d5cc01d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isDeviceDocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is an MTw and whether it is docked (or USB connected). </p>
<p>The function checks if the master device ID is the same as the device ID. If the device ID is not found, the function returns false and the lastResult value is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is docked, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a644e0cd86bc9aafab800fd27770d4db4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isDeviceWireless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected. </p>
<p>If the device ID is not found, the function returns false and the lastResult value is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is wirelessly connected, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a4e8d5dcdaf496a1fadba2b6e4e3f2503"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isOptionEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether an option is persistently enabled or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled peristently in the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> object. This does not mean it is enabled in all connected devices, since it may have been disabled in specific devices by the user. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a0cc1b909edb8a34b0935efbb31d8e841" title="Peristently enable or disable an option.">setOptionEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6552d32d161eb719c0ca469385581c2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::lastResult </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the result value of the last operation. </p>
<p>The result values are codes that describe a failure in more detail. </p>
<dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec" title="Get the text for the value returned by lastResult()">lastResultText()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3caf40d684b29db2c89f98b0c9cd9ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::lastResultText </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text for the value returned by <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </p>
<p>This is a convenience function for </p>
<div class="fragment"><div class="line"><a class="code" href="struct_xs_string.html" title="A 0-terminated managed string of characters.">XsString</a> lastResultText = <a class="code" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">XsControl::resultText</a>(xscontrol-&gt;lastResult());</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode.">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d7dab3c9babc9f30368db489a77b45a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::libraryPath </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the physical path of the XDA dll. </p>
<p>This only works on Windows platforms. </p>
<dl class="section return"><dt>Returns</dt><dd>The path where the XDA dll is located. </dd></dl>

</div>
</div>
<a class="anchor" id="a700e2ba28d2710417b2e321520597a14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::loadFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load filter profile definitions from a settings file with the given <em>filename</em>. </p>
<p>To use the filtering properly, XDA requires filter settings usually stored in a scenarios.xsb file. XSB is the Xsens Settings Binary format. This function allows you to specify the full path + filename to use instead of the default filter profiles embedded in the dll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full path+filename to use for loading the parameters. When empty, the default filter profiles are loaded. On Linux this is "./scenarios.xsb", on Windows it is read from the dll resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a02b6af07042af55cb056c6534ab02ae4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::mainDeviceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of main devices. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of main devices </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a8fecb52cb85a7150ab3b5895f823e374" title="Get the device IDs of the available main devices.">mainDeviceIds()</a>, mainDeviceId(const XsDeviceId&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a8fecb52cb85a7150ab3b5895f823e374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::mainDeviceIds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of the available main devices. </p>
<p>Main devices are the devices communicating with the serial port, typically Xbus Masters, AwindA Stations and stand-alone MTis or MTxs. </p>
<dl class="section return"><dt>Returns</dt><dd>a std::vector with the device IDs. </dd></dl>

</div>
</div>
<a class="anchor" id="af4ca3e78e879d72befb8454e60a847f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> XsControl::mainDevices </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> interface objects. </p>
<dl class="section return"><dt>Returns</dt><dd>A list containing pointers to the main device <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object.">XsDevice</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="a94dae55abd64daeb1a88cbc9f8e55777"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::mtCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of connected MTs. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of MTs, including both main and child devices.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a6b81e6e2056cbee49272335e93b3584d" title="Get the device IDs of the available MTs.">mtDeviceIds()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b81e6e2056cbee49272335e93b3584d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::mtDeviceIds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of the available MTs. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector with the device IDs. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a94dae55abd64daeb1a88cbc9f8e55777" title="Get the number of connected MTs.">mtCount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae19d4bbf1c8331a77c1583800314fb60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the log file with the given <em>filename</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>True is the file was opened successfully. False if an error was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the file to open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a>, loadLogFile(), logFileName() </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcd5f3427b7509b07baf64650e56dbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel on serial port with the given <em>portname</em>. </p>
<p>If opening the port is successful, the connected devices are available through the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> interface.</p>
<p>The expected value for <em>portname</em> on Microsoft Windows platforms is "COMx" where x is the port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portname</td><td>The name of the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#ace2f1637761664f1828e4d7895cdb453" title="Open a communication channel to the given COM portNr.">openPort(int, XsBaudRate, uint32_t, bool)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae7f3a38146617728cea9490fa3c98fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel using the details in the supplied XsPortInfo structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>Contains the details of the port to open </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>openPort(const XsString &amp;, XsBaudRate, uint32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="ace2f1637761664f1828e4d7895cdb453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>portNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XsBaudRate&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel to the given COM <em>portNr</em>. </p>
<p>This is a convenience overload for openPort(const XsString&amp;, XsBaudRate, bool). This function is available on Microsoft Windows only due to the ambiguous nature of port numbers on other platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portNr</td><td>The port number. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port was opened successfully, false otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd" title="Open a communication channel on serial port with the given portname.">openPort(const XsString&amp;, XsBaudRate, uint32_t, bool)</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation.">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10af14e5ee745c50f4565078861c5d70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a> XsControl::queueMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently used queue mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently selected queue mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a9720f314343d0bc679e5d19d077086d4" title="Set the queue mode to the given mode.">setQueueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a45b86ccc2b443f1c2bfd6c99fefcfe34" title="Get the currently used queue mode.">XsDevice::queueMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b49db27bd202e7b2f5d24468ec34bd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="aee6e97e9dad8eea2681994d9d31cd272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::resultText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>resultCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a descriptive text for the given <em>resultCode</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultCode</td><td>The result code to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>resultCode</em> translated into an XsString </dd></dl>

</div>
</div>
<a class="anchor" id="a89b1fba7b2b70c59f7fa09a27deb3815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::setLatLonAlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lla</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current GPS position of the system. </p>
<p>This function will update the Latitude, Longitude and Altitude of the system and all connected devices. This differs from <a class="el" href="struct_xs_control.html#a90e5245b55d5423b0cb42f5dc37e8afd" title="Returns the broadcast device.">broadcast()</a>-&gt;<a class="el" href="struct_xs_control.html#a89b1fba7b2b70c59f7fa09a27deb3815" title="Sets the current GPS position of the system.">setLatLonAlt()</a> in that the setting is persistent for the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class.">XsControl</a> and will be applied to devices connected after the setting has been made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>A vector containing the desired Latitude, Longitude and Altitude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true since the function always succeeds, the boolean return value is for consistency in the interface. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_device.html#a1e3b2eb82952163acc7db94deeebbf7a" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector.">XsDevice::setLatLonAlt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae048b7cbd1cfa3f5a2947ddc3162db9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setLogPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the path where the xda.log file will be written. </p>
<p>The xda.log file contains fatal error information and may be useful to determine the cause of application crashes. By default, XDA does not create a log file until this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path where the xda.log should be written, including trailing slash (eg. "C:\\logs\\") </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cc1b909edb8a34b0935efbb31d8e841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setOptionEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peristently enable or disable an option. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data. The default state of these options is enabled. On a system with limited resources it may be useful to limit the processing done by XDA. This function remembers the setting and applies it to new devices when they are created as well as broadcasting it to existing devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option to enable or disable </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some options depend on each other and thus can cause other options to become enabled or disabled as well. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a4e8d5dcdaf496a1fadba2b6e4e3f2503" title="Returns whether an option is persistently enabled or not.">isOptionEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9720f314343d0bc679e5d19d077086d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setQueueMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga4a1c2443ecb8b093eda10fff7c160f95">XsQueueMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the queue mode to the given <em>mode</em>. </p>
<p>Indicate if a readData call for a live system should get the latest data or the next in queue data or nothing at all. The default queue mode is XQM_CallbackOnly, which means that data is not queued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the new queue mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_xs_control.html#a10af14e5ee745c50f4565078861c5d70" title="Get the currently used queue mode.">queueMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac404b469ed2b928365d5a6ff63ee81ea" title="Set the queue mode to the given mode.">XsDevice::setQueueMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6673814556e4a0b2120962324104a87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::setSerialKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the serial key for XDA. </p>
<p>Without a valid key XDA will not create any devices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the serial key to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the serial key validates OK, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ae33c5f8f9417b79aa830e65cdeec2d0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::testSynchronization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the connected main devices are hardware-synchronized. </p>
<p>The function will check synchronization settings and initiate some measurements to determine whether the synchronization is correct. </p>
<dl class="section return"><dt>Returns</dt><dd>The function returns XRV_OK when ALL connected devices are synchronized. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should only be called in config mode and only on live devices or it will return an error value. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0bbc6a90441f4f6fca7acc1ed94132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsControl::version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the version of the XDA dll. </p>
<dl class="section return"><dt>Returns</dt><dd>The version information of the XDA dll. </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Thu Jan 16 2014 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.2</small>
</address>
</body>
</html>
